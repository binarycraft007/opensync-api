
/*
 * plume-customer
 *
 * Customer APIs for NOC, IOS, Android, QA scripts, and www.plume.com
 *
 * API version: 1.109.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
	"time"
)

// Linger please
var (
	_ context.Context
)

type CustomerApiService service

/*
CustomerApiService Confirm a user registration with identity verification token.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uid
 * @param token
 * @param optional nil or *CustomerApiCustomerConfirmOpts - Optional Parameters:
     * @param "Redirect" (optional.String) - 


*/

type CustomerApiCustomerConfirmOpts struct { 
	Redirect optional.String
}

func (a *CustomerApiService) CustomerConfirm(ctx context.Context, uid string, token string, localVarOptionals *CustomerApiCustomerConfirmOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/confirm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("uid", parameterToString(uid, ""))
	localVarQueryParams.Add("token", parameterToString(token, ""))
	if localVarOptionals != nil && localVarOptionals.Redirect.IsSet() {
		localVarQueryParams.Add("redirect", parameterToString(localVarOptionals.Redirect.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Count instances of the model matched by where from the data source.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CustomerApiCustomerCountOpts - Optional Parameters:
     * @param "Where" (optional.String) -  Criteria to match model instances

@return InlineResponse2001
*/

type CustomerApiCustomerCountOpts struct { 
	Where optional.String
}

func (a *CustomerApiService) CustomerCount(ctx context.Context, localVarOptionals *CustomerApiCustomerCountOpts) (InlineResponse2001, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2001
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Where.IsSet() {
		localVarQueryParams.Add("where", parameterToString(localVarOptionals.Where.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2001
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create or update a Plume NOC user.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, user created.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Input validation failed.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param email
 * @param name
 * @param roles
 * @param optional nil or *CustomerApiCustomerCreateOrUpdateUserOpts - Optional Parameters:
     * @param "Groups" (optional.String) - 

@return Customer
*/

type CustomerApiCustomerCreateOrUpdateUserOpts struct { 
	Groups optional.String
}

func (a *CustomerApiService) CustomerCreateOrUpdateUser(ctx context.Context, email string, name string, roles string, localVarOptionals *CustomerApiCustomerCreateOrUpdateUserOpts) (Customer, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Customer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/createOrUpdateUser"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("email", parameterToString(email, ""))
	localVarFormParams.Add("name", parameterToString(name, ""))
	localVarFormParams.Add("roles", parameterToString(roles, ""))
	if localVarOptionals != nil && localVarOptionals.Groups.IsSet() {
		localVarFormParams.Add("groups", parameterToString(localVarOptionals.Groups.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Customer
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create a Plume customer.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, customer created.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Input validation failed.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CustomerApiCustomerCustomCreateOpts - Optional Parameters:
     * @param "Email" (optional.String) - 
     * @param "Password" (optional.String) - 
     * @param "Name" (optional.String) - 
     * @param "PartnerId" (optional.String) - 
     * @param "Person" (optional.String) -  Person object should contain field &#39;imageId&#39;  and object profile with field type (String)
     * @param "Location" (optional.String) -  Location object should contain field &#39;name&#39; (String)
     * @param "NotificationOptions" (optional.String) - 
     * @param "PasswordLessToken" (optional.Bool) - 
     * @param "Source" (optional.String) - 

@return Customer
*/

type CustomerApiCustomerCustomCreateOpts struct { 
	Email optional.String
	Password optional.String
	Name optional.String
	PartnerId optional.String
	Person optional.String
	Location optional.String
	NotificationOptions optional.String
	PasswordLessToken optional.Bool
	Source optional.String
}

func (a *CustomerApiService) CustomerCustomCreate(ctx context.Context, localVarOptionals *CustomerApiCustomerCustomCreateOpts) (Customer, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Customer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Email.IsSet() {
		localVarFormParams.Add("email", parameterToString(localVarOptionals.Email.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Password.IsSet() {
		localVarFormParams.Add("password", parameterToString(localVarOptionals.Password.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PartnerId.IsSet() {
		localVarFormParams.Add("partnerId", parameterToString(localVarOptionals.PartnerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Person.IsSet() {
		localVarFormParams.Add("person", parameterToString(localVarOptionals.Person.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarFormParams.Add("location", parameterToString(localVarOptionals.Location.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotificationOptions.IsSet() {
		localVarFormParams.Add("notificationOptions", parameterToString(localVarOptionals.NotificationOptions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PasswordLessToken.IsSet() {
		localVarFormParams.Add("passwordLessToken", parameterToString(localVarOptionals.PasswordLessToken.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Source.IsSet() {
		localVarFormParams.Add("source", parameterToString(localVarOptionals.Source.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Customer
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService 
Check if customer email exists and is known to Plume, pass email as parameter to /Customers/exists?email&#x3D;xxx@yyy.com &lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: customer email exists and is known to Plume, emailVerified returned&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: email is required&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer email does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: email is not valid&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CustomerApiCustomerEmailExistsOpts - Optional Parameters:
     * @param "Email" (optional.String) - 

@return bool
*/

type CustomerApiCustomerEmailExistsOpts struct { 
	Email optional.String
}

func (a *CustomerApiService) CustomerEmailExists(ctx context.Context, localVarOptionals *CustomerApiCustomerEmailExistsOpts) (bool, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue bool
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/exists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Email.IsSet() {
		localVarQueryParams.Add("email", parameterToString(localVarOptionals.Email.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v bool
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Generate two accessTokens with special scopes for the account with the email address and send a verification email.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, return new appToken, refreshToken and send out the email with emailToken.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Email must be defined and valid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param email
 * @param optional nil or *CustomerApiCustomerEmailPasswordlessTokenOpts - Optional Parameters:
     * @param "NotificationOptions" (optional.String) - 

@return AccessToken
*/

type CustomerApiCustomerEmailPasswordlessTokenOpts struct { 
	NotificationOptions optional.String
}

func (a *CustomerApiService) CustomerEmailPasswordlessToken(ctx context.Context, email string, localVarOptionals *CustomerApiCustomerEmailPasswordlessTokenOpts) (AccessToken, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AccessToken
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/passwordLessToken"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("email", parameterToString(email, ""))
	if localVarOptionals != nil && localVarOptionals.NotificationOptions.IsSet() {
		localVarFormParams.Add("notificationOptions", parameterToString(localVarOptionals.NotificationOptions.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v AccessToken
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Find all instances of the model matched by filter from the data source.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CustomerApiCustomerFindOpts - Optional Parameters:
     * @param "Filter" (optional.String) -  Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.

@return []Customer
*/

type CustomerApiCustomerFindOpts struct { 
	Filter optional.String
}

func (a *CustomerApiService) CustomerFind(ctx context.Context, localVarOptionals *CustomerApiCustomerFindOpts) ([]Customer, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Customer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Filter.IsSet() {
		localVarQueryParams.Add("filter", parameterToString(localVarOptionals.Filter.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []Customer
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Find a model instance by {{id}} from the data source.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Model id
 * @param optional nil or *CustomerApiCustomerFindByIdOpts - Optional Parameters:
     * @param "Filter" (optional.String) -  Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})

@return Customer
*/

type CustomerApiCustomerFindByIdOpts struct { 
	Filter optional.String
}

func (a *CustomerApiService) CustomerFindById(ctx context.Context, id string, localVarOptionals *CustomerApiCustomerFindByIdOpts) (Customer, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Customer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Filter.IsSet() {
		localVarQueryParams.Add("filter", parameterToString(localVarOptionals.Filter.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Customer
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Import customer data
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Nothing to import.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Import data is invalid.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param data
 * @param migratedFrom
 * @param reason

@return interface{}
*/
func (a *CustomerApiService) CustomerImportData(ctx context.Context, data string, migratedFrom string, reason string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/import"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("data", parameterToString(data, ""))
	localVarFormParams.Add("migratedFrom", parameterToString(migratedFrom, ""))
	localVarFormParams.Add("reason", parameterToString(reason, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Login a user with username/email and password.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param credentials
 * @param optional nil or *CustomerApiCustomerLoginOpts - Optional Parameters:
     * @param "Include" (optional.String) -  Related objects to include in the response. See the description of return value for more details.

@return interface{}
*/

type CustomerApiCustomerLoginOpts struct { 
	Include optional.String
}

func (a *CustomerApiService) CustomerLogin(ctx context.Context, credentials interface{}, localVarOptionals *CustomerApiCustomerLoginOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Include.IsSet() {
		localVarQueryParams.Add("include", parameterToString(localVarOptionals.Include.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &credentials
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Logout a user with access token.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().


*/
func (a *CustomerApiService) CustomerLogoutPostCustomersLogout(ctx context.Context) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/logout"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService DEPRECATED: Update home devices visible to guests.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, devicesVisibleToGuests returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Customer id, location id, or WifiNetwork does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Device mac validation failed.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac mac to be added

@return []string
*/
func (a *CustomerApiService) CustomerPrototypeAddDeviceVisibleToGuests(ctx context.Context, id string, locationId string, mac string) ([]string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork/accessZones/home/devicesVisibleToGuests/{mac}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Retrieve timezone, capabilities, summary, ... for this location.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, an array of properties returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeAppFacadeHomeOpts - Optional Parameters:
     * @param "Filters" (optional.String) - 
     * @param "DaysOffline" (optional.Float64) - 

@return AppFacadeHomeResponse
*/

type CustomerApiCustomerPrototypeAppFacadeHomeOpts struct { 
	Filters optional.String
	DaysOffline optional.Float64
}

func (a *CustomerApiService) CustomerPrototypeAppFacadeHome(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeAppFacadeHomeOpts) (AppFacadeHomeResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AppFacadeHomeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/appFacade/home"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Filters.IsSet() {
		localVarQueryParams.Add("filters", parameterToString(localVarOptionals.Filters.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DaysOffline.IsSet() {
		localVarQueryParams.Add("daysOffline", parameterToString(localVarOptionals.DaysOffline.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v AppFacadeHomeResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Approve devices in the network
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Network does not exist.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param macs

@return []string
*/
func (a *CustomerApiService) CustomerPrototypeApproveDevices(ctx context.Context, id string, locationId string, networkId string, macs []XAny) ([]string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkAccess/networks/{networkId}/approved"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &macs
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Approve a persons whitelist request and add it to the security policy.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: No content.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, CustomerId or requst id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param requestId
 * @param persons


*/
func (a *CustomerApiService) CustomerPrototypeApproveWhitelistRequest(ctx context.Context, id string, locationId string, requestId string, persons string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy/websites/whitelist/approvalRequests/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", fmt.Sprintf("%v", requestId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("persons", parameterToString(persons, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Block devices
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param macs

@return []string
*/
func (a *CustomerApiService) CustomerPrototypeBlockDevices(ctx context.Context, id string, locationId string, macs []XAny) ([]string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkAccess/blocked"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &macs
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Claim a node and all nodes still associated to its Package ID for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: King node claimed and all related claimed nodes are returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Valid serial number but zero new claimed nodes.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Unable to find Node with serial number, customer id, or location id.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;409&lt;/strong&gt;: Node is owned by another customer.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Claiming request exceeded numPodsAuthorized (&#x3D;leaf pods), accountId+partnerId not unique, and/or monitorMode&#x3D;true.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId location id
 * @param optional nil or *CustomerApiCustomerPrototypeClaimNodeOpts - Optional Parameters:
     * @param "SerialNumber" (optional.String) -  unique serial number or ID of Node
     * @param "RadioMac24" (optional.String) -  optional but required for auto-importing, must be a valid mac address
     * @param "RadioMac50" (optional.String) -  optional but required for auto-importing, must be a valid mac address
     * @param "RadioMac60" (optional.String) -  optional but required for auto-importing, must be a valid mac address
     * @param "EthernetMac" (optional.String) -  optional but required for auto-importing, must be a valid mac address
     * @param "Ethernet1Mac" (optional.String) -  optional but required for auto-importing, must be a valid mac address
     * @param "ClaimKey" (optional.String) -  optional but required for auto-importing, must be a valid claimKey
     * @param "Model" (optional.String) -  optional when auto-importing, ignored otherwise
     * @param "HybridCheck" (optional.Bool) -  optional when auto-importing, ignored otherwise
     * @param "Nickname" (optional.String) -  optional node nickname
     * @param "SkipSubscription" (optional.Bool) -  skip subscription update
     * @param "BackhaulDhcpPoolIdx" (optional.Float64) -  optional node backhaulDhcpPoolIdx
     * @param "Room" (optional.String) -  optional room identifier

@return NodeClaimingResponse
*/

type CustomerApiCustomerPrototypeClaimNodeOpts struct { 
	SerialNumber optional.String
	RadioMac24 optional.String
	RadioMac50 optional.String
	RadioMac60 optional.String
	EthernetMac optional.String
	Ethernet1Mac optional.String
	ClaimKey optional.String
	Model optional.String
	HybridCheck optional.Bool
	Nickname optional.String
	SkipSubscription optional.Bool
	BackhaulDhcpPoolIdx optional.Float64
	Room optional.String
}

func (a *CustomerApiService) CustomerPrototypeClaimNode(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeClaimNodeOpts) (NodeClaimingResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NodeClaimingResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodes"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.SkipSubscription.IsSet() {
		localVarQueryParams.Add("skipSubscription", parameterToString(localVarOptionals.SkipSubscription.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.SerialNumber.IsSet() {
		localVarFormParams.Add("serialNumber", parameterToString(localVarOptionals.SerialNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RadioMac24.IsSet() {
		localVarFormParams.Add("radioMac24", parameterToString(localVarOptionals.RadioMac24.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RadioMac50.IsSet() {
		localVarFormParams.Add("radioMac50", parameterToString(localVarOptionals.RadioMac50.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RadioMac60.IsSet() {
		localVarFormParams.Add("radioMac60", parameterToString(localVarOptionals.RadioMac60.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EthernetMac.IsSet() {
		localVarFormParams.Add("ethernetMac", parameterToString(localVarOptionals.EthernetMac.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ethernet1Mac.IsSet() {
		localVarFormParams.Add("ethernet1Mac", parameterToString(localVarOptionals.Ethernet1Mac.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClaimKey.IsSet() {
		localVarFormParams.Add("claimKey", parameterToString(localVarOptionals.ClaimKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Model.IsSet() {
		localVarFormParams.Add("model", parameterToString(localVarOptionals.Model.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HybridCheck.IsSet() {
		localVarFormParams.Add("hybridCheck", parameterToString(localVarOptionals.HybridCheck.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Nickname.IsSet() {
		localVarFormParams.Add("nickname", parameterToString(localVarOptionals.Nickname.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackhaulDhcpPoolIdx.IsSet() {
		localVarFormParams.Add("backhaulDhcpPoolIdx", parameterToString(localVarOptionals.BackhaulDhcpPoolIdx.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Room.IsSet() {
		localVarFormParams.Add("room", parameterToString(localVarOptionals.Room.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NodeClaimingResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Creates a new instance in accessTokens of this model.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param optional nil or *CustomerApiCustomerPrototypeCreateAccessTokensOpts - Optional Parameters:
     * @param "Data" (optional.Interface of AccessToken) - 

@return AccessToken
*/

type CustomerApiCustomerPrototypeCreateAccessTokensOpts struct { 
	Data optional.Interface
}

func (a *CustomerApiService) CustomerPrototypeCreateAccessTokens(ctx context.Context, id string, localVarOptionals *CustomerApiCustomerPrototypeCreateAccessTokensOpts) (AccessToken, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AccessToken
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/accessTokens"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		
		localVarOptionalData, localVarOptionalDataok := localVarOptionals.Data.Value().(AccessToken)
		if !localVarOptionalDataok {
				return localVarReturnValue, nil, reportError("data should be AccessToken")
		}
		localVarPostBody = &localVarOptionalData
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v AccessToken
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create access token to get marketing data by CRM for campaigns
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, accessToken returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param optional nil or *CustomerApiCustomerPrototypeCreateGetMarketingExportDataAccessTokenOpts - Optional Parameters:
     * @param "Ttl" (optional.Float64) - 

@return AccessToken
*/

type CustomerApiCustomerPrototypeCreateGetMarketingExportDataAccessTokenOpts struct { 
	Ttl optional.Float64
}

func (a *CustomerApiService) CustomerPrototypeCreateGetMarketingExportDataAccessToken(ctx context.Context, id string, localVarOptionals *CustomerApiCustomerPrototypeCreateGetMarketingExportDataAccessTokenOpts) (AccessToken, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AccessToken
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/createGetMarketingExportDataAccessToken"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Ttl.IsSet() {
		localVarFormParams.Add("ttl", parameterToString(localVarOptionals.Ttl.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v AccessToken
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create access token with limited privileges as defined for IP authenticated customers
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, response object returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param optional nil or *CustomerApiCustomerPrototypeCreateIpLimitedAccessTokenOpts - Optional Parameters:
     * @param "Ttl" (optional.Float64) - 

@return AccessToken
*/

type CustomerApiCustomerPrototypeCreateIpLimitedAccessTokenOpts struct { 
	Ttl optional.Float64
}

func (a *CustomerApiService) CustomerPrototypeCreateIpLimitedAccessToken(ctx context.Context, id string, localVarOptionals *CustomerApiCustomerPrototypeCreateIpLimitedAccessTokenOpts) (AccessToken, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AccessToken
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/createIpLimitedAccessToken"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Ttl.IsSet() {
		localVarFormParams.Add("ttl", parameterToString(localVarOptionals.Ttl.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v AccessToken
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create a new location.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required field(the location name) missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param name
 * @param optional nil or *CustomerApiCustomerPrototypeCreateLocationOpts - Optional Parameters:
     * @param "Profile" (optional.String) - 

@return XAny
*/

type CustomerApiCustomerPrototypeCreateLocationOpts struct { 
	Profile optional.String
}

func (a *CustomerApiService) CustomerPrototypeCreateLocation(ctx context.Context, id string, name string, localVarOptionals *CustomerApiCustomerPrototypeCreateLocationOpts) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	if localVarOptionals != nil && localVarOptionals.Profile.IsSet() {
		localVarFormParams.Add("profile", parameterToString(localVarOptionals.Profile.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Creates a new instance in _migration of this model.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param optional nil or *CustomerApiCustomerPrototypeCreateMigrationOpts - Optional Parameters:
     * @param "Data" (optional.Interface of Migration) - 

@return Migration
*/

type CustomerApiCustomerPrototypeCreateMigrationOpts struct { 
	Data optional.Interface
}

func (a *CustomerApiService) CustomerPrototypeCreateMigration(ctx context.Context, id string, localVarOptionals *CustomerApiCustomerPrototypeCreateMigrationOpts) (Migration, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Migration
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/_migration"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		
		localVarOptionalData, localVarOptionalDataok := localVarOptionals.Data.Value().(Migration)
		if !localVarOptionalDataok {
				return localVarReturnValue, nil, reportError("data should be Migration")
		}
		localVarPostBody = &localVarOptionalData
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Migration
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Generates usable passwordless accessToken for the account with the email address.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, return new appToken.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id

@return AccessToken
*/
func (a *CustomerApiService) CustomerPrototypeCreateNewPasswordlessToken(ctx context.Context, id string) (AccessToken, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AccessToken
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/accessToken"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v AccessToken
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create access token with ouath scope.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, access token created and returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization Required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param optional nil or *CustomerApiCustomerPrototypeCreateOauthAccessTokenOpts - Optional Parameters:
     * @param "Scope" (optional.String) - 
     * @param "TtlSeconds" (optional.Float64) - 
     * @param "SingleToken" (optional.Bool) - 

@return AccessToken
*/

type CustomerApiCustomerPrototypeCreateOauthAccessTokenOpts struct { 
	Scope optional.String
	TtlSeconds optional.Float64
	SingleToken optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeCreateOauthAccessToken(ctx context.Context, id string, localVarOptionals *CustomerApiCustomerPrototypeCreateOauthAccessTokenOpts) (AccessToken, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AccessToken
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/createOauthAccessToken"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Scope.IsSet() {
		localVarFormParams.Add("scope", parameterToString(localVarOptionals.Scope.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TtlSeconds.IsSet() {
		localVarFormParams.Add("ttlSeconds", parameterToString(localVarOptionals.TtlSeconds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SingleToken.IsSet() {
		localVarFormParams.Add("singleToken", parameterToString(localVarOptionals.SingleToken.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v AccessToken
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create refresh token for a specific access token with ouath scope.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, access token created and returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization Required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param optional nil or *CustomerApiCustomerPrototypeCreateOauthRefreshTokenOpts - Optional Parameters:
     * @param "LinkedAccessToken" (optional.String) - 
     * @param "PrevLinkedRefreshTokenId" (optional.String) - 
     * @param "ClientId" (optional.String) - 

@return AccessToken
*/

type CustomerApiCustomerPrototypeCreateOauthRefreshTokenOpts struct { 
	LinkedAccessToken optional.String
	PrevLinkedRefreshTokenId optional.String
	ClientId optional.String
}

func (a *CustomerApiService) CustomerPrototypeCreateOauthRefreshToken(ctx context.Context, id string, localVarOptionals *CustomerApiCustomerPrototypeCreateOauthRefreshTokenOpts) (AccessToken, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AccessToken
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/createOauthRefreshToken"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.LinkedAccessToken.IsSet() {
		localVarFormParams.Add("linkedAccessToken", parameterToString(localVarOptionals.LinkedAccessToken.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PrevLinkedRefreshTokenId.IsSet() {
		localVarFormParams.Add("prevLinkedRefreshTokenId", parameterToString(localVarOptionals.PrevLinkedRefreshTokenId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClientId.IsSet() {
		localVarFormParams.Add("clientId", parameterToString(localVarOptionals.ClientId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v AccessToken
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create access token to patch customer serviceLevel used by ZUORA
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, accessToken returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param optional nil or *CustomerApiCustomerPrototypeCreatePatchServiceLevelAccessTokenOpts - Optional Parameters:
     * @param "Ttl" (optional.Float64) - 

@return AccessToken
*/

type CustomerApiCustomerPrototypeCreatePatchServiceLevelAccessTokenOpts struct { 
	Ttl optional.Float64
}

func (a *CustomerApiService) CustomerPrototypeCreatePatchServiceLevelAccessToken(ctx context.Context, id string, localVarOptionals *CustomerApiCustomerPrototypeCreatePatchServiceLevelAccessTokenOpts) (AccessToken, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AccessToken
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/createPatchServiceLevelAccessToken"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Ttl.IsSet() {
		localVarFormParams.Add("ttl", parameterToString(localVarOptionals.Ttl.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v AccessToken
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create access token to read data related to DNS security policies
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, accessToken returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id

@return AccessToken
*/
func (a *CustomerApiService) CustomerPrototypeCreateReadDnsAccessToken(ctx context.Context, id string) (AccessToken, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AccessToken
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/createReadDnsAccessToken"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v AccessToken
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Delete/clear all device freezes templateIds for a mac.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac


*/
func (a *CustomerApiService) CustomerPrototypeDeleteAllDeviceFreezes(ctx context.Context, id string, locationId string, mac string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/freezes"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Set custom setting to default for app prioritization.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeDeleteAppPrioritizationLocationConfig(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/qos/appPrioritization/customSetting"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Delete a CaptivePortal for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id/NetworkId does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId


*/
func (a *CustomerApiService) CustomerPrototypeDeleteCaptivePortal(ctx context.Context, id string, locationId string, networkId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/{networkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete Authorized Client
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id/NetworkId does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param mac


*/
func (a *CustomerApiService) CustomerPrototypeDeleteCaptivePortalAuthorizedClients(ctx context.Context, id string, locationId string, networkId string, mac string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/{networkId}/authorizedClients/{mac}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete specified location settings, while keeping claimed nodes intact
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, a job well done.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required &lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id not found or nodeId missing from URL &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeDeleteConfigsOpts - Optional Parameters:
     * @param "Persons" (optional.Bool) -  Whether or not to delete person information
     * @param "OnboardingCheckpoints" (optional.Bool) -  Whether or not to delete onboarding checkpoints
     * @param "Devices" (optional.Bool) -  Whether or not to delete devices related information
     * @param "NetworkConfiguration" (optional.Bool) -  Whether or not to delete network configuration
     * @param "WifiNetwork" (optional.Bool) -  Whether or not to delete wifi network
     * @param "DeviceFreeze" (optional.Bool) -  Whether or not to delete device freeze templates
     * @param "DeviceNicknames" (optional.Bool) -  Whether or not to delete device nicknames
     * @param "Managers" (optional.Bool) -  Whether or not to delete managers of the location
     * @param "WanConfiguration" (optional.Bool) -  Whether or not to delete wanConfiguration


*/

type CustomerApiCustomerPrototypeDeleteConfigsOpts struct { 
	Persons optional.Bool
	OnboardingCheckpoints optional.Bool
	Devices optional.Bool
	NetworkConfiguration optional.Bool
	WifiNetwork optional.Bool
	DeviceFreeze optional.Bool
	DeviceNicknames optional.Bool
	Managers optional.Bool
	WanConfiguration optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeDeleteConfigs(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeDeleteConfigsOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/configs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Persons.IsSet() {
		localVarFormParams.Add("persons", parameterToString(localVarOptionals.Persons.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnboardingCheckpoints.IsSet() {
		localVarFormParams.Add("onboardingCheckpoints", parameterToString(localVarOptionals.OnboardingCheckpoints.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Devices.IsSet() {
		localVarFormParams.Add("devices", parameterToString(localVarOptionals.Devices.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NetworkConfiguration.IsSet() {
		localVarFormParams.Add("networkConfiguration", parameterToString(localVarOptionals.NetworkConfiguration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WifiNetwork.IsSet() {
		localVarFormParams.Add("wifiNetwork", parameterToString(localVarOptionals.WifiNetwork.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceFreeze.IsSet() {
		localVarFormParams.Add("deviceFreeze", parameterToString(localVarOptionals.DeviceFreeze.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceNicknames.IsSet() {
		localVarFormParams.Add("deviceNicknames", parameterToString(localVarOptionals.DeviceNicknames.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Managers.IsSet() {
		localVarFormParams.Add("managers", parameterToString(localVarOptionals.Managers.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WanConfiguration.IsSet() {
		localVarFormParams.Add("wanConfiguration", parameterToString(localVarOptionals.WanConfiguration.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete \&quot;custom shared\&quot; schedule shared by all persons and devices in a location.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, the custom shared schedule deleted.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id does not exist or is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param templateId


*/
func (a *CustomerApiService) CustomerPrototypeDeleteCustomSharedSchedule(ctx context.Context, id string, locationId string, templateId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/schedules/{templateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", fmt.Sprintf("%v", templateId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete a model instance by {{id}} from the data source.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, customer details returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization Required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeDeleteCustomer(ctx context.Context, id string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Delete a device to be frozen for a Location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: MAC address does not exist or is invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param freezeTemplateId Valid templates are &#39;untilMidinight&#39;, &#39;schoolNights&#39;, etc.


*/
func (a *CustomerApiService) CustomerPrototypeDeleteDeviceFreeze(ctx context.Context, id string, locationId string, mac string, freezeTemplateId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/freeze/{freezeTemplateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"freezeTemplateId"+"}", fmt.Sprintf("%v", freezeTemplateId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete a device to be frozen for a Location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac


*/
func (a *CustomerApiService) CustomerPrototypeDeleteDeviceFreezeAutoExpire(ctx context.Context, id string, locationId string, mac string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/freeze/autoExpire"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete a device forever freeze for a Location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: MAC address does not exist or is invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac


*/
func (a *CustomerApiService) CustomerPrototypeDeleteDeviceFreezeForever(ctx context.Context, id string, locationId string, mac string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/freeze/forever"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete a device residentialGwManaged freeze for a Location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: MAC address does not exist or is invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac


*/
func (a *CustomerApiService) CustomerPrototypeDeleteDeviceFreezeResidentialGwManaged(ctx context.Context, id string, locationId string, mac string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/freeze/residentialGwManaged"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete a device suspend for a Location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: MAC address does not exist or is invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac


*/
func (a *CustomerApiService) CustomerPrototypeDeleteDeviceFreezeSuspend(ctx context.Context, id string, locationId string, mac string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/freeze/suspend"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete a device mac from a WiFi Access Zone
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, all access zones returned&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Customer id, location id, or WifiNetwork does not exist&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Validation failed&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param zoneId id of access zone
 * @param mac the device mac to be added to the access zone

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypeDeleteDeviceFromAccessZone(ctx context.Context, id string, locationId string, zoneId float64, mac string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork/accessZones/{zoneId}/accessibleDevices/{mac}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", fmt.Sprintf("%v", zoneId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Unassign a device from Person for a location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, Person id, or mac does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId
 * @param mac


*/
func (a *CustomerApiService) CustomerPrototypeDeleteDeviceFromPerson(ctx context.Context, id string, locationId string, personId string, mac string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/devices/{mac}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete a device group from a network.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Schema validation failed.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;403&lt;/strong&gt;: Not allowed to delete standalone groups or groups in unsupported networks.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Unauthorized.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Invalid JSON or missing arguments.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param groupId


*/
func (a *CustomerApiService) CustomerPrototypeDeleteDeviceGroup(ctx context.Context, id string, locationId string, networkId string, groupId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkAccess/networks/{networkId}/deviceGroups/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", fmt.Sprintf("%v", groupId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete prioritization of a single device
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac

@return []XAny
*/
func (a *CustomerApiService) CustomerPrototypeDeleteDeviceQosPrioritization(ctx context.Context, id string, locationId string, mac string) ([]XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/qos/prioritization"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 204 {
			var v []XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Delete an Anomaly Experience (demo) for a Device on a location.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, Device does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac


*/
func (a *CustomerApiService) CustomerPrototypeDeleteDeviceSecurityPolicyAnomalyExperience(ctx context.Context, id string, locationId string, mac string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/securityPolicy/anomaly/experience"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Update a Location&#39;s Anomaly Security Policy for a location ID to remove a whitelisted DNS entry.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, Device or DNS does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param fqdn


*/
func (a *CustomerApiService) CustomerPrototypeDeleteDeviceSecurityPolicyAnomalyWhitelist(ctx context.Context, id string, locationId string, mac string, fqdn string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/securityPolicy/anomaly/websites/whitelist/{fqdn}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fqdn"+"}", fmt.Sprintf("%v", fqdn), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete a current DHCP IP reservation and the associated port forwarding entries for a particular MAC address at a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, remaining DhcpReservations are returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: NetworkConfiguration or DhcpReservation is empty.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: mac is empty or invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac

@return []DhcpReservation
*/
func (a *CustomerApiService) CustomerPrototypeDeleteDhcpReservation(ctx context.Context, id string, locationId string, mac string) ([]DhcpReservation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []DhcpReservation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkConfiguration/dhcpReservations/{mac}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []DhcpReservation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Disable 2.4Ghz band enforcement early.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, forced steer ended early.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location ID or Device mac not found or the device has not been online in the last 31 days&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId locationId
 * @param mac MAC address of the target device. Must have been online in the last 31 days.

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeDeleteForcedSteer(ctx context.Context, id string, locationId string, mac string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/forcedSteer"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a Device&#39;s Security Policy for a location ID to remove a blacklisted DNS entry.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, Device, or DNS does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param dns


*/
func (a *CustomerApiService) CustomerPrototypeDeleteFromDeviceSecurityPolicyWebsitesBlacklist(ctx context.Context, id string, locationId string, mac string, dns string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/securityPolicy/websites/blacklist/{dns}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dns"+"}", fmt.Sprintf("%v", dns), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Update a Device&#39;s Security Policy for a location ID to remove a whitelisted DNS entry.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, Device, or DNS does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param dns


*/
func (a *CustomerApiService) CustomerPrototypeDeleteFromDeviceSecurityPolicyWebsitesWhitelist(ctx context.Context, id string, locationId string, mac string, dns string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/securityPolicy/websites/whitelist/{dns}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dns"+"}", fmt.Sprintf("%v", dns), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Update a Location&#39;s Default Device Group Security Policy for a location ID to remove a blacklisted DNS entry.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, or DNS does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param dns


*/
func (a *CustomerApiService) CustomerPrototypeDeleteFromGroupOfUnassignedDevicesSecurityPolicyWebsitesBlacklist(ctx context.Context, id string, locationId string, dns string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/groupOfUnassignedDevices/securityPolicy/websites/blacklist/{dns}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dns"+"}", fmt.Sprintf("%v", dns), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Update a Location&#39;s Default Device Group Security Policy for a location ID to remove a whitelisted DNS entry.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, or DNS does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param dns


*/
func (a *CustomerApiService) CustomerPrototypeDeleteFromGroupOfUnassignedDevicesSecurityPolicyWebsitesWhitelist(ctx context.Context, id string, locationId string, dns string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/groupOfUnassignedDevices/securityPolicy/websites/whitelist/{dns}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dns"+"}", fmt.Sprintf("%v", dns), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Update a Location&#39;s Security Policy for a location ID to remove a blacklisted DNS entry.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, or DNS does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param dns


*/
func (a *CustomerApiService) CustomerPrototypeDeleteFromLocationSecurityPolicyWebsitesBlacklist(ctx context.Context, id string, locationId string, dns string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy/websites/blacklist/{dns}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dns"+"}", fmt.Sprintf("%v", dns), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Update a Locations&#39;s Security Policy for a location ID to remove a whitelisted DNS entry.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, or DNS does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param dns


*/
func (a *CustomerApiService) CustomerPrototypeDeleteFromLocationSecurityPolicyWebsitesWhitelist(ctx context.Context, id string, locationId string, dns string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy/websites/whitelist/{dns}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dns"+"}", fmt.Sprintf("%v", dns), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Update a Person&#39;s Security Policy for a location ID to remove a blacklisted DNS entry.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, Person id, or DNS does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId
 * @param dns


*/
func (a *CustomerApiService) CustomerPrototypeDeleteFromPersonSecurityPolicyWebsitesBlacklist(ctx context.Context, id string, locationId string, personId string, dns string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/securityPolicy/websites/blacklist/{dns}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dns"+"}", fmt.Sprintf("%v", dns), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Update a Person&#39;s Security Policy for a location ID to remove a whitelisted DNS entry.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, Person id, or DNS does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId
 * @param dns


*/
func (a *CustomerApiService) CustomerPrototypeDeleteFromPersonSecurityPolicyWebsitesWhitelist(ctx context.Context, id string, locationId string, personId string, dns string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/securityPolicy/websites/whitelist/{dns}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dns"+"}", fmt.Sprintf("%v", dns), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete a Front Haul for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id/NetworkId does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId


*/
func (a *CustomerApiService) CustomerPrototypeDeleteFrontHaul(ctx context.Context, id string, locationId string, networkId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/fronthauls/{networkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete the Gdpr Captive Portals data for a guest.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, GDPR Captive Portals data deleted.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or secondary networks does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param email

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeDeleteGdprCaptivePortalsData(ctx context.Context, id string, locationId string, networkId string, email string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortal/{networkId}/gdprForget/guests"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("email", parameterToString(email, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Delete GroupOfUnassignedDevices autoExpire freeze for a Location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId


*/
func (a *CustomerApiService) CustomerPrototypeDeleteGroupOfUnassignedDevicesFreezeAutoExpire(ctx context.Context, id string, locationId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/groupOfUnassignedDevices/freeze/autoExpire"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete GroupOfUnassignedDevices forever freeze for a Location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId


*/
func (a *CustomerApiService) CustomerPrototypeDeleteGroupOfUnassignedDevicesFreezeForever(ctx context.Context, id string, locationId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/groupOfUnassignedDevices/freeze/forever"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete GroupOfUnassignedDevices suspend for a Location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId


*/
func (a *CustomerApiService) CustomerPrototypeDeleteGroupOfUnassignedDevicesFreezeSuspend(ctx context.Context, id string, locationId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/groupOfUnassignedDevices/freeze/suspend"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete GroupOfUnassignedDevices uuid freeze for a Location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param freezeTemplateId Valid templates are uuids


*/
func (a *CustomerApiService) CustomerPrototypeDeleteGroupOfUnassignedDevicesFreezeTemplateId(ctx context.Context, id string, locationId string, freezeTemplateId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/groupOfUnassignedDevices/freeze/{freezeTemplateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"freezeTemplateId"+"}", fmt.Sprintf("%v", freezeTemplateId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete All GroupOfUnassignedDevices freeze except autoExpire for a Location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId


*/
func (a *CustomerApiService) CustomerPrototypeDeleteGroupOfUnassignedDevicesFreezes(ctx context.Context, id string, locationId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/groupOfUnassignedDevices/freezes"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete kvConfigs with selected module and key on a particular Node for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, your new info looks good.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: nodeId must be defined.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;425&lt;/strong&gt;: nodeId must belong to the location.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param nodeId
 * @param module
 * @param key

@return KvConfig
*/
func (a *CustomerApiService) CustomerPrototypeDeleteKvConfigs(ctx context.Context, id string, locationId string, nodeId string, module string, key string) (KvConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue KvConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodes/{nodeId}/kvConfigs/{module}/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", fmt.Sprintf("%v", nodeId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"module"+"}", fmt.Sprintf("%v", module), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", fmt.Sprintf("%v", key), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v KvConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService link the outside account, such as Samsung user.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, the outside account inserted into the customer info/object.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param provider
 * @param userId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeDeleteLinkedAccount(ctx context.Context, id string, provider string, userId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/linkedAccounts/{provider}/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"provider"+"}", fmt.Sprintf("%v", provider), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", fmt.Sprintf("%v", userId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Archive a location.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, location archived.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;409&lt;/strong&gt;: Location already archived.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId


*/
func (a *CustomerApiService) CustomerPrototypeDeleteLocation(ctx context.Context, id string, locationId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete a Location&#39;s Security Events history for a location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, Device or DNS does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param categories
 * @param optional nil or *CustomerApiCustomerPrototypeDeleteLocationEventsHistoryOpts - Optional Parameters:
     * @param "Reason" (optional.String) - 


*/

type CustomerApiCustomerPrototypeDeleteLocationEventsHistoryOpts struct { 
	Reason optional.String
}

func (a *CustomerApiService) CustomerPrototypeDeleteLocationEventsHistory(ctx context.Context, id string, locationId string, categories string, localVarOptionals *CustomerApiCustomerPrototypeDeleteLocationEventsHistoryOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy/events"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("categories", parameterToString(categories, ""))
	if localVarOptionals != nil && localVarOptionals.Reason.IsSet() {
		localVarFormParams.Add("reason", parameterToString(localVarOptionals.Reason.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete the location freeze/autoExpire for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypeDeleteLocationFreezeAutoExpire(ctx context.Context, id string, locationId string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/freeze/autoExpire"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Delete manager access for location and destroy access tokens for that manager\&quot;.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location or Manager does not exist.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param managerId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeDeleteManagerAccess(ctx context.Context, id string, locationId string, managerId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/managers/{managerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managerId"+"}", fmt.Sprintf("%v", managerId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Delete a node model based on its id.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: The node was successfully deleted.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization Required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Node or customer not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Node deletion could not be completed.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param nodeId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeDeleteNodeLocked(ctx context.Context, id string, nodeId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/nodes/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Delete persistent data/configs from node in runtime.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location or Node, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Required fields are not valid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId location id
 * @param nodeId node id
 * @param optional nil or *CustomerApiCustomerPrototypeDeleteNodePersistentConfigsOpts - Optional Parameters:
     * @param "DeleteAllPersistentConfigs" (optional.Bool) -  whether all persistent config data or just GW-offline data will be deleted


*/

type CustomerApiCustomerPrototypeDeleteNodePersistentConfigsOpts struct { 
	DeleteAllPersistentConfigs optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeDeleteNodePersistentConfigs(ctx context.Context, id string, locationId string, nodeId string, localVarOptionals *CustomerApiCustomerPrototypeDeleteNodePersistentConfigsOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodes/{nodeId}/persistentConfigs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.DeleteAllPersistentConfigs.IsSet() {
		localVarFormParams.Add("deleteAllPersistentConfigs", parameterToString(localVarOptionals.DeleteAllPersistentConfigs.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete a Person for a location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or Person id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId
 * @param optional nil or *CustomerApiCustomerPrototypeDeletePersonOpts - Optional Parameters:
     * @param "BlockUnassignedDevices" (optional.Bool) -  block any devices previously assigned to Person (false by default)


*/

type CustomerApiCustomerPrototypeDeletePersonOpts struct { 
	BlockUnassignedDevices optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeDeletePerson(ctx context.Context, id string, locationId string, personId string, localVarOptionals *CustomerApiCustomerPrototypeDeletePersonOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.BlockUnassignedDevices.IsSet() {
		localVarFormParams.Add("blockUnassignedDevices", parameterToString(localVarOptionals.BlockUnassignedDevices.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete a person to be frozen for a Location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId


*/
func (a *CustomerApiService) CustomerPrototypeDeletePersonAllFreeze(ctx context.Context, id string, locationId string, personId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/freezes"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete a person to be frozen for a Location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId
 * @param freezeTemplateId Valid templates are &#39;untilMidinight&#39;, &#39;schoolNights&#39;, etc.


*/
func (a *CustomerApiService) CustomerPrototypeDeletePersonFreeze(ctx context.Context, id string, locationId string, personId string, freezeTemplateId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/freeze/{freezeTemplateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"freezeTemplateId"+"}", fmt.Sprintf("%v", freezeTemplateId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete all devices from a person to be frozen for a Location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId


*/
func (a *CustomerApiService) CustomerPrototypeDeletePersonFreezeAutoExpire(ctx context.Context, id string, locationId string, personId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/freeze/autoExpire"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete a person forever freeze for a Location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId


*/
func (a *CustomerApiService) CustomerPrototypeDeletePersonFreezeForever(ctx context.Context, id string, locationId string, personId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/freeze/forever"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete person suspend for a Location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId


*/
func (a *CustomerApiService) CustomerPrototypeDeletePersonFreezeSuspend(ctx context.Context, id string, locationId string, personId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/freeze/suspend"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete a Person&#39;s Profile for a location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or Person id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId


*/
func (a *CustomerApiService) CustomerPrototypeDeletePersonProfile(ctx context.Context, id string, locationId string, personId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/profile"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete an existing Port Forwarding entry for an existing DHCP IP reservation tied to a MAC address at a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, returns list of remaining port forwards.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: NetworkConfiguration, DhcpReservation or PortForward does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: mac does not exist, or is invalid, or externalPort is empty.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param externalPort

@return []PortForward
*/
func (a *CustomerApiService) CustomerPrototypeDeletePortForward(ctx context.Context, id string, locationId string, mac string, externalPort string) ([]PortForward, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []PortForward
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkConfiguration/dhcpReservations/{mac}/portForward/{externalPort}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalPort"+"}", fmt.Sprintf("%v", externalPort), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []PortForward
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Delete a Remote Connection Allow IpAddress/ttl for the given device and Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or Device mac does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param ipaddr ipaddress

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeDeleteRemoteConnectionsAllow(ctx context.Context, id string, locationId string, mac string, ipaddr string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/securityPolicy/remoteConnections/allow/{ipaddr}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ipaddr"+"}", fmt.Sprintf("%v", ipaddr), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Delete a Remote Connection Allow All for the given device and Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or Device mac does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeDeleteRemoteConnectionsAllowAll(ctx context.Context, id string, locationId string, mac string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/securityPolicy/remoteConnections/allowAll"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Delete a Room for a location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or Room id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param roomId


*/
func (a *CustomerApiService) CustomerPrototypeDeleteRoom(ctx context.Context, id string, locationId string, roomId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/rooms/{roomId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roomId"+"}", fmt.Sprintf("%v", roomId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Delete a WiFi Access Zone
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, remaining access zones returned&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Customer id, location id, or WifiNetwork does not exist&lt;/div&gt; &lt;div&gt;&lt;strong&gt;405&lt;/strong&gt;: Cannot delete a read-only access zone&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param accessZoneId access zone id

@return []WifiAccessZone
*/
func (a *CustomerApiService) CustomerPrototypeDeleteWifiAccessZone(ctx context.Context, id string, locationId string, accessZoneId float64) ([]WifiAccessZone, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []WifiAccessZone
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork/accessZones/{accessZoneId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessZoneId"+"}", fmt.Sprintf("%v", accessZoneId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []WifiAccessZone
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Delete a WiFi Password
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, all passwords returned&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Customer id, location id, or WifiNetwork does not exist&lt;/div&gt; &lt;div&gt;&lt;strong&gt;405&lt;/strong&gt;: Cannot delete a read-only key&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param accessZone home | guests | internetAccessOnly
 * @param keyId Unique password id: 0-9

@return []WifiNetworkKey
*/
func (a *CustomerApiService) CustomerPrototypeDeleteWifiKey(ctx context.Context, id string, locationId string, accessZone string, keyId float64) ([]WifiNetworkKey, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []WifiNetworkKey
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork/accessZones/{accessZone}/keys/{keyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessZone"+"}", fmt.Sprintf("%v", accessZone), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyId"+"}", fmt.Sprintf("%v", keyId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []WifiNetworkKey
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Deletes _migration of this model.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id


*/
func (a *CustomerApiService) CustomerPrototypeDestroyMigration(ctx context.Context, id string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/_migration"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Disable customer from logging in until their account is reactivated.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Customer has been disabled.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Customer does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param optional nil or *CustomerApiCustomerPrototypeDisableLoginOpts - Optional Parameters:
     * @param "TriggerReset" (optional.Bool) - 


*/

type CustomerApiCustomerPrototypeDisableLoginOpts struct { 
	TriggerReset optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeDisableLogin(ctx context.Context, id string, localVarOptionals *CustomerApiCustomerPrototypeDisableLoginOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/disable"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.TriggerReset.IsSet() {
		localVarFormParams.Add("triggerReset", parameterToString(localVarOptionals.TriggerReset.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Re-enables deviceType sniffing for a particular device.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, your new info looks good.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: No device found with provided mac address&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac


*/
func (a *CustomerApiService) CustomerPrototypeEnableDeviceTypeSniffing(ctx context.Context, id string, locationId string, mac string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/resniff"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Enable customer log in, after it has been disabled.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Customer has been enabled.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Customer does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id


*/
func (a *CustomerApiService) CustomerPrototypeEnableLogin(ctx context.Context, id string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/enable"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Reset specified location settings to default, while keeping claimed nodes intact. Some of the flags can cause a node to be reeboted.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, a job well done.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required &lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id not found or nodeId missing from URL &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeFactoryResetOpts - Optional Parameters:
     * @param "Persons" (optional.Bool) -  Whether or not to delete person information
     * @param "OnboardingCheckpoints" (optional.Bool) -  Whether or not to reset onboarding checkpoints
     * @param "Devices" (optional.Bool) -  Whether or not to delete devices related information
     * @param "NetworkConfiguration" (optional.Bool) -  Whether or not to reset network configuration (triggers node reboot)
     * @param "WifiNetwork" (optional.Bool) -  Whether or not to reset wifi network (triggers node reboot)
     * @param "DeviceFreeze" (optional.Bool) -  Whether or not to reset device freeze templates
     * @param "DeviceNicknames" (optional.Bool) -  Whether or not to reset device nicknames
     * @param "Managers" (optional.Bool) -  Whether or not to reset managers of the location
     * @param "WanConfiguration" (optional.Bool) -  Whether or not to reset wanConfiguration


*/

type CustomerApiCustomerPrototypeFactoryResetOpts struct { 
	Persons optional.Bool
	OnboardingCheckpoints optional.Bool
	Devices optional.Bool
	NetworkConfiguration optional.Bool
	WifiNetwork optional.Bool
	DeviceFreeze optional.Bool
	DeviceNicknames optional.Bool
	Managers optional.Bool
	WanConfiguration optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeFactoryReset(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeFactoryResetOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/factoryReset"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Persons.IsSet() {
		localVarFormParams.Add("persons", parameterToString(localVarOptionals.Persons.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnboardingCheckpoints.IsSet() {
		localVarFormParams.Add("onboardingCheckpoints", parameterToString(localVarOptionals.OnboardingCheckpoints.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Devices.IsSet() {
		localVarFormParams.Add("devices", parameterToString(localVarOptionals.Devices.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NetworkConfiguration.IsSet() {
		localVarFormParams.Add("networkConfiguration", parameterToString(localVarOptionals.NetworkConfiguration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WifiNetwork.IsSet() {
		localVarFormParams.Add("wifiNetwork", parameterToString(localVarOptionals.WifiNetwork.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceFreeze.IsSet() {
		localVarFormParams.Add("deviceFreeze", parameterToString(localVarOptionals.DeviceFreeze.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceNicknames.IsSet() {
		localVarFormParams.Add("deviceNicknames", parameterToString(localVarOptionals.DeviceNicknames.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Managers.IsSet() {
		localVarFormParams.Add("managers", parameterToString(localVarOptionals.Managers.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WanConfiguration.IsSet() {
		localVarFormParams.Add("wanConfiguration", parameterToString(localVarOptionals.WanConfiguration.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Get a Location&#39;s combined State and Config by LocationId.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, full object returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: LocationId not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeFindLocationByIdOpts - Optional Parameters:
     * @param "Include" (optional.String) -  CSV value of objects to add to the response: summary (is the only option for now)

@return Location
*/

type CustomerApiCustomerPrototypeFindLocationByIdOpts struct { 
	Include optional.String
}

func (a *CustomerApiService) CustomerPrototypeFindLocationById(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeFindLocationByIdOpts) (Location, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Location
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Include.IsSet() {
		localVarQueryParams.Add("include", parameterToString(localVarOptionals.Include.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Location
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get an access token for a location where you are assigned as a manager
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid email, name, access type or manager is already assigned to this location &lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetAccessTokenForManagedLocation(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/entitledAccess/{locationId}/accessTokens"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Retrieve active alerts for this location.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, an array of Nodes and an array of Devices returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetAlerts(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/alerts"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get information about app engagement timer details for a location
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetAppEngagementTimer(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/appEngagementTimer"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the AppId info for the given location.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, appId info returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or url does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return NetworkConfig
*/
func (a *CustomerApiService) CustomerPrototypeGetAppIdInfoCaptivePortalNetwork(ctx context.Context, id string, locationId string) (NetworkConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NetworkConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/ownerAppIds"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NetworkConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get status for app prioritization.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetAppPrioritizationLocationConfig(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/qos/appPrioritization"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get monitoring metrics for app prioritization.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param startTime format yyyy-mm-ddThh:MM:ss.nnnZ, 24 hours time specified in UTC
 * @param endTime format yyyy-mm-ddThh:MM:ss.nnnZ, 24 hours time specified in UTC
 * @param optional nil or *CustomerApiCustomerPrototypeGetAppPrioritizationMonitoringOpts - Optional Parameters:
     * @param "Granularity" (optional.String) -  any of the values - total/15 minutes/1 hour/1 day
     * @param "Macs" (optional.String) -  array of macs[]
     * @param "TrafficClasses" (optional.String) -  array of trafficClasses[]
     * @param "SortOrder" (optional.String) -  TxBytes\&quot;|| \&quot;RxBytes
     * @param "Limit" (optional.Float64) -  Maximum number of devices to return.

@return interface{}
*/

type CustomerApiCustomerPrototypeGetAppPrioritizationMonitoringOpts struct { 
	Granularity optional.String
	Macs optional.String
	TrafficClasses optional.String
	SortOrder optional.String
	Limit optional.Float64
}

func (a *CustomerApiService) CustomerPrototypeGetAppPrioritizationMonitoring(ctx context.Context, id string, locationId string, startTime time.Time, endTime time.Time, localVarOptionals *CustomerApiCustomerPrototypeGetAppPrioritizationMonitoringOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/qos/appPrioritization/monitoring"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Granularity.IsSet() {
		localVarFormParams.Add("granularity", parameterToString(localVarOptionals.Granularity.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Macs.IsSet() {
		localVarFormParams.Add("macs", parameterToString(localVarOptionals.Macs.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TrafficClasses.IsSet() {
		localVarFormParams.Add("trafficClasses", parameterToString(localVarOptionals.TrafficClasses.Value(), ""))
	}
	localVarFormParams.Add("startTime", parameterToString(startTime, ""))
	localVarFormParams.Add("endTime", parameterToString(endTime, ""))
	if localVarOptionals != nil && localVarOptionals.SortOrder.IsSet() {
		localVarFormParams.Add("sortOrder", parameterToString(localVarOptionals.SortOrder.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarFormParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get AppPrioritization template configs
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetAppPrioritizationTemplateConfig(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/qos/appPrioritization/templateConfig"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get App QoE metrics by traffic classes / devices / apps.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param timePeriod Any of \&quot;last24Hours\&quot;,\&quot;last7Days\&quot;,\&quot;last30Days\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetAppQoeStatsByTrafficClassOpts - Optional Parameters:
     * @param "IncludeApps" (optional.Bool) -  Default false, to include app stats in the response
     * @param "TrafficClassNames" (optional.String) -  array of traffic classes - default list - av_streaming, gaming, video_conferencing

@return interface{}
*/

type CustomerApiCustomerPrototypeGetAppQoeStatsByTrafficClassOpts struct { 
	IncludeApps optional.Bool
	TrafficClassNames optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetAppQoeStatsByTrafficClass(ctx context.Context, id string, locationId string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetAppQoeStatsByTrafficClassOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/appqoe/AppQoeStatsByTrafficClass"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.IncludeApps.IsSet() {
		localVarFormParams.Add("includeApps", parameterToString(localVarOptionals.IncludeApps.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TrafficClassNames.IsSet() {
		localVarFormParams.Add("trafficClassNames", parameterToString(localVarOptionals.TrafficClassNames.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get App QoE metrics for traffic classes.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param granularity any of the values - total/1 minute/15 minutes/1 hour/1 day
 * @param startTime format yyyy-mm-ddThh:MM:ss.nnnZ, 24 hours time specified in UTC
 * @param endTime format yyyy-mm-ddThh:MM:ss.nnnZ, 24 hours time specified in UTC
 * @param optional nil or *CustomerApiCustomerPrototypeGetAppQoeTrafficClassMetricsGetCustomersidLocationslocationIdAppqoeTrafficClassStatsOpts - Optional Parameters:
     * @param "Macs" (optional.String) -  array of macs[]
     * @param "TrafficClasses" (optional.String) -  array of trafficClasses
     * @param "Limit" (optional.Float64) -  Maximum number of devices to return.

@return interface{}
*/

type CustomerApiCustomerPrototypeGetAppQoeTrafficClassMetricsGetCustomersidLocationslocationIdAppqoeTrafficClassStatsOpts struct { 
	Macs optional.String
	TrafficClasses optional.String
	Limit optional.Float64
}

func (a *CustomerApiService) CustomerPrototypeGetAppQoeTrafficClassMetricsGetCustomersidLocationslocationIdAppqoeTrafficClassStats(ctx context.Context, id string, locationId string, granularity string, startTime time.Time, endTime time.Time, localVarOptionals *CustomerApiCustomerPrototypeGetAppQoeTrafficClassMetricsGetCustomersidLocationslocationIdAppqoeTrafficClassStatsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/appqoe/traffic_class_stats"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("granularity", parameterToString(granularity, ""))
	if localVarOptionals != nil && localVarOptionals.Macs.IsSet() {
		localVarQueryParams.Add("macs", parameterToString(localVarOptionals.Macs.Value(), ""))
	}
	localVarQueryParams.Add("startTime", parameterToString(startTime, ""))
	localVarQueryParams.Add("endTime", parameterToString(endTime, ""))
	if localVarOptionals != nil && localVarOptionals.TrafficClasses.IsSet() {
		localVarQueryParams.Add("trafficClasses", parameterToString(localVarOptionals.TrafficClasses.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get App QoE metrics for traffic classes.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param granularity any of the values - total/1 minute/15 minutes/1 hour/1 day
 * @param startTime format yyyy-mm-ddThh:MM:ss.nnnZ, 24 hours time specified in UTC
 * @param endTime format yyyy-mm-ddThh:MM:ss.nnnZ, 24 hours time specified in UTC
 * @param optional nil or *CustomerApiCustomerPrototypeGetAppQoeTrafficClassMetricsPostCustomersidLocationslocationIdAppqoeTrafficClassStatsOpts - Optional Parameters:
     * @param "Macs" (optional.String) -  array of macs
     * @param "TrafficClasses" (optional.String) -  array of trafficClasses
     * @param "Limit" (optional.Float64) -  Maximum number of devices to return.

@return interface{}
*/

type CustomerApiCustomerPrototypeGetAppQoeTrafficClassMetricsPostCustomersidLocationslocationIdAppqoeTrafficClassStatsOpts struct { 
	Macs optional.String
	TrafficClasses optional.String
	Limit optional.Float64
}

func (a *CustomerApiService) CustomerPrototypeGetAppQoeTrafficClassMetricsPostCustomersidLocationslocationIdAppqoeTrafficClassStats(ctx context.Context, id string, locationId string, granularity string, startTime time.Time, endTime time.Time, localVarOptionals *CustomerApiCustomerPrototypeGetAppQoeTrafficClassMetricsPostCustomersidLocationslocationIdAppqoeTrafficClassStatsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/appqoe/traffic_class_stats"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("granularity", parameterToString(granularity, ""))
	if localVarOptionals != nil && localVarOptionals.Macs.IsSet() {
		localVarFormParams.Add("macs", parameterToString(localVarOptionals.Macs.Value(), ""))
	}
	localVarFormParams.Add("startTime", parameterToString(startTime, ""))
	localVarFormParams.Add("endTime", parameterToString(endTime, ""))
	if localVarOptionals != nil && localVarOptionals.TrafficClasses.IsSet() {
		localVarFormParams.Add("trafficClasses", parameterToString(localVarOptionals.TrafficClasses.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarFormParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get IP flows config
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or device does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetAppTimeIpFlows(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/appTime/ipFlows"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get audit trail for a customer.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Ok.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Customer id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypeGetAuditTrailForCustomer(ctx context.Context, id string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/auditTrail"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get audit trail for location.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Ok.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypeGetAuditTrailForLocation(ctx context.Context, id string, locationId string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/auditTrail"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the number of authorized leaf pods for a Location ID.
&lt;div&gt;Number of leaf pods that are authorized to be claimed and be a part of the Plume network&lt;/div&gt; &lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, numPodsAuthorized returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return Authorizations
*/
func (a *CustomerApiService) CustomerPrototypeGetAuthorizations(ctx context.Context, id string, locationId string) (Authorizations, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Authorizations
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/authorizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Authorizations
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetBackhaul(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/backhaul"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the Captive Portal campaign for a given Location ID/NetworkId.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, campaign returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or CaptivePortal Network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId

@return NetworkConfig
*/
func (a *CustomerApiService) CustomerPrototypeGetCampaignCaptivePortalNetwork(ctx context.Context, id string, locationId string, networkId string) (NetworkConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NetworkConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/{networkId}/campaign"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NetworkConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get CaptivePortal authorized clients
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id/NetworkId does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetCaptivePortalAuthorizedClients(ctx context.Context, id string, locationId string, networkId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/{networkId}/authorizedClients"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the Captive Portal Network guest info download availability for the given network.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, CaptivePortal Networks guest info download availability returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or secondary networks does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param optional nil or *CustomerApiCustomerPrototypeGetCaptivePortalGuestEmailCollectionInfoOpts - Optional Parameters:
     * @param "Duration" (optional.Float64) -  number of days for how far back in history for data
     * @param "Limit" (optional.Float64) -  limit how many emails we wish to return

@return InlineResponse2008
*/

type CustomerApiCustomerPrototypeGetCaptivePortalGuestEmailCollectionInfoOpts struct { 
	Duration optional.Float64
	Limit optional.Float64
}

func (a *CustomerApiService) CustomerPrototypeGetCaptivePortalGuestEmailCollectionInfo(ctx context.Context, id string, locationId string, networkId string, localVarOptionals *CustomerApiCustomerPrototypeGetCaptivePortalGuestEmailCollectionInfoOpts) (InlineResponse2008, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2008
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/{networkId}/guestEmailCollectionInfo"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Duration.IsSet() {
		localVarQueryParams.Add("duration", parameterToString(localVarOptionals.Duration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2008
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the list of Guests which were logged into the given captivePortal network during the current day.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, CaptivePortal Networks returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or secondary networks does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param optional nil or *CustomerApiCustomerPrototypeGetCaptivePortalGuestsOpts - Optional Parameters:
     * @param "OrderBy" (optional.String) -  Order by: &lt;connectionTime&gt;
     * @param "Limit" (optional.Float64) - 

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetCaptivePortalGuestsOpts struct { 
	OrderBy optional.String
	Limit optional.Float64
}

func (a *CustomerApiService) CustomerPrototypeGetCaptivePortalGuests(ctx context.Context, id string, locationId string, networkId string, localVarOptionals *CustomerApiCustomerPrototypeGetCaptivePortalGuestsOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/{networkId}/guests"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("orderBy", parameterToString(localVarOptionals.OrderBy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the Captive Portal configs for a given Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, CaptivePortal Networks returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or secondary networks does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return NetworkConfig
*/
func (a *CustomerApiService) CustomerPrototypeGetCaptivePortalNetworks(ctx context.Context, id string, locationId string) (NetworkConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NetworkConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NetworkConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Download Captive Portal Guest details for a given Location ID/NetworkId.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or CaptivePortal Network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId

@return *os.File
*/
func (a *CustomerApiService) CustomerPrototypeGetCaptivePortalSendDetails(ctx context.Context, id string, locationId string, networkId string) (*os.File, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/{networkId}/downloadGuestDetails"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v *os.File
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Download Captive Portal Guest details for a given Location ID/NetworkId without accessing Amazon S3.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or CaptivePortal Network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param optional nil or *CustomerApiCustomerPrototypeGetCaptivePortalSendDetailsDirectOpts - Optional Parameters:
     * @param "Duration" (optional.Float64) - 
     * @param "Limit" (optional.Float64) - 

@return *os.File
*/

type CustomerApiCustomerPrototypeGetCaptivePortalSendDetailsDirectOpts struct { 
	Duration optional.Float64
	Limit optional.Float64
}

func (a *CustomerApiService) CustomerPrototypeGetCaptivePortalSendDetailsDirect(ctx context.Context, id string, locationId string, networkId string, localVarOptionals *CustomerApiCustomerPrototypeGetCaptivePortalSendDetailsDirectOpts) (*os.File, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/{networkId}/downloadGuestDetailsDirect"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Duration.IsSet() {
		localVarQueryParams.Add("duration", parameterToString(localVarOptionals.Duration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v *os.File
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Returns list of linked command accounts for the location
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, return the  list of linked command accounts.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return []interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetCommands(ctx context.Context, id string, locationId string) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/command"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the companyInfo for the given url (domain).
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, company info returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or url does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeGetCompanyInfoCaptivePortalNetworkOpts - Optional Parameters:
     * @param "Url" (optional.String) - 
     * @param "UrlType" (optional.String) -  only &#39;domain&#39; currently supported

@return NetworkConfig
*/

type CustomerApiCustomerPrototypeGetCompanyInfoCaptivePortalNetworkOpts struct { 
	Url optional.String
	UrlType optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetCompanyInfoCaptivePortalNetwork(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeGetCompanyInfoCaptivePortalNetworkOpts) (NetworkConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NetworkConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/companyInfo/search"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Url.IsSet() {
		localVarFormParams.Add("url", parameterToString(localVarOptionals.Url.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlType.IsSet() {
		localVarFormParams.Add("urlType", parameterToString(localVarOptionals.UrlType.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NetworkConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get control mode for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetControlMode(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/controlMode"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Returns a single Node for a Customer ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, node returned with locationId field.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist. Or, nodeId not claimed to this account.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param nodeId id of node

@return NodeResponse
*/
func (a *CustomerApiService) CustomerPrototypeGetCustomerNodeById(ctx context.Context, id string, nodeId string) (NodeResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NodeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/nodes/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NodeResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Returns partner customer support configuration.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypeGetCustomerSupportConfigurations(ctx context.Context, id string, locationId string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/customerSupportConfigurations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Daily/Weekly/Monthly device usage summary report based on location
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeGetDashboardOpts - Optional Parameters:
     * @param "Macs" (optional.String) -  mac list of all devices in the location

@return XAny
*/

type CustomerApiCustomerPrototypeGetDashboardOpts struct { 
	Macs optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetDashboard(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeGetDashboardOpts) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/flex/dashboard"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Macs.IsSet() {
		localVarQueryParams.Add("macs", parameterToString(localVarOptionals.Macs.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the AppTime Apps Data Usage Stats for captivePortal network.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, AppTime Stats returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or secondary networks does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param timePeriod Any of \&quot;weekly\&quot;,\&quot;dailyToday\&quot;,\&quot;dailyYesterday\&quot;,\&quot;daily2DaysAgo\&quot;,\&quot;daily3DaysAgo\&quot;,\&quot;daily4DaysAgo\&quot;,\&quot;daily5DaysAgo\&quot;,\&quot;daily6DaysAgo\&quot;,\&quot;last30Days\&quot;,\&quot;last12Months\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetDefaultNetworkAppTimeAppsDataUsageOpts - Optional Parameters:
     * @param "Limit" (optional.Float64) -  Maximum number of apps to return. Defaults to 20
     * @param "Grouping" (optional.String) -  typing of Grouping for the purposes of applying the limit. Can be: &#39;perTimeSlot&#39; ONLY

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetDefaultNetworkAppTimeAppsDataUsageOpts struct { 
	Limit optional.Float64
	Grouping optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetDefaultNetworkAppTimeAppsDataUsage(ctx context.Context, id string, locationId string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetDefaultNetworkAppTimeAppsDataUsageOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork/appTime/apps/dataUsage"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the AppTime Apps Online Time Stats for default network.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, AppTime Stats returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or secondary networks does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param timePeriod Any of \&quot;weekly\&quot;,\&quot;dailyToday\&quot;,\&quot;dailyYesterday\&quot;,\&quot;daily2DaysAgo\&quot;,\&quot;daily3DaysAgo\&quot;,\&quot;daily4DaysAgo\&quot;,\&quot;daily5DaysAgo\&quot;,\&quot;daily6DaysAgo\&quot;,\&quot;last30Days\&quot;,\&quot;last12Months\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetDefaultNetworkAppTimeAppsOnlineTimeOpts - Optional Parameters:
     * @param "Limit" (optional.Float64) -  Maximum number of apps to return. Defaults to 20
     * @param "Grouping" (optional.String) -  typing of Grouping for the purposes of applying the limit. Can be: &#39;perTimeSlot&#39; ONLY

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetDefaultNetworkAppTimeAppsOnlineTimeOpts struct { 
	Limit optional.Float64
	Grouping optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetDefaultNetworkAppTimeAppsOnlineTime(ctx context.Context, id string, locationId string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetDefaultNetworkAppTimeAppsOnlineTimeOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork/appTime/apps/onlineTime"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the AppTime Categories Data Usage Stats for captivePortal network.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, AppTime Stats returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or secondary networks does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param timePeriod Any of \&quot;weekly\&quot;,\&quot;dailyToday\&quot;,\&quot;dailyYesterday\&quot;,\&quot;daily2DaysAgo\&quot;,\&quot;daily3DaysAgo\&quot;,\&quot;daily4DaysAgo\&quot;,\&quot;daily5DaysAgo\&quot;,\&quot;daily6DaysAgo\&quot;,\&quot;last30Days\&quot;,\&quot;last12Months\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetDefaultNetworkAppTimeCategoriesDataUsageOpts - Optional Parameters:
     * @param "Limit" (optional.Float64) -  Maximum number of categories to return. Defaults to 20
     * @param "Grouping" (optional.String) -  typing of Grouping for the purposes of applying the limit. Can be: &#39;overall&#39;|&#39;perTimeSlot&#39;

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetDefaultNetworkAppTimeCategoriesDataUsageOpts struct { 
	Limit optional.Float64
	Grouping optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetDefaultNetworkAppTimeCategoriesDataUsage(ctx context.Context, id string, locationId string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetDefaultNetworkAppTimeCategoriesDataUsageOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork/appTime/categories/dataUsage"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the AppTime Categories Online Time Stats for captivePortal network.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, AppTime Stats returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or secondary networks does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param timePeriod Any of \&quot;weekly\&quot;,\&quot;dailyToday\&quot;,\&quot;dailyYesterday\&quot;,\&quot;daily2DaysAgo\&quot;,\&quot;daily3DaysAgo\&quot;,\&quot;daily4DaysAgo\&quot;,\&quot;daily5DaysAgo\&quot;,\&quot;daily6DaysAgo\&quot;,\&quot;last30Days\&quot;,\&quot;last12Months\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetDefaultNetworkAppTimeCategoriesOnlineTimeOpts - Optional Parameters:
     * @param "Limit" (optional.Float64) -  Maximum number of categories to return. Defaults to 20
     * @param "Grouping" (optional.String) -  typing of Grouping for the purposes of applying the limit. Can be: &#39;overall&#39;|&#39;perTimeSlot&#39;

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetDefaultNetworkAppTimeCategoriesOnlineTimeOpts struct { 
	Limit optional.Float64
	Grouping optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetDefaultNetworkAppTimeCategoriesOnlineTime(ctx context.Context, id string, locationId string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetDefaultNetworkAppTimeCategoriesOnlineTimeOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork/appTime/categories/onlineTime"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Device alarm history graph array for a particular MAC address.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac mac id of device
 * @param optional nil or *CustomerApiCustomerPrototypeGetDeviceAlarmsOpts - Optional Parameters:
     * @param "CoverageAlarmThreshold" (optional.String) -  a coverage alarm will be returned (value&#x3D;1) when rssi_alarm_penalty_count &gt;&#x3D; this value
     * @param "Granularity" (optional.String) -  days/hours/minutes
     * @param "Limit" (optional.Float64) -  X # of days/hours/minutes
     * @param "Start" (optional.Float64) -  number of milliseconds elapsed since 1 January 1970 00:00:00 UTC. Defaults to now - (limit * granularity)

@return interface{}
*/

type CustomerApiCustomerPrototypeGetDeviceAlarmsOpts struct { 
	CoverageAlarmThreshold optional.String
	Granularity optional.String
	Limit optional.Float64
	Start optional.Float64
}

func (a *CustomerApiService) CustomerPrototypeGetDeviceAlarms(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypeGetDeviceAlarmsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/flex/devices/{mac}/alarms"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.CoverageAlarmThreshold.IsSet() {
		localVarQueryParams.Add("coverageAlarmThreshold", parameterToString(localVarOptionals.CoverageAlarmThreshold.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Granularity.IsSet() {
		localVarQueryParams.Add("granularity", parameterToString(localVarOptionals.Granularity.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Start.IsSet() {
		localVarQueryParams.Add("start", parameterToString(localVarOptionals.Start.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the AppTime Apps Data Usage Stats for a Device.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, AppTime Stats returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or device does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param timePeriod Any of \&quot;weekly\&quot;,\&quot;dailyToday\&quot;,\&quot;dailyYesterday\&quot;,\&quot;daily2DaysAgo\&quot;,\&quot;daily3DaysAgo\&quot;,\&quot;daily4DaysAgo\&quot;,\&quot;daily5DaysAgo\&quot;,\&quot;daily6DaysAgo\&quot;,\&quot;last30Days\&quot;,\&quot;last12Months\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetDeviceAppTimeAppsDataUsageOpts - Optional Parameters:
     * @param "Limit" (optional.Float64) -  Maximum number of apps to return. Defaults to 20
     * @param "Grouping" (optional.String) -  typing of Grouping for the purposes of applying the limit. Can be: &#39;perTimeSlot&#39; ONLY

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetDeviceAppTimeAppsDataUsageOpts struct { 
	Limit optional.Float64
	Grouping optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetDeviceAppTimeAppsDataUsage(ctx context.Context, id string, locationId string, mac string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetDeviceAppTimeAppsDataUsageOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/appTime/apps/dataUsage"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the AppTime Apps Online Time Stats for a Device.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, AppTime Stats returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or device does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param timePeriod Any of \&quot;weekly\&quot;,\&quot;dailyToday\&quot;,\&quot;dailyYesterday\&quot;,\&quot;daily2DaysAgo\&quot;,\&quot;daily3DaysAgo\&quot;,\&quot;daily4DaysAgo\&quot;,\&quot;daily5DaysAgo\&quot;,\&quot;daily6DaysAgo\&quot;,\&quot;last30Days\&quot;,\&quot;last12Months\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetDeviceAppTimeAppsOnlineTimeOpts - Optional Parameters:
     * @param "Limit" (optional.Float64) -  Maximum number of apps to return. Defaults to 20
     * @param "Grouping" (optional.String) -  typing of Grouping for the purposes of applying the limit. Can be: &#39;perTimeSlot&#39; ONLY

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetDeviceAppTimeAppsOnlineTimeOpts struct { 
	Limit optional.Float64
	Grouping optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetDeviceAppTimeAppsOnlineTime(ctx context.Context, id string, locationId string, mac string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetDeviceAppTimeAppsOnlineTimeOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/appTime/apps/onlineTime"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the AppTime Categories Data Usage Stats for a Device.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, AppTime Stats returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or device does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param timePeriod Any of \&quot;weekly\&quot;,\&quot;dailyToday\&quot;,\&quot;dailyYesterday\&quot;,\&quot;daily2DaysAgo\&quot;,\&quot;daily3DaysAgo\&quot;,\&quot;daily4DaysAgo\&quot;,\&quot;daily5DaysAgo\&quot;,\&quot;daily6DaysAgo\&quot;,\&quot;last30Days\&quot;,\&quot;last12Months\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetDeviceAppTimeCategoriesDataUsageOpts - Optional Parameters:
     * @param "Limit" (optional.Float64) -  Maximum number of categories to return. Defaults to 20
     * @param "Grouping" (optional.String) -  typing of Grouping for the purposes of applying the limit. Can be: &#39;overall&#39;|&#39;perTimeSlot&#39;

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetDeviceAppTimeCategoriesDataUsageOpts struct { 
	Limit optional.Float64
	Grouping optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetDeviceAppTimeCategoriesDataUsage(ctx context.Context, id string, locationId string, mac string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetDeviceAppTimeCategoriesDataUsageOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/appTime/categories/dataUsage"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the AppTime Categories Online Time Stats for a Device.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, AppTime Stats returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or device does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param timePeriod Any of \&quot;weekly\&quot;,\&quot;dailyToday\&quot;,\&quot;dailyYesterday\&quot;,\&quot;daily2DaysAgo\&quot;,\&quot;daily3DaysAgo\&quot;,\&quot;daily4DaysAgo\&quot;,\&quot;daily5DaysAgo\&quot;,\&quot;daily6DaysAgo\&quot;,\&quot;last30Days\&quot;,\&quot;last12Months\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetDeviceAppTimeCategoriesOnlineTimeOpts - Optional Parameters:
     * @param "Limit" (optional.Float64) -  Maximum number of categories to return. Defaults to 20
     * @param "Grouping" (optional.String) -  typing of Grouping for the purposes of applying the limit. Can be: &#39;overall&#39;|&#39;perTimeSlot&#39;

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetDeviceAppTimeCategoriesOnlineTimeOpts struct { 
	Limit optional.Float64
	Grouping optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetDeviceAppTimeCategoriesOnlineTime(ctx context.Context, id string, locationId string, mac string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetDeviceAppTimeCategoriesOnlineTimeOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/appTime/categories/onlineTime"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Device band steering stats with all nodes for a particular MAC address.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId location id of devices and nodes
 * @param mac mac id of device
 * @param optional nil or *CustomerApiCustomerPrototypeGetDeviceBandSteeringStatsOpts - Optional Parameters:
     * @param "Granularity" (optional.String) -  days/hours/minutes
     * @param "Limit" (optional.Float64) -  X # of days/hours/minutes
     * @param "Start" (optional.Float64) -  number of milliseconds elapsed since 1 January 1970 00:00:00 UTC. Defaults to now - (limit * granularity)

@return XAny
*/

type CustomerApiCustomerPrototypeGetDeviceBandSteeringStatsOpts struct { 
	Granularity optional.String
	Limit optional.Float64
	Start optional.Float64
}

func (a *CustomerApiService) CustomerPrototypeGetDeviceBandSteeringStats(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypeGetDeviceBandSteeringStatsOpts) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/flex/devices/{mac}/bandSteeringStats"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Granularity.IsSet() {
		localVarQueryParams.Add("granularity", parameterToString(localVarOptionals.Granularity.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Start.IsSet() {
		localVarQueryParams.Add("start", parameterToString(localVarOptionals.Start.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Returns a single Device for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, device returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist. Or, device not found in this network &#39;s history.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac mac of device
 * @param optional nil or *CustomerApiCustomerPrototypeGetDeviceByMacOpts - Optional Parameters:
     * @param "Include" (optional.String) -  can be &#39;bandwidthData&#39;, &#39;chartsData&#39; or both. None means &#39;bandwidthData&#39; only.
     * @param "DaysOffline" (optional.Float64) -  exclude devices disconnected longer than daysOffline.

@return DeviceResponse
*/

type CustomerApiCustomerPrototypeGetDeviceByMacOpts struct { 
	Include optional.String
	DaysOffline optional.Float64
}

func (a *CustomerApiService) CustomerPrototypeGetDeviceByMac(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypeGetDeviceByMacOpts) (DeviceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Include.IsSet() {
		localVarQueryParams.Add("include", parameterToString(localVarOptionals.Include.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DaysOffline.IsSet() {
		localVarQueryParams.Add("daysOffline", parameterToString(localVarOptionals.DaysOffline.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Device client steering stats with all nodes for a particular MAC address.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId location id of devices and nodes
 * @param mac mac id of device
 * @param optional nil or *CustomerApiCustomerPrototypeGetDeviceClientSteeringStatsOpts - Optional Parameters:
     * @param "Granularity" (optional.String) -  days/hours/minutes
     * @param "Limit" (optional.Float64) -  X # of days/hours/minutes
     * @param "Start" (optional.Float64) -  number of milliseconds elapsed since 1 January 1970 00:00:00 UTC. Defaults to now - (limit * granularity)

@return XAny
*/

type CustomerApiCustomerPrototypeGetDeviceClientSteeringStatsOpts struct { 
	Granularity optional.String
	Limit optional.Float64
	Start optional.Float64
}

func (a *CustomerApiService) CustomerPrototypeGetDeviceClientSteeringStats(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypeGetDeviceClientSteeringStatsOpts) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/flex/devices/{mac}/clientSteeringStats"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Granularity.IsSet() {
		localVarQueryParams.Add("granularity", parameterToString(localVarOptionals.Granularity.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Start.IsSet() {
		localVarQueryParams.Add("start", parameterToString(localVarOptionals.Start.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get a list of device groups in a network, along with a list of member devices and group shares.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Unauthorized.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId

@return []XAny
*/
func (a *CustomerApiService) CustomerPrototypeGetDeviceGroups(ctx context.Context, id string, locationId string, networkId string) ([]XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkAccess/networks/{networkId}/deviceGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Device or pod QoE 15 minutes data.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac device mac address
 * @param optional nil or *CustomerApiCustomerPrototypeGetDeviceQoeMetricsOpts - Optional Parameters:
     * @param "Granularity" (optional.String) -  days/hours/minutes
     * @param "Limit" (optional.Float64) -  X # of days/hours/minutes
     * @param "TimestampISOFormat" (optional.Bool) -  either timestamp utc number or ISO string

@return interface{}
*/

type CustomerApiCustomerPrototypeGetDeviceQoeMetricsOpts struct { 
	Granularity optional.String
	Limit optional.Float64
	TimestampISOFormat optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeGetDeviceQoeMetrics(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypeGetDeviceQoeMetricsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/flex/devices/{mac}/qoeMetrics"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Granularity.IsSet() {
		localVarQueryParams.Add("granularity", parameterToString(localVarOptionals.Granularity.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TimestampISOFormat.IsSet() {
		localVarQueryParams.Add("timestampISOFormat", parameterToString(localVarOptionals.TimestampISOFormat.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Returns the security policy Device for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, device returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist. Or, device not found in this network &#39;s history.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac mac of device

@return DeviceResponse
*/
func (a *CustomerApiService) CustomerPrototypeGetDeviceSecurity(ctx context.Context, id string, locationId string, mac string) (DeviceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/securityPolicy"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get a Security Policy Events for Device for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac mac of device
 * @param startTime
 * @param optional nil or *CustomerApiCustomerPrototypeGetDeviceSecurityPolicyEventsOpts - Optional Parameters:
     * @param "Includes" (optional.String) - 
     * @param "Limit" (optional.Float64) - 
     * @param "Direction" (optional.String) - 
     * @param "ProtectionType" (optional.String) - 

@return SecurityEventsResponse
*/

type CustomerApiCustomerPrototypeGetDeviceSecurityPolicyEventsOpts struct { 
	Includes optional.String
	Limit optional.Float64
	Direction optional.String
	ProtectionType optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetDeviceSecurityPolicyEvents(ctx context.Context, id string, locationId string, mac string, startTime time.Time, localVarOptionals *CustomerApiCustomerPrototypeGetDeviceSecurityPolicyEventsOpts) (SecurityEventsResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SecurityEventsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/securityPolicy/events"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Includes.IsSet() {
		localVarQueryParams.Add("includes", parameterToString(localVarOptionals.Includes.Value(), ""))
	}
	localVarQueryParams.Add("startTime", parameterToString(startTime, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Direction.IsSet() {
		localVarQueryParams.Add("direction", parameterToString(localVarOptionals.Direction.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProtectionType.IsSet() {
		localVarQueryParams.Add("protectionType", parameterToString(localVarOptionals.ProtectionType.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v SecurityEventsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get a Security Policy Hourly Blocked Counts for a Device for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac mac of device

@return Counts
*/
func (a *CustomerApiService) CustomerPrototypeGetDeviceSecurityPolicyHourlyCounts(ctx context.Context, id string, locationId string, mac string) (Counts, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Counts
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/securityPolicy/hourlyBlockedCounts"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Counts
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the sounding states for eligible devices in this location
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, device sounding states returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeGetDeviceSoundingStateOpts - Optional Parameters:
     * @param "Mac" (optional.String) -  Optional mac address for single device lookup (fetches all devices by default)

@return interface{}
*/

type CustomerApiCustomerPrototypeGetDeviceSoundingStateOpts struct { 
	Mac optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetDeviceSoundingState(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeGetDeviceSoundingStateOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/homeSecurity/devices/sounding"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Mac.IsSet() {
		localVarQueryParams.Add("mac", parameterToString(localVarOptionals.Mac.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Find all instances of the model.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param optional nil or *CustomerApiCustomerPrototypeGetDeviceSteeringWithAthenaOpts - Optional Parameters:
     * @param "Order" (optional.String) -  desc || asc
     * @param "Limit" (optional.Float64) -  1000 max for deep:false and 10 max for deep:true
     * @param "StartAt" (optional.String) -  find objects after this value
     * @param "EndAt" (optional.String) -  find objects before this value

@return interface{}
*/

type CustomerApiCustomerPrototypeGetDeviceSteeringWithAthenaOpts struct { 
	Order optional.String
	Limit optional.Float64
	StartAt optional.String
	EndAt optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetDeviceSteeringWithAthena(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypeGetDeviceSteeringWithAthenaOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/flex/devices/{mac}/clientSteeringTriggers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Order.IsSet() {
		localVarQueryParams.Add("order", parameterToString(localVarOptionals.Order.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartAt.IsSet() {
		localVarQueryParams.Add("startAt", parameterToString(localVarOptionals.StartAt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndAt.IsSet() {
		localVarQueryParams.Add("endAt", parameterToString(localVarOptionals.EndAt.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get all the devices for a Location ID, including the device name, icon to use, MAC and IP  address, connecting nodes and more.
All devices with 2g, 5g and 6g channel settings &lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, array of Devices returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeGetDevicesOpts - Optional Parameters:
     * @param "DaysOffline" (optional.Float64) - 
     * @param "AllSSIDs" (optional.Bool) - 
     * @param "ShowPartnerComponent" (optional.Bool) - 

@return InlineResponse20011
*/

type CustomerApiCustomerPrototypeGetDevicesOpts struct { 
	DaysOffline optional.Float64
	AllSSIDs optional.Bool
	ShowPartnerComponent optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeGetDevices(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeGetDevicesOpts) (InlineResponse20011, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse20011
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.DaysOffline.IsSet() {
		localVarQueryParams.Add("daysOffline", parameterToString(localVarOptionals.DaysOffline.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AllSSIDs.IsSet() {
		localVarQueryParams.Add("allSSIDs", parameterToString(localVarOptionals.AllSSIDs.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ShowPartnerComponent.IsSet() {
		localVarQueryParams.Add("showPartnerComponent", parameterToString(localVarOptionals.ShowPartnerComponent.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse20011
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get current DHCP Configuration details for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, current dhcp returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or dhcp does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetDhcp(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkConfiguration/dhcp"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get current DHCP IP reservation details for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, current DhcpReservation returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or DhcpReservation does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: mac is empty, or invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac

@return DhcpReservation
*/
func (a *CustomerApiService) CustomerPrototypeGetDhcpReservation(ctx context.Context, id string, locationId string, mac string) (DhcpReservation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DhcpReservation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkConfiguration/dhcpReservations/{mac}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v DhcpReservation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get current DHCP IP reservation details for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, current DhcpReservation returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or DhcpReservation does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: mac is empty, or invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return []DhcpReservation
*/
func (a *CustomerApiService) CustomerPrototypeGetDhcpReservations(ctx context.Context, id string, locationId string) ([]DhcpReservation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []DhcpReservation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkConfiguration/dhcpReservations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []DhcpReservation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the current DNS IP addresses and settings for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, current DNS server settings returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: NetworkConfiguration or DNS server settings does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return DnsServers
*/
func (a *CustomerApiService) CustomerPrototypeGetDnsServers(ctx context.Context, id string, locationId string) (DnsServers, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DnsServers
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkConfiguration/dnsServers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v DnsServers
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the current DPP configuration for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, current DPP configuration returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetDpp(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/dpp"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Returns DPP announcements from controller
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypeGetDppAnnouncementsFromController(ctx context.Context, id string, locationId string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/dpp/announcements"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the AppTime Apps Data Usage Stats for fronthaul network.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, AppTime Stats returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or secondary networks does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param timePeriod Any of \&quot;weekly\&quot;,\&quot;dailyToday\&quot;,\&quot;dailyYesterday\&quot;,\&quot;daily2DaysAgo\&quot;,\&quot;daily3DaysAgo\&quot;,\&quot;daily4DaysAgo\&quot;,\&quot;daily5DaysAgo\&quot;,\&quot;daily6DaysAgo\&quot;,\&quot;last30Days\&quot;,\&quot;last12Months\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetEmployeeNetworkAppTimeAppsDataUsageOpts - Optional Parameters:
     * @param "Limit" (optional.Float64) -  Maximum number of apps to return. Defaults to 20
     * @param "Grouping" (optional.String) -  typing of Grouping for the purposes of applying the limit. Can be: &#39;perTimeSlot&#39; ONLY

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetEmployeeNetworkAppTimeAppsDataUsageOpts struct { 
	Limit optional.Float64
	Grouping optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetEmployeeNetworkAppTimeAppsDataUsage(ctx context.Context, id string, locationId string, networkId string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetEmployeeNetworkAppTimeAppsDataUsageOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/fronthauls/{networkId}/appTime/apps/dataUsage"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the AppTime Apps Online Time Stats for fronthaul network.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, AppTime Stats returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or secondary networks does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param timePeriod Any of \&quot;weekly\&quot;,\&quot;dailyToday\&quot;,\&quot;dailyYesterday\&quot;,\&quot;daily2DaysAgo\&quot;,\&quot;daily3DaysAgo\&quot;,\&quot;daily4DaysAgo\&quot;,\&quot;daily5DaysAgo\&quot;,\&quot;daily6DaysAgo\&quot;,\&quot;last30Days\&quot;,\&quot;last12Months\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetEmployeeNetworkAppTimeAppsOnlineTimeOpts - Optional Parameters:
     * @param "Limit" (optional.Float64) -  Maximum number of apps to return. Defaults to 20
     * @param "Grouping" (optional.String) -  typing of Grouping for the purposes of applying the limit. Can be: &#39;perTimeSlot&#39; ONLY

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetEmployeeNetworkAppTimeAppsOnlineTimeOpts struct { 
	Limit optional.Float64
	Grouping optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetEmployeeNetworkAppTimeAppsOnlineTime(ctx context.Context, id string, locationId string, networkId string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetEmployeeNetworkAppTimeAppsOnlineTimeOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/fronthauls/{networkId}/appTime/apps/onlineTime"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the AppTime Categories Data Usage Stats for fronthaul network.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, AppTime Stats returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or secondary networks does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param timePeriod Any of \&quot;weekly\&quot;,\&quot;dailyToday\&quot;,\&quot;dailyYesterday\&quot;,\&quot;daily2DaysAgo\&quot;,\&quot;daily3DaysAgo\&quot;,\&quot;daily4DaysAgo\&quot;,\&quot;daily5DaysAgo\&quot;,\&quot;daily6DaysAgo\&quot;,\&quot;last30Days\&quot;,\&quot;last12Months\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetEmployeeNetworkAppTimeCategoriesDataUsageOpts - Optional Parameters:
     * @param "Limit" (optional.Float64) -  Maximum number of categories to return. Defaults to 20
     * @param "Grouping" (optional.String) -  typing of Grouping for the purposes of applying the limit. Can be: &#39;overall&#39;|&#39;perTimeSlot&#39;

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetEmployeeNetworkAppTimeCategoriesDataUsageOpts struct { 
	Limit optional.Float64
	Grouping optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetEmployeeNetworkAppTimeCategoriesDataUsage(ctx context.Context, id string, locationId string, networkId string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetEmployeeNetworkAppTimeCategoriesDataUsageOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/fronthauls/{networkId}/appTime/categories/dataUsage"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the AppTime Categories Online Time Stats for fronthaul network.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, AppTime Stats returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or secondary networks does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param timePeriod Any of \&quot;weekly\&quot;,\&quot;dailyToday\&quot;,\&quot;dailyYesterday\&quot;,\&quot;daily2DaysAgo\&quot;,\&quot;daily3DaysAgo\&quot;,\&quot;daily4DaysAgo\&quot;,\&quot;daily5DaysAgo\&quot;,\&quot;daily6DaysAgo\&quot;,\&quot;last30Days\&quot;,\&quot;last12Months\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetEmployeeNetworkAppTimeCategoriesOnlineTimeOpts - Optional Parameters:
     * @param "Limit" (optional.Float64) -  Maximum number of categories to return. Defaults to 20
     * @param "Grouping" (optional.String) -  typing of Grouping for the purposes of applying the limit. Can be: &#39;overall&#39;|&#39;perTimeSlot&#39;

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetEmployeeNetworkAppTimeCategoriesOnlineTimeOpts struct { 
	Limit optional.Float64
	Grouping optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetEmployeeNetworkAppTimeCategoriesOnlineTime(ctx context.Context, id string, locationId string, networkId string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetEmployeeNetworkAppTimeCategoriesOnlineTimeOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/fronthauls/{networkId}/appTime/categories/onlineTime"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get a list of all locations on which you are assigned as a manager.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid email, name, access type or manager is already assigned to this location &lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetEntitledAccessList(ctx context.Context, id string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/entitledAccess"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the event history for this location
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, event array returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeGetEventHistoryOpts - Optional Parameters:
     * @param "From" (optional.Float64) -  UTC unix ts
     * @param "To" (optional.Float64) -  UTC unix ts, defaults to now
     * @param "Category" (optional.String) -  Filter events by category (Motion or Plume [config changes]). Multiple categories can be passed as a comma-separated string. Default is both.
     * @param "Limit" (optional.Float64) -  Maximum number of events to return. Defaults to 10
     * @param "Sort" (optional.Bool) -  whether the returned events will be post-sorted by timestamp

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetEventHistoryOpts struct { 
	From optional.Float64
	To optional.Float64
	Category optional.String
	Limit optional.Float64
	Sort optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeGetEventHistory(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeGetEventHistoryOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/homeSecurity/events/history"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.From.IsSet() {
		localVarQueryParams.Add("from", parameterToString(localVarOptionals.From.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.To.IsSet() {
		localVarQueryParams.Add("to", parameterToString(localVarOptionals.To.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Category.IsSet() {
		localVarQueryParams.Add("category", parameterToString(localVarOptionals.Category.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get from Controller Fast interference status.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Ok.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypeGetFastInterference(ctx context.Context, id string, locationId string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/fastInterference"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Firmware Upgrade Status
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, response object returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return []interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetFirmwareUpgradeStatus(ctx context.Context, id string, locationId string) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/firmware"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService GET the flow stats configuration
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, current flow stats configuration returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetFlowStats(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/flowStats"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService HTML or JSON (vertices[] + edges[]) used to display a Network Topology.
&lt;div&gt;The HTML and JSON to initialize and dynamically display and update a Topology.&lt;/div&gt; &lt;div&gt;The JSON can also be used to get a network&#39;s list of nodes + devices (a.k.a. vertices) and links (a.k.a., edges).&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt; &lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, HTML or JSON returned depending on \&quot;Accept\&quot; HTTP header.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeGetForceGraphOpts - Optional Parameters:
     * @param "Ip" (optional.String) -  deprecated and optional IP address of client displaying the topology
     * @param "Mac" (optional.String) -  optional mac address of client displaying the topology
     * @param "AuthKey" (optional.String) -  PubNub authKey
     * @param "SubscribeKey" (optional.String) -  PubNub subscribeKey
     * @param "View" (optional.String) -  view template override (e.g., iguana)
     * @param "AllSSIDs" (optional.Bool) - 
     * @param "ShowPartnerComponent" (optional.Bool) - 

@return string
*/

type CustomerApiCustomerPrototypeGetForceGraphOpts struct { 
	Ip optional.String
	Mac optional.String
	AuthKey optional.String
	SubscribeKey optional.String
	View optional.String
	AllSSIDs optional.Bool
	ShowPartnerComponent optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeGetForceGraph(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeGetForceGraphOpts) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/forceGraph"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Ip.IsSet() {
		localVarQueryParams.Add("ip", parameterToString(localVarOptionals.Ip.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Mac.IsSet() {
		localVarQueryParams.Add("mac", parameterToString(localVarOptionals.Mac.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AuthKey.IsSet() {
		localVarQueryParams.Add("authKey", parameterToString(localVarOptionals.AuthKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubscribeKey.IsSet() {
		localVarQueryParams.Add("subscribeKey", parameterToString(localVarOptionals.SubscribeKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.View.IsSet() {
		localVarQueryParams.Add("view", parameterToString(localVarOptionals.View.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AllSSIDs.IsSet() {
		localVarQueryParams.Add("allSSIDs", parameterToString(localVarOptionals.AllSSIDs.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ShowPartnerComponent.IsSet() {
		localVarQueryParams.Add("showPartnerComponent", parameterToString(localVarOptionals.ShowPartnerComponent.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the Front Haul Portal configs for a given Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, FrontHaul Networks returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or secondary network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return NetworkConfig
*/
func (a *CustomerApiService) CustomerPrototypeGetFrontHaulNetworks(ctx context.Context, id string, locationId string) (NetworkConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NetworkConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/fronthauls"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NetworkConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the current DPP configurator for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, current DPP configurator returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetFrontHaulsDpp(ctx context.Context, id string, locationId string, networkId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/fronthauls/{networkId}/dpp"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the frontline storage for this location
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, HomeSecurity object returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return FrontlineStorage
*/
func (a *CustomerApiService) CustomerPrototypeGetFrontlineStorage(ctx context.Context, id string, locationId string) (FrontlineStorage, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrontlineStorage
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/frontline/storage"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrontlineStorage
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the Gdpr Captive Portals data for a guest.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, GDPR Captive Portals data returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or secondary networks does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param email
 * @param localEndDate
 * @param localStartDate

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetGdprCaptivePortalsData(ctx context.Context, id string, locationId string, networkId string, email string, localEndDate string, localStartDate string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networks/{networkId}/gdprData"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("email", parameterToString(email, ""))
	localVarQueryParams.Add("localEndDate", parameterToString(localEndDate, ""))
	localVarQueryParams.Add("localStartDate", parameterToString(localStartDate, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get GroupOfUnassignedDevices freeze policy for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Ok.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypeGetGroupOfUnassignedDevicesFreezePolicy(ctx context.Context, id string, locationId string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/groupOfUnassignedDevices/freezePolicy"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get a Security Policy for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return Person
*/
func (a *CustomerApiService) CustomerPrototypeGetGroupOfUnassignedDevicesSecurityPolicy(ctx context.Context, id string, locationId string) (Person, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Person
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/groupOfUnassignedDevices/securityPolicy"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Person
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get a Security Policy Events for groupOfUnassignedDevices for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param startTime
 * @param optional nil or *CustomerApiCustomerPrototypeGetGroupOfUnassignedDevicesSecurityPolicyEventsOpts - Optional Parameters:
     * @param "Includes" (optional.String) - 
     * @param "Limit" (optional.Float64) - 
     * @param "Direction" (optional.String) - 
     * @param "ProtectionType" (optional.String) - 

@return SecurityEventsResponse
*/

type CustomerApiCustomerPrototypeGetGroupOfUnassignedDevicesSecurityPolicyEventsOpts struct { 
	Includes optional.String
	Limit optional.Float64
	Direction optional.String
	ProtectionType optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetGroupOfUnassignedDevicesSecurityPolicyEvents(ctx context.Context, id string, locationId string, startTime time.Time, localVarOptionals *CustomerApiCustomerPrototypeGetGroupOfUnassignedDevicesSecurityPolicyEventsOpts) (SecurityEventsResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SecurityEventsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/groupOfUnassignedDevices/securityPolicy/events"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Includes.IsSet() {
		localVarQueryParams.Add("includes", parameterToString(localVarOptionals.Includes.Value(), ""))
	}
	localVarQueryParams.Add("startTime", parameterToString(startTime, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Direction.IsSet() {
		localVarQueryParams.Add("direction", parameterToString(localVarOptionals.Direction.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProtectionType.IsSet() {
		localVarQueryParams.Add("protectionType", parameterToString(localVarOptionals.ProtectionType.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v SecurityEventsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get a Security Policy Hourly Blocked Counts for group Of Unassigned Devices for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return Counts
*/
func (a *CustomerApiService) CustomerPrototypeGetGroupOfUnassignedDevicesSecurityPolicyHourlyCounts(ctx context.Context, id string, locationId string) (Counts, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Counts
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/groupOfUnassignedDevices/securityPolicy/hourlyBlockedCounts"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Counts
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id

@return []XAny
*/
func (a *CustomerApiService) CustomerPrototypeGetGroups(ctx context.Context, id string) ([]XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the AppTime Apps Data Usage Stats for captivePortal network.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, AppTime Stats returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or secondary networks does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param timePeriod Any of \&quot;weekly\&quot;,\&quot;dailyToday\&quot;,\&quot;dailyYesterday\&quot;,\&quot;daily2DaysAgo\&quot;,\&quot;daily3DaysAgo\&quot;,\&quot;daily4DaysAgo\&quot;,\&quot;daily5DaysAgo\&quot;,\&quot;daily6DaysAgo\&quot;,\&quot;last30Days\&quot;,\&quot;last12Months\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetGuestNetworkAppTimeAppsDataUsageOpts - Optional Parameters:
     * @param "Limit" (optional.Float64) -  Maximum number of apps to return. Defaults to 20
     * @param "Grouping" (optional.String) -  typing of Grouping for the purposes of applying the limit. Can be: &#39;perTimeSlot&#39; ONLY

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetGuestNetworkAppTimeAppsDataUsageOpts struct { 
	Limit optional.Float64
	Grouping optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetGuestNetworkAppTimeAppsDataUsage(ctx context.Context, id string, locationId string, networkId string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetGuestNetworkAppTimeAppsDataUsageOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/{networkId}/appTime/apps/dataUsage"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the AppTime Apps Online Time Stats for captivePortal network.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, AppTime Stats returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or secondary networks does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param timePeriod Any of \&quot;weekly\&quot;,\&quot;dailyToday\&quot;,\&quot;dailyYesterday\&quot;,\&quot;daily2DaysAgo\&quot;,\&quot;daily3DaysAgo\&quot;,\&quot;daily4DaysAgo\&quot;,\&quot;daily5DaysAgo\&quot;,\&quot;daily6DaysAgo\&quot;,\&quot;last30Days\&quot;,\&quot;last12Months\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetGuestNetworkAppTimeAppsOnlineTimeOpts - Optional Parameters:
     * @param "Limit" (optional.Float64) -  Maximum number of apps to return. Defaults to 20
     * @param "Grouping" (optional.String) -  typing of Grouping for the purposes of applying the limit. Can be: &#39;perTimeSlot&#39; ONLY

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetGuestNetworkAppTimeAppsOnlineTimeOpts struct { 
	Limit optional.Float64
	Grouping optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetGuestNetworkAppTimeAppsOnlineTime(ctx context.Context, id string, locationId string, networkId string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetGuestNetworkAppTimeAppsOnlineTimeOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/{networkId}/appTime/apps/onlineTime"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the AppTime Categories Data Usage Stats for captivePortal network.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, AppTime Stats returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or secondary networks does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param timePeriod Any of \&quot;weekly\&quot;,\&quot;dailyToday\&quot;,\&quot;dailyYesterday\&quot;,\&quot;daily2DaysAgo\&quot;,\&quot;daily3DaysAgo\&quot;,\&quot;daily4DaysAgo\&quot;,\&quot;daily5DaysAgo\&quot;,\&quot;daily6DaysAgo\&quot;,\&quot;last30Days\&quot;,\&quot;last12Months\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetGuestNetworkAppTimeCategoriesDataUsageOpts - Optional Parameters:
     * @param "Limit" (optional.Float64) -  Maximum number of categories to return. Defaults to 20
     * @param "Grouping" (optional.String) -  typing of Grouping for the purposes of applying the limit. Can be: &#39;overall&#39;|&#39;perTimeSlot&#39;

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetGuestNetworkAppTimeCategoriesDataUsageOpts struct { 
	Limit optional.Float64
	Grouping optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetGuestNetworkAppTimeCategoriesDataUsage(ctx context.Context, id string, locationId string, networkId string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetGuestNetworkAppTimeCategoriesDataUsageOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/{networkId}/appTime/categories/dataUsage"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the AppTime Categories Online Time Stats for captivePortal network.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, AppTime Stats returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or secondary networks does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param timePeriod Any of \&quot;weekly\&quot;,\&quot;dailyToday\&quot;,\&quot;dailyYesterday\&quot;,\&quot;daily2DaysAgo\&quot;,\&quot;daily3DaysAgo\&quot;,\&quot;daily4DaysAgo\&quot;,\&quot;daily5DaysAgo\&quot;,\&quot;daily6DaysAgo\&quot;,\&quot;last30Days\&quot;,\&quot;last12Months\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetGuestNetworkAppTimeCategoriesOnlineTimeOpts - Optional Parameters:
     * @param "Limit" (optional.Float64) -  Maximum number of categories to return. Defaults to 20
     * @param "Grouping" (optional.String) -  typing of Grouping for the purposes of applying the limit. Can be: &#39;overall&#39;|&#39;perTimeSlot&#39;

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetGuestNetworkAppTimeCategoriesOnlineTimeOpts struct { 
	Limit optional.Float64
	Grouping optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetGuestNetworkAppTimeCategoriesOnlineTime(ctx context.Context, id string, locationId string, networkId string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetGuestNetworkAppTimeCategoriesOnlineTimeOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/{networkId}/appTime/categories/onlineTime"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the all the Homeaway events history for this location
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, event array returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeGetHomeAwayLocationEventsOpts - Optional Parameters:
     * @param "From" (optional.Float64) -  UTC unix epoch ms, defaults to 1 week ago
     * @param "To" (optional.Float64) -  UTC unix epoch ms, defaults to now
     * @param "Limit" (optional.Float64) -  Maximum number of events to return. Defaults to 100

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetHomeAwayLocationEventsOpts struct { 
	From optional.Float64
	To optional.Float64
	Limit optional.Float64
}

func (a *CustomerApiService) CustomerPrototypeGetHomeAwayLocationEvents(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeGetHomeAwayLocationEventsOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/homeAway/events"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.From.IsSet() {
		localVarQueryParams.Add("from", parameterToString(localVarOptionals.From.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.To.IsSet() {
		localVarQueryParams.Add("to", parameterToString(localVarOptionals.To.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the home security configuration for this location
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, HomeSecurity object returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return HomeSecurity
*/
func (a *CustomerApiService) CustomerPrototypeGetHomeSecurity(ctx context.Context, id string, locationId string) (HomeSecurity, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue HomeSecurity
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/homeSecurity"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v HomeSecurity
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetIPv6(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/ipv6"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Retrieve all kvConfigs on a particular Node for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, your new info looks good.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: nodeId must be defined.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;425&lt;/strong&gt;: nodeId must belong to the location.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param nodeId

@return []KvConfig
*/
func (a *CustomerApiService) CustomerPrototypeGetKvConfigs(ctx context.Context, id string, locationId string, nodeId string) ([]KvConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []KvConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodes/{nodeId}/kvConfigs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []KvConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get a Location&#39;s AppTime config by location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetLocationAppTime(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/appTime"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the non-base feature capabilities supported by a particular Location ID.
&lt;div&gt;The controller will implement logic to determine the non-base features supported by the Pods in the location ID. The feature capability is determined on the system level, and not per individual Pod.&lt;/div&gt; &lt;div&gt;The mobile apps or other WebUIs should only show the UI for a feature if the disabled value equals \&quot;false\&quot;.&lt;/div&gt; &lt;div&gt;&amp;nbsp;&lt;/div&gt; &lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, current Capabilities returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return CapabilitiesResponse
*/
func (a *CustomerApiService) CustomerPrototypeGetLocationCapabilities(ctx context.Context, id string, locationId string) (CapabilitiesResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CapabilitiesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/capabilities"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v CapabilitiesResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get a Config Audit Trail Events for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param includes
 * @param startTime
 * @param optional nil or *CustomerApiCustomerPrototypeGetLocationConfigAuditEventsOpts - Optional Parameters:
     * @param "Limit" (optional.Float64) - 
     * @param "Direction" (optional.String) - 

@return ConfigAuditEventsResponse
*/

type CustomerApiCustomerPrototypeGetLocationConfigAuditEventsOpts struct { 
	Limit optional.Float64
	Direction optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetLocationConfigAuditEvents(ctx context.Context, id string, locationId string, includes string, startTime time.Time, localVarOptionals *CustomerApiCustomerPrototypeGetLocationConfigAuditEventsOpts) (ConfigAuditEventsResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConfigAuditEventsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/configAudit/events"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("includes", parameterToString(includes, ""))
	localVarQueryParams.Add("startTime", parameterToString(startTime, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Direction.IsSet() {
		localVarQueryParams.Add("direction", parameterToString(localVarOptionals.Direction.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ConfigAuditEventsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get all devices/persons except some to be frozen for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypeGetLocationFreezeAutoExpire(ctx context.Context, id string, locationId string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/freeze/autoExpire"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the Guard Event Stats for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param timePeriod Any of \&quot;last24Hours\&quot;,\&quot;last7Days\&quot;,\&quot;last30Days\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetLocationGuardEventStatsOpts - Optional Parameters:
     * @param "Macs" (optional.String) -  array of macs[]
     * @param "Persons" (optional.String) -  array of personIds[]
     * @param "ProtectionType" (optional.String) -  filter by protectionType: ihp | ohp. Returns all types by default.
     * @param "EventTypes" (optional.String) -  filter by event type, any combo of: &#39;adBlocking&#39;,&#39;teenagers&#39;,&#39;kids&#39;,&#39;adultAndSensitive&#39;,&#39;secureAndProtect&#39;,&#39;ipThreatOutbound&#39;,&#39;ipThreatInbound&#39;, &#39;iotProtect&#39;. Returns all types by default.
     * @param "GroupOfUnassignedDevices" (optional.Bool) -  to include the group of unassigned devices

@return SecurityEventsResponse
*/

type CustomerApiCustomerPrototypeGetLocationGuardEventStatsOpts struct { 
	Macs optional.String
	Persons optional.String
	ProtectionType optional.String
	EventTypes optional.String
	GroupOfUnassignedDevices optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeGetLocationGuardEventStats(ctx context.Context, id string, locationId string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetLocationGuardEventStatsOpts) (SecurityEventsResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SecurityEventsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy/guard/eventStats"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Macs.IsSet() {
		localVarFormParams.Add("macs", parameterToString(localVarOptionals.Macs.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Persons.IsSet() {
		localVarFormParams.Add("persons", parameterToString(localVarOptionals.Persons.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProtectionType.IsSet() {
		localVarFormParams.Add("protectionType", parameterToString(localVarOptionals.ProtectionType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventTypes.IsSet() {
		localVarFormParams.Add("eventTypes", parameterToString(localVarOptionals.EventTypes.Value(), ""))
	}
	localVarFormParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.GroupOfUnassignedDevices.IsSet() {
		localVarFormParams.Add("groupOfUnassignedDevices", parameterToString(localVarOptionals.GroupOfUnassignedDevices.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v SecurityEventsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the Guard Event Domain Groups for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeGetLocationGuardEventsTldOrIpOpts - Optional Parameters:
     * @param "Macs" (optional.String) -  array of macs[]
     * @param "Persons" (optional.String) -  array of personIds[]
     * @param "TldOrIp" (optional.String) -  top level domain or IP address
     * @param "ProtectionType" (optional.String) -  filter by protectionType: ihp | ohp. Returns all types by default.
     * @param "EventTypes" (optional.String) -  filter by event type, any combo of: &#39;adBlocking&#39;,&#39;teenagers&#39;,&#39;kids&#39;,&#39;adultAndSensitive&#39;,&#39;secureAndProtect&#39;,&#39;ipThreatOutbound&#39;,&#39;ipThreatInbound&#39;, &#39;iotProtect&#39;. Returns all types by default.
     * @param "TimePeriod" (optional.String) -  Any of \&quot;last24Hours\&quot;, \&quot;last7Days\&quot;, \&quot;last30Days\&quot;
     * @param "GroupOfUnassignedDevices" (optional.Bool) -  to include the group of unassigned devices

@return SecurityEventsResponse
*/

type CustomerApiCustomerPrototypeGetLocationGuardEventsTldOrIpOpts struct { 
	Macs optional.String
	Persons optional.String
	TldOrIp optional.String
	ProtectionType optional.String
	EventTypes optional.String
	TimePeriod optional.String
	GroupOfUnassignedDevices optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeGetLocationGuardEventsTldOrIp(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeGetLocationGuardEventsTldOrIpOpts) (SecurityEventsResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SecurityEventsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy/guard/events"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Macs.IsSet() {
		localVarFormParams.Add("macs", parameterToString(localVarOptionals.Macs.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Persons.IsSet() {
		localVarFormParams.Add("persons", parameterToString(localVarOptionals.Persons.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TldOrIp.IsSet() {
		localVarFormParams.Add("tldOrIp", parameterToString(localVarOptionals.TldOrIp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProtectionType.IsSet() {
		localVarFormParams.Add("protectionType", parameterToString(localVarOptionals.ProtectionType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventTypes.IsSet() {
		localVarFormParams.Add("eventTypes", parameterToString(localVarOptionals.EventTypes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TimePeriod.IsSet() {
		localVarFormParams.Add("timePeriod", parameterToString(localVarOptionals.TimePeriod.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GroupOfUnassignedDevices.IsSet() {
		localVarFormParams.Add("groupOfUnassignedDevices", parameterToString(localVarOptionals.GroupOfUnassignedDevices.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v SecurityEventsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the Guard Event Stats for all persons in a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param timePeriod Any of \&quot;last24Hours\&quot;,\&quot;last7Days\&quot;,\&quot;last30Days\&quot;

@return PersonEventStats
*/
func (a *CustomerApiService) CustomerPrototypeGetLocationGuardPersonEventsSummary(ctx context.Context, id string, locationId string, timePeriod string) (PersonEventStats, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PersonEventStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy/guard/personEventsSummary"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("timePeriod", parameterToString(timePeriod, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v PersonEventStats
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Retrieve all kvStates on a particular Node for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, your new info looks good.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: nodeId must be defined.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;425&lt;/strong&gt;: nodeId must belong to the location.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetLocationKvStates(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/kvStates"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Gets all the configs from Overlord for a specified location.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, got the data.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetLocationOverlordConfigs(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/v2/configAndState"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get QoE recent 1 minute data for a whole location.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetLocationQoe(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/flex/qoe"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get a Location&#39;s Rooms config by location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetLocationRooms(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/rooms"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get a Security Policy for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return Person
*/
func (a *CustomerApiService) CustomerPrototypeGetLocationSecurityPolicy(ctx context.Context, id string, locationId string) (Person, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Person
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Person
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get a Security Policy Events for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param startTime
 * @param optional nil or *CustomerApiCustomerPrototypeGetLocationSecurityPolicyEventsOpts - Optional Parameters:
     * @param "Includes" (optional.String) - 
     * @param "Limit" (optional.Float64) - 
     * @param "Direction" (optional.String) - 
     * @param "ProtectionType" (optional.String) - 

@return SecurityEventsResponse
*/

type CustomerApiCustomerPrototypeGetLocationSecurityPolicyEventsOpts struct { 
	Includes optional.String
	Limit optional.Float64
	Direction optional.String
	ProtectionType optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetLocationSecurityPolicyEvents(ctx context.Context, id string, locationId string, startTime time.Time, localVarOptionals *CustomerApiCustomerPrototypeGetLocationSecurityPolicyEventsOpts) (SecurityEventsResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SecurityEventsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy/events"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Includes.IsSet() {
		localVarQueryParams.Add("includes", parameterToString(localVarOptionals.Includes.Value(), ""))
	}
	localVarQueryParams.Add("startTime", parameterToString(startTime, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Direction.IsSet() {
		localVarQueryParams.Add("direction", parameterToString(localVarOptionals.Direction.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProtectionType.IsSet() {
		localVarQueryParams.Add("protectionType", parameterToString(localVarOptionals.ProtectionType.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v SecurityEventsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get a Security Policy Hourly Blocked Counts for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return Counts
*/
func (a *CustomerApiService) CustomerPrototypeGetLocationSecurityPolicyHourlyCounts(ctx context.Context, id string, locationId string) (Counts, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Counts
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy/hourlyBlockedCounts"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Counts
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get WAN Configuration for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, WAN Settings returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetLocationWanConfiguration(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wanConfiguration"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService DEPRECATED: Get the WAN Settings for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, WAN Settings returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return LocationWanSettings
*/
func (a *CustomerApiService) CustomerPrototypeGetLocationWanSettings(ctx context.Context, id string, locationId string) (LocationWanSettings, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue LocationWanSettings
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wanSettings"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v LocationWanSettings
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Queries locations of Customer.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, full object returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: LocationId not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param optional nil or *CustomerApiCustomerPrototypeGetLocationsOpts - Optional Parameters:
     * @param "Include" (optional.String) -  CSV value of objects to add to the response: summary (is the only option for now)

@return Location
*/

type CustomerApiCustomerPrototypeGetLocationsOpts struct { 
	Include optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetLocations(ctx context.Context, id string, localVarOptionals *CustomerApiCustomerPrototypeGetLocationsOpts) (Location, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Location
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Include.IsSet() {
		localVarQueryParams.Add("include", parameterToString(localVarOptionals.Include.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Location
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get a list of all managers the are assigned to manage your location.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetManagersListForLocation(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/managers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetches hasOne relation _migration.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param optional nil or *CustomerApiCustomerPrototypeGetMigrationOpts - Optional Parameters:
     * @param "Refresh" (optional.Bool) - 

@return Migration
*/

type CustomerApiCustomerPrototypeGetMigrationOpts struct { 
	Refresh optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeGetMigration(ctx context.Context, id string, localVarOptionals *CustomerApiCustomerPrototypeGetMigrationOpts) (Migration, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Migration
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/_migration"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Refresh.IsSet() {
		localVarQueryParams.Add("refresh", parameterToString(localVarOptionals.Refresh.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Migration
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Retrieve all firmaware modules for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, your new info looks good.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetModulesFromController(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/firmware/modules"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the motion density history for this location
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, motion density array returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeGetMotionHistoryOpts - Optional Parameters:
     * @param "From" (optional.Float64) -  UTC unix ts
     * @param "To" (optional.Float64) -  UTC unix ts, defaults to now
     * @param "Bucket" (optional.Float64) -  number of seconds in density calculation window; returned data points represent % of non-zero intensity values in the window

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetMotionHistoryOpts struct { 
	From optional.Float64
	To optional.Float64
	Bucket optional.Float64
}

func (a *CustomerApiService) CustomerPrototypeGetMotionHistory(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeGetMotionHistoryOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/homeSecurity/motionHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.From.IsSet() {
		localVarQueryParams.Add("from", parameterToString(localVarOptionals.From.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.To.IsSet() {
		localVarQueryParams.Add("to", parameterToString(localVarOptionals.To.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Bucket.IsSet() {
		localVarQueryParams.Add("bucket", parameterToString(localVarOptionals.Bucket.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the motion state history for this location
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, motion state array returned (Each element of the array is in the form [\&quot;val\&quot;, \&quot;unix_ts\&quot;], where \&quot;val\&quot; is one of:  &lt;div&gt;0 - Not armed, not tripped&lt;/div&gt; &lt;div&gt;1 - Not armed, tripped&lt;/div&gt; &lt;div&gt;2 - Armed, not tripped&lt;/div&gt; &lt;div&gt;3 - Armed, tripped&lt;/div&gt;&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeGetMotionStateHistoryOpts - Optional Parameters:
     * @param "From" (optional.Float64) -  UTC unix ts
     * @param "To" (optional.Float64) -  UTC unix ts, defaults to now
     * @param "Bucket" (optional.Float64) -  number of seconds in density calculation window; returned data points represent % of non-zero intensity values in the window

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetMotionStateHistoryOpts struct { 
	From optional.Float64
	To optional.Float64
	Bucket optional.Float64
}

func (a *CustomerApiService) CustomerPrototypeGetMotionStateHistory(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeGetMotionStateHistoryOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/homeSecurity/motionHistory/state"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.From.IsSet() {
		localVarQueryParams.Add("from", parameterToString(localVarOptionals.From.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.To.IsSet() {
		localVarQueryParams.Add("to", parameterToString(localVarOptionals.To.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Bucket.IsSet() {
		localVarQueryParams.Add("bucket", parameterToString(localVarOptionals.Bucket.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get information about networkAccess networks
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return []NetworkAccessNetwork
*/
func (a *CustomerApiService) CustomerPrototypeGetNetworkAccessNetworks(ctx context.Context, id string, locationId string) ([]NetworkAccessNetwork, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []NetworkAccessNetwork
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkAccess/networks"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []NetworkAccessNetwork
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the current overall settings and status of the Advanced Networking settings for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, current networkConfiguration settings returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return NetworkConfigurationHome
*/
func (a *CustomerApiService) CustomerPrototypeGetNetworkConfigurationHome(ctx context.Context, id string, locationId string) (NetworkConfigurationHome, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NetworkConfigurationHome
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkConfiguration/home"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NetworkConfigurationHome
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the current Network Mode for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, current NetworkMode returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or NetworkMode does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return InlineResponse2005
*/
func (a *CustomerApiService) CustomerPrototypeGetNetworkMode(ctx context.Context, id string, locationId string) (InlineResponse2005, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2005
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkMode"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2005
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get BLE pairing pin for a node that is claimed by the selected location
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, pin generated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location or node does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid token. &lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param nodeId
 * @param token

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetNodeBlePairingPin(ctx context.Context, id string, locationId string, nodeId string, token string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodes/{nodeId}/blePairingPin"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("token", parameterToString(token, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Returns a single Node for a Location ID with its list of connected devices.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, node returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist. Or, nodeId not claimed to this account.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param nodeId id of node

@return NodeResponse
*/
func (a *CustomerApiService) CustomerPrototypeGetNodeBySerialNumber(ctx context.Context, id string, locationId string, nodeId string) (NodeResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NodeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodes/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NodeResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Retrieve all kvStates on a particular Node for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, your new info looks good.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: nodeId must be defined.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;425&lt;/strong&gt;: nodeId must belong to the location.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param nodeId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetNodeKvStates(ctx context.Context, id string, locationId string, nodeId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodes/{nodeId}/kvStates"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Retrieve the Node settings and status for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, array of Nodes returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return InlineResponse20010
*/
func (a *CustomerApiService) CustomerPrototypeGetNodes(ctx context.Context, id string, locationId string) (InlineResponse20010, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse20010
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodes"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse20010
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the current OHP identifier for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, current DPP configurator returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetOhpLocationIdentifier(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy/ohp/locationIdentifier"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the onboarding identifier for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, current DPP configurator returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetOnboardingLocationIdentifier(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/onboardingLocationIdentifier"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the AppTime Apps Data Usage Stats for a Person.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, AppTime Stats returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or person does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId
 * @param timePeriod Any of \&quot;weekly\&quot;,\&quot;dailyToday\&quot;,\&quot;dailyYesterday\&quot;,\&quot;daily2DaysAgo\&quot;,\&quot;daily3DaysAgo\&quot;,\&quot;daily4DaysAgo\&quot;,\&quot;daily5DaysAgo\&quot;,\&quot;daily6DaysAgo\&quot;,\&quot;last30Days\&quot;,\&quot;last12Months\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetPersonAppTimeAppsDataUsageOpts - Optional Parameters:
     * @param "Limit" (optional.Float64) -  Maximum number of apps to return. Defaults to 20
     * @param "Grouping" (optional.String) -  typing of Grouping for the purposes of applying the limit. Can be: &#39;perTimeSlot&#39; ONLY

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetPersonAppTimeAppsDataUsageOpts struct { 
	Limit optional.Float64
	Grouping optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetPersonAppTimeAppsDataUsage(ctx context.Context, id string, locationId string, personId string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetPersonAppTimeAppsDataUsageOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/appTime/apps/dataUsage"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the AppTime Apps Online Time Stats for a Person.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, AppTime Stats returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or person does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId
 * @param timePeriod Any of \&quot;weekly\&quot;,\&quot;dailyToday\&quot;,\&quot;dailyYesterday\&quot;,\&quot;daily2DaysAgo\&quot;,\&quot;daily3DaysAgo\&quot;,\&quot;daily4DaysAgo\&quot;,\&quot;daily5DaysAgo\&quot;,\&quot;daily6DaysAgo\&quot;,\&quot;last30Days\&quot;,\&quot;last12Months\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetPersonAppTimeAppsOnlineTimeOpts - Optional Parameters:
     * @param "Limit" (optional.Float64) -  Maximum number of apps to return. Defaults to 20
     * @param "Grouping" (optional.String) -  typing of Grouping for the purposes of applying the limit. Can be: &#39;perTimeSlot&#39; ONLY

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetPersonAppTimeAppsOnlineTimeOpts struct { 
	Limit optional.Float64
	Grouping optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetPersonAppTimeAppsOnlineTime(ctx context.Context, id string, locationId string, personId string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetPersonAppTimeAppsOnlineTimeOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/appTime/apps/onlineTime"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the AppTime Categories Data Usage Stats for a Person.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, AppTime Stats returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or person does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId
 * @param timePeriod Any of \&quot;weekly\&quot;,\&quot;dailyToday\&quot;,\&quot;dailyYesterday\&quot;,\&quot;daily2DaysAgo\&quot;,\&quot;daily3DaysAgo\&quot;,\&quot;daily4DaysAgo\&quot;,\&quot;daily5DaysAgo\&quot;,\&quot;daily6DaysAgo\&quot;,\&quot;last30Days\&quot;,\&quot;last12Months\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetPersonAppTimeCategoriesDataUsageOpts - Optional Parameters:
     * @param "Limit" (optional.Float64) -  Maximum number of categories to return. Defaults to 20
     * @param "Grouping" (optional.String) -  typing of Grouping for the purposes of applying the limit. Can be: &#39;overall&#39;|&#39;perTimeSlot&#39;

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetPersonAppTimeCategoriesDataUsageOpts struct { 
	Limit optional.Float64
	Grouping optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetPersonAppTimeCategoriesDataUsage(ctx context.Context, id string, locationId string, personId string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetPersonAppTimeCategoriesDataUsageOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/appTime/categories/dataUsage"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the AppTime Categories Online Time Stats for a Person.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, AppTime Stats returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or person does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId
 * @param timePeriod Any of \&quot;weekly\&quot;,\&quot;dailyToday\&quot;,\&quot;dailyYesterday\&quot;,\&quot;daily2DaysAgo\&quot;,\&quot;daily3DaysAgo\&quot;,\&quot;daily4DaysAgo\&quot;,\&quot;daily5DaysAgo\&quot;,\&quot;daily6DaysAgo\&quot;,\&quot;last30Days\&quot;,\&quot;last12Months\&quot;
 * @param optional nil or *CustomerApiCustomerPrototypeGetPersonAppTimeCategoriesOnlineTimeOpts - Optional Parameters:
     * @param "Limit" (optional.Float64) -  Maximum number of categories to return. Defaults to 20
     * @param "Grouping" (optional.String) -  typing of Grouping for the purposes of applying the limit. Can be: &#39;overall&#39;|&#39;perTimeSlot&#39;

@return []interface{}
*/

type CustomerApiCustomerPrototypeGetPersonAppTimeCategoriesOnlineTimeOpts struct { 
	Limit optional.Float64
	Grouping optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetPersonAppTimeCategoriesOnlineTime(ctx context.Context, id string, locationId string, personId string, timePeriod string, localVarOptionals *CustomerApiCustomerPrototypeGetPersonAppTimeCategoriesOnlineTimeOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/appTime/categories/onlineTime"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("timePeriod", parameterToString(timePeriod, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Grouping.IsSet() {
		localVarQueryParams.Add("grouping", parameterToString(localVarOptionals.Grouping.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get a Person by ID for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId

@return Person
*/
func (a *CustomerApiService) CustomerPrototypeGetPersonById(ctx context.Context, id string, locationId string, personId string) (Person, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Person
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Person
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get a Security Policy Events for Person for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId person
 * @param startTime
 * @param optional nil or *CustomerApiCustomerPrototypeGetPersonSecurityPolicyEventsOpts - Optional Parameters:
     * @param "Includes" (optional.String) - 
     * @param "Limit" (optional.Float64) - 
     * @param "Direction" (optional.String) - 
     * @param "ProtectionType" (optional.String) - 

@return SecurityEventsResponse
*/

type CustomerApiCustomerPrototypeGetPersonSecurityPolicyEventsOpts struct { 
	Includes optional.String
	Limit optional.Float64
	Direction optional.String
	ProtectionType optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetPersonSecurityPolicyEvents(ctx context.Context, id string, locationId string, personId string, startTime time.Time, localVarOptionals *CustomerApiCustomerPrototypeGetPersonSecurityPolicyEventsOpts) (SecurityEventsResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SecurityEventsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/securityPolicy/events"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Includes.IsSet() {
		localVarQueryParams.Add("includes", parameterToString(localVarOptionals.Includes.Value(), ""))
	}
	localVarQueryParams.Add("startTime", parameterToString(startTime, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Direction.IsSet() {
		localVarQueryParams.Add("direction", parameterToString(localVarOptionals.Direction.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProtectionType.IsSet() {
		localVarQueryParams.Add("protectionType", parameterToString(localVarOptionals.ProtectionType.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v SecurityEventsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get a Security Policy Hourly Blocked Counts for a Person for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId person

@return Counts
*/
func (a *CustomerApiService) CustomerPrototypeGetPersonSecurityPolicyHourlyCounts(ctx context.Context, id string, locationId string, personId string) (Counts, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Counts
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/securityPolicy/hourlyBlockedCounts"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Counts
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get all Persons for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return []Person
*/
func (a *CustomerApiService) CustomerPrototypeGetPersons(ctx context.Context, id string, locationId string) ([]Person, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Person
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []Person
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get all existing Port Forwarding entries for an existing DHCP IP reservation tied to a MAC address at a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, current Port Forwarding entries  returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: NetworkConfiguration or dhcpReservations value is empty.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: mac is empty or invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac

@return []PortForward
*/
func (a *CustomerApiService) CustomerPrototypeGetPortForwards(ctx context.Context, id string, locationId string, mac string) ([]PortForward, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []PortForward
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkConfiguration/dhcpReservations/{mac}/portForwards"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []PortForward
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get networks for wpa3 transition flow
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, returns the data&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or wifiNetwork does not exist&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypeGetPrimarySecondaryNetworks(ctx context.Context, id string, locationId string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/primarySecondaryNetworks"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Device or pod QoE live mode data.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac mac address or pod id
 * @param optional nil or *CustomerApiCustomerPrototypeGetQoe1MinuteOpts - Optional Parameters:
     * @param "StartTime" (optional.Float64) -  start timestamp
     * @param "TimestampISOFormat" (optional.Bool) -  either timestamp utc number or ISO string

@return interface{}
*/

type CustomerApiCustomerPrototypeGetQoe1MinuteOpts struct { 
	StartTime optional.Float64
	TimestampISOFormat optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeGetQoe1Minute(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypeGetQoe1MinuteOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/flex/devices/{mac}/qoe/liveModeStream"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.StartTime.IsSet() {
		localVarQueryParams.Add("startTime", parameterToString(localVarOptionals.StartTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TimestampISOFormat.IsSet() {
		localVarQueryParams.Add("timestampISOFormat", parameterToString(localVarOptionals.TimestampISOFormat.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Device or pod QoE super live mode data.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac mac address or pod id
 * @param optional nil or *CustomerApiCustomerPrototypeGetQoeSecondsOpts - Optional Parameters:
     * @param "StartTime" (optional.Float64) -  start timestamp
     * @param "TimestampISOFormat" (optional.Bool) -  either timestamp utc number or ISO string

@return interface{}
*/

type CustomerApiCustomerPrototypeGetQoeSecondsOpts struct { 
	StartTime optional.Float64
	TimestampISOFormat optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeGetQoeSeconds(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypeGetQoeSecondsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/flex/devices/{mac}/qoe/superLiveModeStream"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.StartTime.IsSet() {
		localVarQueryParams.Add("startTime", parameterToString(localVarOptionals.StartTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TimestampISOFormat.IsSet() {
		localVarQueryParams.Add("timestampISOFormat", parameterToString(localVarOptionals.TimestampISOFormat.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the Unauthorized Remote Connections config for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetRemoteConnectionsConfig(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy/remoteConnections"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Queries roles of Customer.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param optional nil or *CustomerApiCustomerPrototypeGetRolesOpts - Optional Parameters:
     * @param "Filter" (optional.String) - 

@return []Role
*/

type CustomerApiCustomerPrototypeGetRolesOpts struct { 
	Filter optional.String
}

func (a *CustomerApiService) CustomerPrototypeGetRoles(ctx context.Context, id string, localVarOptionals *CustomerApiCustomerPrototypeGetRolesOpts) ([]Role, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []Role
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Filter.IsSet() {
		localVarQueryParams.Add("filter", parameterToString(localVarOptionals.Filter.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []Role
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update home devices visible to guests.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, Invitation returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Customer id, location id&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return Invitation
*/
func (a *CustomerApiService) CustomerPrototypeGetSecondaryNetworkInvitation(ctx context.Context, id string, locationId string) (Invitation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Invitation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/primarySecondaryNetworks/wpa3ssid/invitations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Invitation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Retrieve all securityStates for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, your new info looks good.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetSecurityRealizedStates(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy/realizedState"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the service level for this location
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, return service Level object.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetServiceLevel(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/serviceLevel"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get DNS, HTTP, UPnP and mDNS sniffing toggles for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, current sniffing toggles returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetSniffing(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/sniffing"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService retrieve the speed test result for a node.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, run.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: locationId or nodeId isn&#39;t defined.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt; &lt;div&gt;&lt;strong&gt;503&lt;/strong&gt;: Service Unavailable.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param nodeId
 * @param optional nil or *CustomerApiCustomerPrototypeGetSpeedTestResultsOpts - Optional Parameters:
     * @param "Granularity" (optional.String) -  days/hours/minutes
     * @param "Limit" (optional.Float64) -  X # of days/hours/minutes

@return interface{}
*/

type CustomerApiCustomerPrototypeGetSpeedTestResultsOpts struct { 
	Granularity optional.String
	Limit optional.Float64
}

func (a *CustomerApiService) CustomerPrototypeGetSpeedTestResults(ctx context.Context, id string, locationId string, nodeId string, localVarOptionals *CustomerApiCustomerPrototypeGetSpeedTestResultsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodes/{nodeId}/speedTestResults"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Granularity.IsSet() {
		localVarQueryParams.Add("granularity", parameterToString(localVarOptionals.Granularity.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService retrieve single speed test result by request id for a node.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: locationId or nodeId isn&#39;t defined.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Speed test not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt; &lt;div&gt;&lt;strong&gt;503&lt;/strong&gt;: Service Unavailable.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param nodeId
 * @param requestId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetSpeedTestResultsByRequestId(ctx context.Context, id string, locationId string, nodeId string, requestId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodes/{nodeId}/speedTestResults/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", fmt.Sprintf("%v", nodeId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", fmt.Sprintf("%v", requestId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the current speed test aggregation result for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, current speedTest result and most active devices returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or NetworkMode does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeGetSpeedTestResultsForAppOpts - Optional Parameters:
     * @param "ExcludeDevices" (optional.Bool) - 

@return XAny
*/

type CustomerApiCustomerPrototypeGetSpeedTestResultsForAppOpts struct { 
	ExcludeDevices optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeGetSpeedTestResultsForApp(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeGetSpeedTestResultsForAppOpts) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/appFacade/dashboard"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ExcludeDevices.IsSet() {
		localVarQueryParams.Add("excludeDevices", parameterToString(localVarOptionals.ExcludeDevices.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the current WiFi SSID for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, current Wifi Network returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or WifiNetwork does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return InlineResponse2007
*/
func (a *CustomerApiService) CustomerPrototypeGetSsid(ctx context.Context, id string, locationId string) (InlineResponse2007, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2007
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork/ssid"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2007
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get Subscription details for this location
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, subscription details returned&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetSubscription(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/subscription"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService DEPRECATED: The system summary for a location including topology, optimizations, and firmware upgrades.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, system info plus topology array returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return SummaryResponse
*/
func (a *CustomerApiService) CustomerPrototypeGetSummary(ctx context.Context, id string, locationId string) (SummaryResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SummaryResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v SummaryResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Retrieve all task statuses of nodes from controller
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetTaskStatuses(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/taskStatuses"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetches hasOne relation termsAndPrivacyAccepted.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param optional nil or *CustomerApiCustomerPrototypeGetTermsAndPrivacyAcceptedOpts - Optional Parameters:
     * @param "Refresh" (optional.Bool) - 

@return TermsAndPrivacy
*/

type CustomerApiCustomerPrototypeGetTermsAndPrivacyAcceptedOpts struct { 
	Refresh optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeGetTermsAndPrivacyAccepted(ctx context.Context, id string, localVarOptionals *CustomerApiCustomerPrototypeGetTermsAndPrivacyAcceptedOpts) (TermsAndPrivacy, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue TermsAndPrivacy
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/termsAndPrivacyAccepted"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Refresh.IsSet() {
		localVarQueryParams.Add("refresh", parameterToString(localVarOptionals.Refresh.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v TermsAndPrivacy
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService DEPRECATED: The topology for a location including channels and devices.
Please use the GET /Customers/{id}/locations/{locationId}/forceGraph API as a replacement. &lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, array of Nodes returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id, location id, or topology does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return TopologyResponse
*/
func (a *CustomerApiService) CustomerPrototypeGetTopology(ctx context.Context, id string, locationId string) (TopologyResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue TopologyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/topology"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v TopologyResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Describes the current state of TOS for the given client.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Ok.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: No device found with provided mac address&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid MAC.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypeGetTos(ctx context.Context, id string, locationId string, mac string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/tos"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the current UPnP setting for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, current Upnp returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return Upnp
*/
func (a *CustomerApiService) CustomerPrototypeGetUpnp(ctx context.Context, id string, locationId string) (Upnp, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Upnp
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkConfiguration/upnp"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Upnp
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Retrieve all Vap State on a particular Node for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, your new info looks good.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetVapStates(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/vapStates"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Retrieve all Vap State on a particular Node for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, your new info looks good.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetVapsAndStaStatesFromBackhaul(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/backhauls"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get a list of pending approval requests for this location.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, CustomerId or requst id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetWhitelistApprovalRequests(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy/websites/whitelist/approvalRequests"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService WiFi Dashboard
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, response object returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return WifiDashboardResponse
*/
func (a *CustomerApiService) CustomerPrototypeGetWifiDashboard(ctx context.Context, id string, locationId string) (WifiDashboardResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue WifiDashboardResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/appFacade/wifiDashboard"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v WifiDashboardResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update home devices visible to guests.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, Invitation returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Customer id, location id, or WifiNetwork accessZone zoneId/keyId does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param zoneId
 * @param keyId keys id be added

@return Invitation
*/
func (a *CustomerApiService) CustomerPrototypeGetWifiInvitationById(ctx context.Context, id string, locationId string, zoneId string, keyId float64) (Invitation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Invitation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork/accessZones/{zoneId}/keys/{keyId}/invitations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", fmt.Sprintf("%v", zoneId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyId"+"}", fmt.Sprintf("%v", keyId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Invitation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get WifiMotion config for this location
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, wifiMotion object returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return WifiMotion
*/
func (a *CustomerApiService) CustomerPrototypeGetWifiMotion(ctx context.Context, id string, locationId string) (WifiMotion, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue WifiMotion
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiMotion"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v WifiMotion
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the current WiFi SSID and PSK for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, current Wifi Network returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or WifiNetwork does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return InlineResponse2002
*/
func (a *CustomerApiService) CustomerPrototypeGetWifiNetwork(ctx context.Context, id string, locationId string) (InlineResponse2002, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2002
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2002
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get the current DPP configurator for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, current DPP configurator returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetWifiNetworkDpp(ctx context.Context, id string, locationId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork/dpp"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService WiFi Networks
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, response object returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return []interface{}
*/
func (a *CustomerApiService) CustomerPrototypeGetWifiNetworks(ctx context.Context, id string, locationId string) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetworks"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Verify that a Customer Id has a Location Id.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, no data returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: LocationId not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return Location
*/
func (a *CustomerApiService) CustomerPrototypeHasLocationById(ctx context.Context, id string, locationId string) (Location, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Head")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Location
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Location
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Provides feedback as to whether an iOS deviceToken was previously registered for push notifications.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, exists:true|false returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param deviceToken

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeIosDeviceTokenExists(ctx context.Context, id string, deviceToken string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/iosDeviceTokens/{deviceToken}/exists"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceToken"+"}", fmt.Sprintf("%v", deviceToken), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService link the outside account, such as Samsung user.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, the outside account inserted into the customer info/object.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param provider
 * @param userId
 * @param sessionToken
 * @param optional nil or *CustomerApiCustomerPrototypeLinkAccountOpts - Optional Parameters:
     * @param "UserName" (optional.String) - 
     * @param "UserDisplayName" (optional.String) - 

@return interface{}
*/

type CustomerApiCustomerPrototypeLinkAccountOpts struct { 
	UserName optional.String
	UserDisplayName optional.String
}

func (a *CustomerApiService) CustomerPrototypeLinkAccount(ctx context.Context, id string, provider string, userId string, sessionToken string, localVarOptionals *CustomerApiCustomerPrototypeLinkAccountOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/linkedAccounts"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("provider", parameterToString(provider, ""))
	localVarFormParams.Add("userId", parameterToString(userId, ""))
	if localVarOptionals != nil && localVarOptionals.UserName.IsSet() {
		localVarFormParams.Add("userName", parameterToString(localVarOptionals.UserName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserDisplayName.IsSet() {
		localVarFormParams.Add("userDisplayName", parameterToString(localVarOptionals.UserDisplayName.Value(), ""))
	}
	localVarFormParams.Add("sessionToken", parameterToString(sessionToken, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get custom shared schedules for a given Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, custom schedules list returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return []LocationCustomSchedule
*/
func (a *CustomerApiService) CustomerPrototypeListCustomSharedSchedules(ctx context.Context, id string, locationId string) ([]LocationCustomSchedule, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []LocationCustomSchedule
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/schedules"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []LocationCustomSchedule
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get detailed information of a location for CRM campaigns.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, location data in response.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeMarketingExportOpts - Optional Parameters:
     * @param "WifiMotionCapable" (optional.Bool) - 
     * @param "WifiMotionEnable" (optional.Bool) - 
     * @param "OnlineProtectionEnabled" (optional.Bool) - 
     * @param "PersonsWithoutAssignedDevices" (optional.Bool) - 
     * @param "PeopleProfileEverCreated" (optional.Bool) - 
     * @param "BlockedSecurityEventsCountThirtyDay" (optional.Bool) - 
     * @param "DevicesOnlineThirtyDays" (optional.Bool) - 
     * @param "MostActiveDevicesThirtyDays" (optional.Bool) - 
     * @param "AppTimeCapable" (optional.Bool) - 
     * @param "Subscription" (optional.Bool) - 
     * @param "LastThirtyDaysSpeedTestAverages" (optional.Bool) - 

@return interface{}
*/

type CustomerApiCustomerPrototypeMarketingExportOpts struct { 
	WifiMotionCapable optional.Bool
	WifiMotionEnable optional.Bool
	OnlineProtectionEnabled optional.Bool
	PersonsWithoutAssignedDevices optional.Bool
	PeopleProfileEverCreated optional.Bool
	BlockedSecurityEventsCountThirtyDay optional.Bool
	DevicesOnlineThirtyDays optional.Bool
	MostActiveDevicesThirtyDays optional.Bool
	AppTimeCapable optional.Bool
	Subscription optional.Bool
	LastThirtyDaysSpeedTestAverages optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeMarketingExport(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeMarketingExportOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/marketingExport"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.WifiMotionCapable.IsSet() {
		localVarQueryParams.Add("wifiMotionCapable", parameterToString(localVarOptionals.WifiMotionCapable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WifiMotionEnable.IsSet() {
		localVarQueryParams.Add("wifiMotionEnable", parameterToString(localVarOptionals.WifiMotionEnable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnlineProtectionEnabled.IsSet() {
		localVarQueryParams.Add("onlineProtectionEnabled", parameterToString(localVarOptionals.OnlineProtectionEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PersonsWithoutAssignedDevices.IsSet() {
		localVarQueryParams.Add("personsWithoutAssignedDevices", parameterToString(localVarOptionals.PersonsWithoutAssignedDevices.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PeopleProfileEverCreated.IsSet() {
		localVarQueryParams.Add("peopleProfileEverCreated", parameterToString(localVarOptionals.PeopleProfileEverCreated.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BlockedSecurityEventsCountThirtyDay.IsSet() {
		localVarQueryParams.Add("blockedSecurityEventsCountThirtyDay", parameterToString(localVarOptionals.BlockedSecurityEventsCountThirtyDay.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesOnlineThirtyDays.IsSet() {
		localVarQueryParams.Add("devicesOnlineThirtyDays", parameterToString(localVarOptionals.DevicesOnlineThirtyDays.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MostActiveDevicesThirtyDays.IsSet() {
		localVarQueryParams.Add("mostActiveDevicesThirtyDays", parameterToString(localVarOptionals.MostActiveDevicesThirtyDays.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AppTimeCapable.IsSet() {
		localVarQueryParams.Add("appTimeCapable", parameterToString(localVarOptionals.AppTimeCapable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Subscription.IsSet() {
		localVarQueryParams.Add("subscription", parameterToString(localVarOptionals.Subscription.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastThirtyDaysSpeedTestAverages.IsSet() {
		localVarQueryParams.Add("lastThirtyDaysSpeedTestAverages", parameterToString(localVarOptionals.LastThirtyDaysSpeedTestAverages.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Returns cloud migration status for customer
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, return the search result.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Customer does not exist.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeMigrationStatus(ctx context.Context, id string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/migration"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Manually initiate an Optimize request for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, optimize request sent.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeOptimizeOpts - Optional Parameters:
     * @param "ForcePcs" (optional.Bool) - 

@return string
*/

type CustomerApiCustomerPrototypeOptimizeOpts struct { 
	ForcePcs optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeOptimize(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeOptimizeOpts) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/optimize"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ForcePcs.IsSet() {
		localVarFormParams.Add("forcePcs", parameterToString(localVarOptionals.ForcePcs.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Resets a appQoe config. AppQoe is to monitor the Quality of Experience of these Apps in the house, which is what this PRD covers. This QoE monitoring will allow CSPs understand likely issues with applications.
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success, reset.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId


*/
func (a *CustomerApiService) CustomerPrototypeOverlordDeleteAppQoeConfig(ctx context.Context, id string, locationId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/config/appQoe"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Resets a flowCache config. Enable/disable Flow Cache to help support devQA to check influence on the first stage of the investigation.
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success, reset.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId


*/
func (a *CustomerApiService) CustomerPrototypeOverlordDeleteFlowCacheConfig(ctx context.Context, id string, locationId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/config/flowCache"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Resets a samKnows config. SamKnows is a provider of internet performance measurement services. They offer the SamKnows Router Agent, which supports a range of QoS and QoE performance measurements. These measurements can be executed both on an ad-hoc and scheduled basis.
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success, reset.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId


*/
func (a *CustomerApiService) CustomerPrototypeOverlordDeleteSamKnowsConfig(ctx context.Context, id string, locationId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/config/samKnows"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Resets a sipAlg config. sipAlg is an application within many routers. It inspects any VoIP traffic to prevent problems caused by firewalls and if necessary modifies the VoIP packets.
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success, reset.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId


*/
func (a *CustomerApiService) CustomerPrototypeOverlordDeleteSipAlgConfig(ctx context.Context, id string, locationId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/config/sipAlg"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Resets a stats config. Location Stats configuration, used to toggle which stats should be collected.
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success, reset.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId


*/
func (a *CustomerApiService) CustomerPrototypeOverlordDeleteStatsConfig(ctx context.Context, id string, locationId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/config/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Updates a appQoe config. AppQoe is to monitor the Quality of Experience of these Apps in the house, which is what this PRD covers. This QoE monitoring will allow CSPs understand likely issues with applications.
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success, accepted and forwarded the data.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid data.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeOverlordUpdateAppQoeConfigOpts - Optional Parameters:
     * @param "Mode" (optional.String) -   string enum: [ AUTO, ENABLE, DISABLE ]


*/

type CustomerApiCustomerPrototypeOverlordUpdateAppQoeConfigOpts struct { 
	Mode optional.String
}

func (a *CustomerApiService) CustomerPrototypeOverlordUpdateAppQoeConfig(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeOverlordUpdateAppQoeConfigOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/config/appQoe"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Mode.IsSet() {
		localVarFormParams.Add("mode", parameterToString(localVarOptionals.Mode.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Updates a flowCache config. Enable/disable Flow Cache to help support devQA to check influence on the first stage of the investigation.
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success, accepted and forwarded the data.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid data.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeOverlordUpdateFlowCacheConfigOpts - Optional Parameters:
     * @param "Enable" (optional.Bool) -   boolean


*/

type CustomerApiCustomerPrototypeOverlordUpdateFlowCacheConfigOpts struct { 
	Enable optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeOverlordUpdateFlowCacheConfig(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeOverlordUpdateFlowCacheConfigOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/config/flowCache"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Enable.IsSet() {
		localVarFormParams.Add("enable", parameterToString(localVarOptionals.Enable.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Updates a samKnows config. SamKnows is a provider of internet performance measurement services. They offer the SamKnows Router Agent, which supports a range of QoS and QoE performance measurements. These measurements can be executed both on an ad-hoc and scheduled basis.
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success, accepted and forwarded the data.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid data.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeOverlordUpdateSamKnowsConfigOpts - Optional Parameters:
     * @param "Mode" (optional.String) -   string enum: [ AUTO, ENABLE, DISABLE ]


*/

type CustomerApiCustomerPrototypeOverlordUpdateSamKnowsConfigOpts struct { 
	Mode optional.String
}

func (a *CustomerApiService) CustomerPrototypeOverlordUpdateSamKnowsConfig(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeOverlordUpdateSamKnowsConfigOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/config/samKnows"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Mode.IsSet() {
		localVarFormParams.Add("mode", parameterToString(localVarOptionals.Mode.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Updates a sipAlg config. sipAlg is an application within many routers. It inspects any VoIP traffic to prevent problems caused by firewalls and if necessary modifies the VoIP packets.
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success, accepted and forwarded the data.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid data.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeOverlordUpdateSipAlgConfigOpts - Optional Parameters:
     * @param "Mode" (optional.String) -   string enum: [ AUTO, ENABLE, DISABLE ]


*/

type CustomerApiCustomerPrototypeOverlordUpdateSipAlgConfigOpts struct { 
	Mode optional.String
}

func (a *CustomerApiService) CustomerPrototypeOverlordUpdateSipAlgConfig(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeOverlordUpdateSipAlgConfigOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/config/sipAlg"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Mode.IsSet() {
		localVarFormParams.Add("mode", parameterToString(localVarOptionals.Mode.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Updates a stats config. Location Stats configuration, used to toggle which stats should be collected.
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success, accepted and forwarded the data.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid data.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeOverlordUpdateStatsConfigOpts - Optional Parameters:
     * @param "OffChannelScan24" (optional.String) -   string enum: [ AUTO, ENABLE, DISABLE ]
     * @param "OffChannelScan50" (optional.String) -   string enum: [ AUTO, ENABLE, DISABLE ]
     * @param "OffChannelScan60" (optional.String) -   string enum: [ AUTO, ENABLE, DISABLE ]
     * @param "ClientAuthFails" (optional.String) -   string enum: [ AUTO, ENABLE, DISABLE ]


*/

type CustomerApiCustomerPrototypeOverlordUpdateStatsConfigOpts struct { 
	OffChannelScan24 optional.String
	OffChannelScan50 optional.String
	OffChannelScan60 optional.String
	ClientAuthFails optional.String
}

func (a *CustomerApiService) CustomerPrototypeOverlordUpdateStatsConfig(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeOverlordUpdateStatsConfigOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/config/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.OffChannelScan24.IsSet() {
		localVarFormParams.Add("offChannelScan24", parameterToString(localVarOptionals.OffChannelScan24.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OffChannelScan50.IsSet() {
		localVarFormParams.Add("offChannelScan50", parameterToString(localVarOptionals.OffChannelScan50.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OffChannelScan60.IsSet() {
		localVarFormParams.Add("offChannelScan60", parameterToString(localVarOptionals.OffChannelScan60.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClientAuthFails.IsSet() {
		localVarFormParams.Add("clientAuthFails", parameterToString(localVarOptionals.ClientAuthFails.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Update an access zone
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, wifiNetwork returned&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Customer id, location id, or WifiNetwork does not exist&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Validation failed&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param zoneId id of access zone
 * @param optional nil or *CustomerApiCustomerPrototypePatchAccessZoneOpts - Optional Parameters:
     * @param "Description" (optional.String) - 
     * @param "AccessibleDevices" (optional.String) -  array of home macs[] visible to this access zone

@return WifiNetwork
*/

type CustomerApiCustomerPrototypePatchAccessZoneOpts struct { 
	Description optional.String
	AccessibleDevices optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchAccessZone(ctx context.Context, id string, locationId string, zoneId float64, localVarOptionals *CustomerApiCustomerPrototypePatchAccessZoneOpts) (WifiNetwork, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue WifiNetwork
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork/accessZones/{zoneId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", fmt.Sprintf("%v", zoneId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarFormParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccessibleDevices.IsSet() {
		localVarFormParams.Add("accessibleDevices", parameterToString(localVarOptionals.AccessibleDevices.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v WifiNetwork
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update app prioritization config.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePatchAppPrioritizationLocationConfigOpts - Optional Parameters:
     * @param "Enabled" (optional.Bool) -  true if app prioritization is enabled
     * @param "Mode" (optional.String) -  App Prioritization mode - any of auto | enable | disable
     * @param "IsFirstTimeUserExperience" (optional.Bool) -  true if it is first time user experience
     * @param "Template" (optional.String) -  Template for app prioritization
     * @param "CustomSettingEnabled" (optional.Bool) -  true if custom setting is enabled
     * @param "CustomSetting" (optional.String) -  Settings for app prioritization

@return XAny
*/

type CustomerApiCustomerPrototypePatchAppPrioritizationLocationConfigOpts struct { 
	Enabled optional.Bool
	Mode optional.String
	IsFirstTimeUserExperience optional.Bool
	Template optional.String
	CustomSettingEnabled optional.Bool
	CustomSetting optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchAppPrioritizationLocationConfig(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePatchAppPrioritizationLocationConfigOpts) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/qos/appPrioritization"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarFormParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Mode.IsSet() {
		localVarFormParams.Add("mode", parameterToString(localVarOptionals.Mode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsFirstTimeUserExperience.IsSet() {
		localVarFormParams.Add("isFirstTimeUserExperience", parameterToString(localVarOptionals.IsFirstTimeUserExperience.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Template.IsSet() {
		localVarFormParams.Add("template", parameterToString(localVarOptionals.Template.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CustomSettingEnabled.IsSet() {
		localVarFormParams.Add("customSettingEnabled", parameterToString(localVarOptionals.CustomSettingEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CustomSetting.IsSet() {
		localVarFormParams.Add("customSetting", parameterToString(localVarOptionals.CustomSetting.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Patch IP flows config
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or device does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param enable
 * @param optional nil or *CustomerApiCustomerPrototypePatchAppTimeIpFlowOpts - Optional Parameters:
     * @param "ExpiresAt" (optional.String) - 

@return interface{}
*/

type CustomerApiCustomerPrototypePatchAppTimeIpFlowOpts struct { 
	ExpiresAt optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchAppTimeIpFlow(ctx context.Context, id string, locationId string, enable bool, localVarOptionals *CustomerApiCustomerPrototypePatchAppTimeIpFlowOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/appTime/ipFlows"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("enable", parameterToString(enable, ""))
	if localVarOptionals != nil && localVarOptionals.ExpiresAt.IsSet() {
		localVarFormParams.Add("expiresAt", parameterToString(localVarOptionals.ExpiresAt.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Patch attributes for a model instance and persist it into the data source.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param optional nil or *CustomerApiCustomerPrototypePatchAttributesPatchCustomersidOpts - Optional Parameters:
     * @param "Data" (optional.Interface of Customer) -  An object of model property name/value pairs

@return Customer
*/

type CustomerApiCustomerPrototypePatchAttributesPatchCustomersidOpts struct { 
	Data optional.Interface
}

func (a *CustomerApiService) CustomerPrototypePatchAttributesPatchCustomersid(ctx context.Context, id string, localVarOptionals *CustomerApiCustomerPrototypePatchAttributesPatchCustomersidOpts) (Customer, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Customer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		
		localVarOptionalData, localVarOptionalDataok := localVarOptionals.Data.Value().(Customer)
		if !localVarOptionalDataok {
				return localVarReturnValue, nil, reportError("data should be Customer")
		}
		localVarPostBody = &localVarOptionalData
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Customer
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Patch attributes for a model instance and persist it into the data source.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param optional nil or *CustomerApiCustomerPrototypePatchAttributesPutCustomersidOpts - Optional Parameters:
     * @param "Data" (optional.Interface of Customer) -  An object of model property name/value pairs

@return Customer
*/

type CustomerApiCustomerPrototypePatchAttributesPutCustomersidOpts struct { 
	Data optional.Interface
}

func (a *CustomerApiService) CustomerPrototypePatchAttributesPutCustomersid(ctx context.Context, id string, localVarOptionals *CustomerApiCustomerPrototypePatchAttributesPutCustomersidOpts) (Customer, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Customer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		
		localVarOptionalData, localVarOptionalDataok := localVarOptionals.Data.Value().(Customer)
		if !localVarOptionalDataok {
				return localVarReturnValue, nil, reportError("data should be Customer")
		}
		localVarPostBody = &localVarOptionalData
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Customer
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Patch the Captive Portal campaign branding properties for a given Location ID/NetworkId.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, campaign branding patched.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or CaptivePortal Network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param optional nil or *CustomerApiCustomerPrototypePatchCampaignCaptivePortalBrandingOpts - Optional Parameters:
     * @param "Payload" (optional.String) - 

@return NetworkConfig
*/

type CustomerApiCustomerPrototypePatchCampaignCaptivePortalBrandingOpts struct { 
	Payload optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchCampaignCaptivePortalBranding(ctx context.Context, id string, locationId string, networkId string, localVarOptionals *CustomerApiCustomerPrototypePatchCampaignCaptivePortalBrandingOpts) (NetworkConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NetworkConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/{networkId}/campaign/branding"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Payload.IsSet() {
		localVarFormParams.Add("payload", parameterToString(localVarOptionals.Payload.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NetworkConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Patch the Captive Portal campaign for a given Location ID/NetworkId.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, campaign patched.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or CaptivePortal Network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param optional nil or *CustomerApiCustomerPrototypePatchCampaignCaptivePortalNetworkOpts - Optional Parameters:
     * @param "CampaignPayload" (optional.String) - 

@return NetworkConfig
*/

type CustomerApiCustomerPrototypePatchCampaignCaptivePortalNetworkOpts struct { 
	CampaignPayload optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchCampaignCaptivePortalNetwork(ctx context.Context, id string, locationId string, networkId string, localVarOptionals *CustomerApiCustomerPrototypePatchCampaignCaptivePortalNetworkOpts) (NetworkConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NetworkConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/{networkId}/campaign"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.CampaignPayload.IsSet() {
		localVarFormParams.Add("campaignPayload", parameterToString(localVarOptionals.CampaignPayload.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NetworkConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a Captive Portal for a given Location ID/NetworkId.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or NetworkId does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: NetworkId/SSIDs must be the unique and valid values.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param optional nil or *CustomerApiCustomerPrototypePatchCaptivePortalOpts - Optional Parameters:
     * @param "Ssid" (optional.String) - 
     * @param "Enable" (optional.Bool) - 
     * @param "EncryptionKey" (optional.String) - 
     * @param "BandwidthLimit" (optional.String) -  attributes: \&quot;enabled\&quot; boolean, \&quot;type\&quot;: \&quot;absolute\&quot;|\&quot;percentage\&quot;, \&quot;upload\&quot;/\&quot;download\&quot; - either as percentage or absolute (Mbps)
     * @param "WpaMode" (optional.String) - 
     * @param "SessionTimeLimitSec" (optional.Float64) - 

@return NetworkConfig
*/

type CustomerApiCustomerPrototypePatchCaptivePortalOpts struct { 
	Ssid optional.String
	Enable optional.Bool
	EncryptionKey optional.String
	BandwidthLimit optional.String
	WpaMode optional.String
	SessionTimeLimitSec optional.Float64
}

func (a *CustomerApiService) CustomerPrototypePatchCaptivePortal(ctx context.Context, id string, locationId string, networkId string, localVarOptionals *CustomerApiCustomerPrototypePatchCaptivePortalOpts) (NetworkConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NetworkConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/{networkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Ssid.IsSet() {
		localVarFormParams.Add("ssid", parameterToString(localVarOptionals.Ssid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enable.IsSet() {
		localVarFormParams.Add("enable", parameterToString(localVarOptionals.Enable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EncryptionKey.IsSet() {
		localVarFormParams.Add("encryptionKey", parameterToString(localVarOptionals.EncryptionKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BandwidthLimit.IsSet() {
		localVarFormParams.Add("bandwidthLimit", parameterToString(localVarOptionals.BandwidthLimit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WpaMode.IsSet() {
		localVarFormParams.Add("wpaMode", parameterToString(localVarOptionals.WpaMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SessionTimeLimitSec.IsSet() {
		localVarFormParams.Add("sessionTimeLimitSec", parameterToString(localVarOptionals.SessionTimeLimitSec.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NetworkConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Post CaptivePortal authorized clients
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id/NetworkId does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param mac
 * @param expireAt

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypePatchCaptivePortalAuthorizedClients(ctx context.Context, id string, locationId string, networkId string, mac string, expireAt string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/{networkId}/authorizedClients/{mac}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("expireAt", parameterToString(expireAt, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Returns cloud migration status for customer
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, no content.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Missing providerId or providerUserId body parameter&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;409&lt;/strong&gt;: Accounts are already linked for providerUserId&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Unfinished document for providerId does not exist&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param providerId enum to identify provider ex. commandAlexa
 * @param providerUserId id of the user in provider&#39;s system


*/
func (a *CustomerApiService) CustomerPrototypePatchCommand(ctx context.Context, id string, locationId string, providerId string, providerUserId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/command"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("providerId", parameterToString(providerId, ""))
	localVarFormParams.Add("providerUserId", parameterToString(providerUserId, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Update a Customer&#39;s device type configuration (user feedback).
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, device type has been updated&lt;br/&gt;but not validated as a device that &lt;br/&gt;has ever connected.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: nickname value must be defined.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id and/or mac does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: nickname value must be less than 33 characters.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param optional nil or *CustomerApiCustomerPrototypePatchCustomDeviceTypeOpts - Optional Parameters:
     * @param "Category" (optional.String) - 
     * @param "Brand" (optional.String) - 
     * @param "Model" (optional.String) - 
     * @param "OsName" (optional.String) - 

@return CustomDeviceType
*/

type CustomerApiCustomerPrototypePatchCustomDeviceTypeOpts struct { 
	Category optional.String
	Brand optional.String
	Model optional.String
	OsName optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchCustomDeviceType(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypePatchCustomDeviceTypeOpts) (CustomDeviceType, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CustomDeviceType
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/customType"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Category.IsSet() {
		localVarFormParams.Add("category", parameterToString(localVarOptionals.Category.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Brand.IsSet() {
		localVarFormParams.Add("brand", parameterToString(localVarOptionals.Brand.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Model.IsSet() {
		localVarFormParams.Add("model", parameterToString(localVarOptionals.Model.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OsName.IsSet() {
		localVarFormParams.Add("osName", parameterToString(localVarOptionals.OsName.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v CustomDeviceType
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Patch a custom shared schedule freeze template for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, your new info looks good.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: templateId must be defined.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: schedules value is invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;425&lt;/strong&gt;: templateId must belong to the location.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param templateId
 * @param schedules
 * @param optional nil or *CustomerApiCustomerPrototypePatchCustomSharedScheduleOpts - Optional Parameters:
     * @param "Name" (optional.String) - 
     * @param "Type_" (optional.String) - 

@return LocationCustomSchedule
*/

type CustomerApiCustomerPrototypePatchCustomSharedScheduleOpts struct { 
	Name optional.String
	Type_ optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchCustomSharedSchedule(ctx context.Context, id string, locationId string, templateId string, schedules string, localVarOptionals *CustomerApiCustomerPrototypePatchCustomSharedScheduleOpts) (LocationCustomSchedule, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue LocationCustomSchedule
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/schedules/{templateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", fmt.Sprintf("%v", templateId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("schedules", parameterToString(schedules, ""))
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v LocationCustomSchedule
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Patches a single Device to mark it favorite for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, everything looks good.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist. Or, device not found in this network &#39;s history.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac mac of device
 * @param optional nil or *CustomerApiCustomerPrototypePatchDeviceOpts - Optional Parameters:
     * @param "Favorite" (optional.Bool) - 
     * @param "Nickname" (optional.String) - 
     * @param "MobileAppDeviceUuid" (optional.String) - 

@return DeviceResponse
*/

type CustomerApiCustomerPrototypePatchDeviceOpts struct { 
	Favorite optional.Bool
	Nickname optional.String
	MobileAppDeviceUuid optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchDevice(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypePatchDeviceOpts) (DeviceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DeviceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Favorite.IsSet() {
		localVarFormParams.Add("favorite", parameterToString(localVarOptionals.Favorite.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Nickname.IsSet() {
		localVarFormParams.Add("nickname", parameterToString(localVarOptionals.Nickname.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MobileAppDeviceUuid.IsSet() {
		localVarFormParams.Add("mobileAppDeviceUuid", parameterToString(localVarOptionals.MobileAppDeviceUuid.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v DeviceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a Device&#39;s AppTime config by location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or device does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param optional nil or *CustomerApiCustomerPrototypePatchDeviceAppTimeOpts - Optional Parameters:
     * @param "Enable" (optional.Bool) - 

@return interface{}
*/

type CustomerApiCustomerPrototypePatchDeviceAppTimeOpts struct { 
	Enable optional.Bool
}

func (a *CustomerApiService) CustomerPrototypePatchDeviceAppTime(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypePatchDeviceAppTimeOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/appTime"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Enable.IsSet() {
		localVarFormParams.Add("enable", parameterToString(localVarOptionals.Enable.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Toggle auto:on/off client steering for a device.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid mac address.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac device mac address
 * @param optional nil or *CustomerApiCustomerPrototypePatchDeviceClientSteeringOpts - Optional Parameters:
     * @param "Auto" (optional.Bool) - 
     * @param "SteeringClass" (optional.String) -  override deviceTypeId for testing purposes

@return ClientSteeringConfiguration
*/

type CustomerApiCustomerPrototypePatchDeviceClientSteeringOpts struct { 
	Auto optional.Bool
	SteeringClass optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchDeviceClientSteering(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypePatchDeviceClientSteeringOpts) (ClientSteeringConfiguration, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ClientSteeringConfiguration
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/clientSteering"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Auto.IsSet() {
		localVarFormParams.Add("auto", parameterToString(localVarOptionals.Auto.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SteeringClass.IsSet() {
		localVarFormParams.Add("steeringClass", parameterToString(localVarOptionals.SteeringClass.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ClientSteeringConfiguration
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Change a device group name or device members.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Schema validation failed.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;403&lt;/strong&gt;: Not allowed to modify standalone groups or groups in unsupported networks.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Unauthorized.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Invalid JSON or missing arguments.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param groupId
 * @param optional nil or *CustomerApiCustomerPrototypePatchDeviceGroupOpts - Optional Parameters:
     * @param "Name" (optional.String) - 
     * @param "Devices" (optional.String) - 

@return NetworkAccessDeviceGroup
*/

type CustomerApiCustomerPrototypePatchDeviceGroupOpts struct { 
	Name optional.String
	Devices optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchDeviceGroup(ctx context.Context, id string, locationId string, networkId string, groupId string, localVarOptionals *CustomerApiCustomerPrototypePatchDeviceGroupOpts) (NetworkAccessDeviceGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NetworkAccessDeviceGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkAccess/networks/{networkId}/deviceGroups/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", fmt.Sprintf("%v", groupId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Devices.IsSet() {
		localVarFormParams.Add("devices", parameterToString(localVarOptionals.Devices.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NetworkAccessDeviceGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update the Device UUID Mapping for Out of Home Protection.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or Device does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param optional nil or *CustomerApiCustomerPrototypePatchDeviceOHPConfigurationOpts - Optional Parameters:
     * @param "OHPNotificationsFlags" (optional.String) -  OHP feature flags
     * @param "DisableMobilizeSdk" (optional.Bool) -  enable or disable OHP SDK on the device

@return interface{}
*/

type CustomerApiCustomerPrototypePatchDeviceOHPConfigurationOpts struct { 
	OHPNotificationsFlags optional.String
	DisableMobilizeSdk optional.Bool
}

func (a *CustomerApiService) CustomerPrototypePatchDeviceOHPConfiguration(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypePatchDeviceOHPConfigurationOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/securityPolicy/ohp"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.OHPNotificationsFlags.IsSet() {
		localVarFormParams.Add("OHPNotificationsFlags", parameterToString(localVarOptionals.OHPNotificationsFlags.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DisableMobilizeSdk.IsSet() {
		localVarFormParams.Add("disableMobilizeSdk", parameterToString(localVarOptionals.DisableMobilizeSdk.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 204 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update QoS of a single device
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Prioritization is not a valid value.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param prioritization

@return []XAny
*/
func (a *CustomerApiService) CustomerPrototypePatchDeviceQos(ctx context.Context, id string, locationId string, mac string, prioritization string) ([]XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/qos"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("prioritization", parameterToString(prioritization, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 202 {
			var v []XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a Device&#39;s Security Policy for a location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, or Person id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;409&lt;/strong&gt;: Device is assigned to a person so its security policy must be configured on the Person&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Mac addresses must be valid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param optional nil or *CustomerApiCustomerPrototypePatchDeviceSecurityPolicyOpts - Optional Parameters:
     * @param "SecureAndProtect" (optional.Bool) - 
     * @param "IotProtect" (optional.Bool) - 
     * @param "IotProtectReason" (optional.String) - 
     * @param "Content" (optional.String) -  Valid values: &#39;kids || teenagers || adBlocking || adultAndSensitive || workAppropriate&#39;

@return Person
*/

type CustomerApiCustomerPrototypePatchDeviceSecurityPolicyOpts struct { 
	SecureAndProtect optional.Bool
	IotProtect optional.Bool
	IotProtectReason optional.String
	Content optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchDeviceSecurityPolicy(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypePatchDeviceSecurityPolicyOpts) (Person, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Person
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/securityPolicy"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.SecureAndProtect.IsSet() {
		localVarFormParams.Add("secureAndProtect", parameterToString(localVarOptionals.SecureAndProtect.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IotProtect.IsSet() {
		localVarFormParams.Add("iotProtect", parameterToString(localVarOptionals.IotProtect.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IotProtectReason.IsSet() {
		localVarFormParams.Add("iotProtectReason", parameterToString(localVarOptionals.IotProtectReason.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Content.IsSet() {
		localVarFormParams.Add("content", parameterToString(localVarOptionals.Content.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Person
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Patch the sounding states for the given devices
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, device sounding states returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param soundingStates

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypePatchDeviceSoundingState(ctx context.Context, id string, locationId string, soundingStates interface{}) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/homeSecurity/devices/sounding"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &soundingStates
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Patch the DPP configuration mode for a Location ID.
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success, DPP updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: DPP value is invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mode auto || enable || disable


*/
func (a *CustomerApiService) CustomerPrototypePatchDpp(ctx context.Context, id string, locationId string, mode string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/dpp"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("mode", parameterToString(mode, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Update the ethernetLan setting for a Location ID.
Supported modes are: * enable/disable/auto  &lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, new ethernetLan settings saved.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Input validation error, see output for details.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param ethernetLan ethernetLan object

@return EthernetLan
*/
func (a *CustomerApiService) CustomerPrototypePatchEthernetLan(ctx context.Context, id string, locationId string, ethernetLan EthernetLan) (EthernetLan, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue EthernetLan
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkConfiguration/ethernetLan"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &ethernetLan
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v EthernetLan
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Patches the flow stats configuration
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success, your new info looks good.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Input value is invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePatchFlowStatsOpts - Optional Parameters:
     * @param "IotDeviceConfig" (optional.String) -  auto || enable || disable
     * @param "ScreenDeviceConfig" (optional.String) -  auto || enable || disable
     * @param "LanIotDeviceConfig" (optional.String) -  auto || enable || disable
     * @param "InterfaceStatsConfig" (optional.String) -  auto || enable || disable


*/

type CustomerApiCustomerPrototypePatchFlowStatsOpts struct { 
	IotDeviceConfig optional.String
	ScreenDeviceConfig optional.String
	LanIotDeviceConfig optional.String
	InterfaceStatsConfig optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchFlowStats(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePatchFlowStatsOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/flowStats"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IotDeviceConfig.IsSet() {
		localVarFormParams.Add("iotDeviceConfig", parameterToString(localVarOptionals.IotDeviceConfig.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScreenDeviceConfig.IsSet() {
		localVarFormParams.Add("screenDeviceConfig", parameterToString(localVarOptionals.ScreenDeviceConfig.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LanIotDeviceConfig.IsSet() {
		localVarFormParams.Add("lanIotDeviceConfig", parameterToString(localVarOptionals.LanIotDeviceConfig.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceStatsConfig.IsSet() {
		localVarFormParams.Add("interfaceStatsConfig", parameterToString(localVarOptionals.InterfaceStatsConfig.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Update a Front Haul for a given Location ID/NetworkId.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or NetworkId does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: NetworkId/SSIDs must be the unique and valid values.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param optional nil or *CustomerApiCustomerPrototypePatchFrontHaulOpts - Optional Parameters:
     * @param "Ssid" (optional.String) - 
     * @param "Enable" (optional.Bool) - 
     * @param "EncryptionKey" (optional.String) - 
     * @param "AccessZone" (optional.String) - 
     * @param "WpaMode" (optional.String) - 
     * @param "SsidBroadcast" (optional.Bool) - 

@return NetworkConfig
*/

type CustomerApiCustomerPrototypePatchFrontHaulOpts struct { 
	Ssid optional.String
	Enable optional.Bool
	EncryptionKey optional.String
	AccessZone optional.String
	WpaMode optional.String
	SsidBroadcast optional.Bool
}

func (a *CustomerApiService) CustomerPrototypePatchFrontHaul(ctx context.Context, id string, locationId string, networkId string, localVarOptionals *CustomerApiCustomerPrototypePatchFrontHaulOpts) (NetworkConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NetworkConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/fronthauls/{networkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Ssid.IsSet() {
		localVarFormParams.Add("ssid", parameterToString(localVarOptionals.Ssid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enable.IsSet() {
		localVarFormParams.Add("enable", parameterToString(localVarOptionals.Enable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EncryptionKey.IsSet() {
		localVarFormParams.Add("encryptionKey", parameterToString(localVarOptionals.EncryptionKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccessZone.IsSet() {
		localVarFormParams.Add("accessZone", parameterToString(localVarOptionals.AccessZone.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WpaMode.IsSet() {
		localVarFormParams.Add("wpaMode", parameterToString(localVarOptionals.WpaMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SsidBroadcast.IsSet() {
		localVarFormParams.Add("ssidBroadcast", parameterToString(localVarOptionals.SsidBroadcast.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NetworkConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a Location&#39;s Default Device Group Security Policy by location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePatchGroupOfUnassignedDevicesSecurityPolicyOpts - Optional Parameters:
     * @param "SecureAndProtect" (optional.Bool) - 
     * @param "IotProtect" (optional.Bool) - 
     * @param "Content" (optional.String) -  Valid values: &#39;kids || teenagers || adBlocking || adultAndSensitive || workAppropriate&#39;

@return interface{}
*/

type CustomerApiCustomerPrototypePatchGroupOfUnassignedDevicesSecurityPolicyOpts struct { 
	SecureAndProtect optional.Bool
	IotProtect optional.Bool
	Content optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchGroupOfUnassignedDevicesSecurityPolicy(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePatchGroupOfUnassignedDevicesSecurityPolicyOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/groupOfUnassignedDevices/securityPolicy"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.SecureAndProtect.IsSet() {
		localVarFormParams.Add("secureAndProtect", parameterToString(localVarOptionals.SecureAndProtect.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IotProtect.IsSet() {
		localVarFormParams.Add("iotProtect", parameterToString(localVarOptionals.IotProtect.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Content.IsSet() {
		localVarFormParams.Add("content", parameterToString(localVarOptionals.Content.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 202 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Enable/disable homeAway wifiMotionEvents activation for this location
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated HomeSecurity object returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param homeAwayActive Enable/disable motion events based on location Homeaway state

@return HomeSecurity
*/
func (a *CustomerApiService) CustomerPrototypePatchHomeAwayActive(ctx context.Context, id string, locationId string, homeAwayActive bool) (HomeSecurity, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue HomeSecurity
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/homeSecurity/homeAway"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("homeAwayActive", parameterToString(homeAwayActive, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v HomeSecurity
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Enable/disable live motion streaming and/or motion events for this location
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated HomeSecurity object returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePatchHomeSecurityOpts - Optional Parameters:
     * @param "Source" (optional.String) -  Source of patch request; must be one of \&quot;user\&quot; or \&quot;geofence\&quot;
     * @param "LiveMotionEnabled" (optional.Bool) - 
     * @param "MotionEventsEnabled" (optional.Bool) - 
     * @param "HomeAwayActive" (optional.Bool) -  Enable/disable motion events based on location Homeaway state

@return HomeSecurity
*/

type CustomerApiCustomerPrototypePatchHomeSecurityOpts struct { 
	Source optional.String
	LiveMotionEnabled optional.Bool
	MotionEventsEnabled optional.Bool
	HomeAwayActive optional.Bool
}

func (a *CustomerApiService) CustomerPrototypePatchHomeSecurity(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePatchHomeSecurityOpts) (HomeSecurity, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue HomeSecurity
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/homeSecurity"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Source.IsSet() {
		localVarFormParams.Add("source", parameterToString(localVarOptionals.Source.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LiveMotionEnabled.IsSet() {
		localVarFormParams.Add("liveMotionEnabled", parameterToString(localVarOptionals.LiveMotionEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MotionEventsEnabled.IsSet() {
		localVarFormParams.Add("motionEventsEnabled", parameterToString(localVarOptionals.MotionEventsEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HomeAwayActive.IsSet() {
		localVarFormParams.Add("homeAwayActive", parameterToString(localVarOptionals.HomeAwayActive.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v HomeSecurity
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Configure motion event configuration for this location
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated HomeSecurity object returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePatchHomeSecuritySensitivityOpts - Optional Parameters:
     * @param "Cooldown" (optional.Float64) -  sets required rest period for motion detected events to end, in seconds
     * @param "PetMode" (optional.String) -  adjusts sensitivity of motion detected events for pets; must be one of \&quot;none\&quot;, \&quot;under10\&quot;, \&quot;10to30\&quot;, \&quot;over30\&quot; and can only be set if sensitivity &#x3D; high
     * @param "Sensitivity" (optional.String) -  adjusts sensitivity of motion detected events; must be one of \&quot;low\&quot;, \&quot;medium\&quot;, \&quot;high\&quot;

@return HomeSecurity
*/

type CustomerApiCustomerPrototypePatchHomeSecuritySensitivityOpts struct { 
	Cooldown optional.Float64
	PetMode optional.String
	Sensitivity optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchHomeSecuritySensitivity(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePatchHomeSecuritySensitivityOpts) (HomeSecurity, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue HomeSecurity
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/homeSecurity/sensitivity"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Cooldown.IsSet() {
		localVarFormParams.Add("cooldown", parameterToString(localVarOptionals.Cooldown.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PetMode.IsSet() {
		localVarFormParams.Add("petMode", parameterToString(localVarOptionals.PetMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sensitivity.IsSet() {
		localVarFormParams.Add("sensitivity", parameterToString(localVarOptionals.Sensitivity.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v HomeSecurity
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePatchIPv6Opts - Optional Parameters:
     * @param "Mode" (optional.String) - 
     * @param "Dns" (optional.String) - 
     * @param "AddressingConfig" (optional.String) - 

@return interface{}
*/

type CustomerApiCustomerPrototypePatchIPv6Opts struct { 
	Mode optional.String
	Dns optional.String
	AddressingConfig optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchIPv6(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePatchIPv6Opts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/ipv6"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Mode.IsSet() {
		localVarFormParams.Add("mode", parameterToString(localVarOptionals.Mode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Dns.IsSet() {
		localVarFormParams.Add("dns", parameterToString(localVarOptionals.Dns.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddressingConfig.IsSet() {
		localVarFormParams.Add("addressingConfig", parameterToString(localVarOptionals.AddressingConfig.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Retrieve all kvConfigs on a particular Node for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, your new info looks good.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: nodeId must be defined.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;425&lt;/strong&gt;: nodeId must belong to the location.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param nodeId
 * @param kvConfigs

@return []KvConfig
*/
func (a *CustomerApiService) CustomerPrototypePatchKvConfigs(ctx context.Context, id string, locationId string, nodeId string, kvConfigs string) ([]KvConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []KvConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodes/{nodeId}/kvConfigs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("kvConfigs", parameterToString(kvConfigs, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []KvConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a Location&#39;s serviceId.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: You must specify at least one parameter to patch.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Only integration role can set profile to property.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePatchLocationOpts - Optional Parameters:
     * @param "ServiceId" (optional.String) - 
     * @param "Profile" (optional.String) - 

@return Location
*/

type CustomerApiCustomerPrototypePatchLocationOpts struct { 
	ServiceId optional.String
	Profile optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchLocation(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePatchLocationOpts) (Location, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Location
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ServiceId.IsSet() {
		localVarFormParams.Add("serviceId", parameterToString(localVarOptionals.ServiceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Profile.IsSet() {
		localVarFormParams.Add("profile", parameterToString(localVarOptionals.Profile.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Location
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a Location&#39;s AppTime config by location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePatchLocationAppTimeOpts - Optional Parameters:
     * @param "Enable" (optional.Bool) - 
     * @param "AppliesToAllDevices" (optional.Bool) - 
     * @param "SandboxSizeMb" (optional.String) - 

@return interface{}
*/

type CustomerApiCustomerPrototypePatchLocationAppTimeOpts struct { 
	Enable optional.Bool
	AppliesToAllDevices optional.Bool
	SandboxSizeMb optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchLocationAppTime(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePatchLocationAppTimeOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/appTime"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Enable.IsSet() {
		localVarFormParams.Add("enable", parameterToString(localVarOptionals.Enable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AppliesToAllDevices.IsSet() {
		localVarFormParams.Add("appliesToAllDevices", parameterToString(localVarOptionals.AppliesToAllDevices.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SandboxSizeMb.IsSet() {
		localVarFormParams.Add("sandboxSizeMb", parameterToString(localVarOptionals.SandboxSizeMb.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Set mode for band steering
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid mode.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePatchLocationBandSteeringOpts - Optional Parameters:
     * @param "Mode" (optional.String) -  auto || enable || disable

@return LocationBandSteering
*/

type CustomerApiCustomerPrototypePatchLocationBandSteeringOpts struct { 
	Mode optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchLocationBandSteering(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePatchLocationBandSteeringOpts) (LocationBandSteering, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue LocationBandSteering
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/bandSteering"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Mode.IsSet() {
		localVarFormParams.Add("mode", parameterToString(localVarOptionals.Mode.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v LocationBandSteering
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Put all devices except some to be frozen for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePatchLocationFreezeAutoExpireOpts - Optional Parameters:
     * @param "IncludedDeviceMacs" (optional.String) - 
     * @param "IncludedPersonIds" (optional.String) - 
     * @param "ExpiresAt" (optional.String) - 


*/

type CustomerApiCustomerPrototypePatchLocationFreezeAutoExpireOpts struct { 
	IncludedDeviceMacs optional.String
	IncludedPersonIds optional.String
	ExpiresAt optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchLocationFreezeAutoExpire(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePatchLocationFreezeAutoExpireOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/freeze/autoExpire"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IncludedDeviceMacs.IsSet() {
		localVarFormParams.Add("includedDeviceMacs", parameterToString(localVarOptionals.IncludedDeviceMacs.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludedPersonIds.IsSet() {
		localVarFormParams.Add("includedPersonIds", parameterToString(localVarOptionals.IncludedPersonIds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExpiresAt.IsSet() {
		localVarFormParams.Add("expiresAt", parameterToString(localVarOptionals.ExpiresAt.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Update type of access of manager on location.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param managerId
 * @param optional nil or *CustomerApiCustomerPrototypePatchLocationManagerOpts - Optional Parameters:
     * @param "AccessType" (optional.String) - 
     * @param "Name" (optional.String) - 
     * @param "NotificationOptions" (optional.String) - 

@return Location
*/

type CustomerApiCustomerPrototypePatchLocationManagerOpts struct { 
	AccessType optional.String
	Name optional.String
	NotificationOptions optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchLocationManager(ctx context.Context, id string, locationId string, managerId string, localVarOptionals *CustomerApiCustomerPrototypePatchLocationManagerOpts) (Location, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Location
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/managers/{managerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managerId"+"}", fmt.Sprintf("%v", managerId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.AccessType.IsSet() {
		localVarFormParams.Add("accessType", parameterToString(localVarOptionals.AccessType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotificationOptions.IsSet() {
		localVarFormParams.Add("notificationOptions", parameterToString(localVarOptionals.NotificationOptions.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Location
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update the location qoe liveMode by api call and Kafka message
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, the new info looks good.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: enalbe and expiresAt, reportingInterval validation error.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: expiresAt and reportingInterval validation error.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param enable
 * @param optional nil or *CustomerApiCustomerPrototypePatchLocationQoeLiveModeOpts - Optional Parameters:
     * @param "ExpiresAt" (optional.String) - 
     * @param "ReportingInterval" (optional.Float64) - 

@return interface{}
*/

type CustomerApiCustomerPrototypePatchLocationQoeLiveModeOpts struct { 
	ExpiresAt optional.String
	ReportingInterval optional.Float64
}

func (a *CustomerApiService) CustomerPrototypePatchLocationQoeLiveMode(ctx context.Context, id string, locationId string, enable bool, localVarOptionals *CustomerApiCustomerPrototypePatchLocationQoeLiveModeOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/qoe/liveMode"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("enable", parameterToString(enable, ""))
	if localVarOptionals != nil && localVarOptionals.ExpiresAt.IsSet() {
		localVarFormParams.Add("expiresAt", parameterToString(localVarOptionals.ExpiresAt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReportingInterval.IsSet() {
		localVarFormParams.Add("reportingInterval", parameterToString(localVarOptionals.ReportingInterval.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a Location&#39;s Security Policy by location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePatchLocationSecurityPolicyOpts - Optional Parameters:
     * @param "SecureAndProtect" (optional.Bool) - 
     * @param "IotProtect" (optional.Bool) - 
     * @param "Content" (optional.String) -  Valid values: &#39;kids || teenagers || adBlocking || adultAndSensitive || workAppropriate&#39;
     * @param "AppliesToAllDevices" (optional.String) -  hash map of security policy IDs that should be applied to all devices

@return interface{}
*/

type CustomerApiCustomerPrototypePatchLocationSecurityPolicyOpts struct { 
	SecureAndProtect optional.Bool
	IotProtect optional.Bool
	Content optional.String
	AppliesToAllDevices optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchLocationSecurityPolicy(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePatchLocationSecurityPolicyOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.SecureAndProtect.IsSet() {
		localVarFormParams.Add("secureAndProtect", parameterToString(localVarOptionals.SecureAndProtect.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IotProtect.IsSet() {
		localVarFormParams.Add("iotProtect", parameterToString(localVarOptionals.IotProtect.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Content.IsSet() {
		localVarFormParams.Add("content", parameterToString(localVarOptionals.Content.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AppliesToAllDevices.IsSet() {
		localVarFormParams.Add("appliesToAllDevices", parameterToString(localVarOptionals.AppliesToAllDevices.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update the multicast settings for a Location ID.
Supported modes for individual settings are: * igmpSnooping: enable/disable/auto * igmpProxy: igmpv1/igmpv2/igmpv3/disable/auto * mldProxy: mldv1/mldv2/disable/disable/auto * multicastToUnicast: enable/disable/auto  &lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, new multicast settings saved.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Input validation error, see output for details.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param multicast multicast object

@return Multicast
*/
func (a *CustomerApiService) CustomerPrototypePatchMulticast(ctx context.Context, id string, locationId string, multicast Multicast) (Multicast, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Multicast
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkConfiguration/multicast"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &multicast
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Multicast
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Enable or disable purgatory in the network
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Network does not exist.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param purgatory

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypePatchNetworkAccessNetwork(ctx context.Context, id string, locationId string, networkId string, purgatory bool) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkAccess/networks/{networkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("purgatory", parameterToString(purgatory, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Enable/disable optimizations for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid dfsMode, prefer160MhzMode, zeroWaitDfsMode, hopPenalty or preCACScheduler provided.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePatchOptimizationsOpts - Optional Parameters:
     * @param "Auto" (optional.String) -  defaults to true
     * @param "DfsMode" (optional.String) -  enum of values include: auto, enable, disable, demo, HomeNonDFSChannels, usDfs, deviceAware
     * @param "Prefer160MhzMode" (optional.String) -  enum of values include: auto, enable, disable
     * @param "ZeroWaitDfsMode" (optional.String) -  enum of values include: auto, enable, disable
     * @param "HopPenalty" (optional.String) -  enum of values include: auto, low, medium, high
     * @param "PreCACScheduler" (optional.String) -  enum of values include: auto, enable, disable

@return Optimizations
*/

type CustomerApiCustomerPrototypePatchOptimizationsOpts struct { 
	Auto optional.String
	DfsMode optional.String
	Prefer160MhzMode optional.String
	ZeroWaitDfsMode optional.String
	HopPenalty optional.String
	PreCACScheduler optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchOptimizations(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePatchOptimizationsOpts) (Optimizations, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Optimizations
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/optimizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Auto.IsSet() {
		localVarFormParams.Add("auto", parameterToString(localVarOptionals.Auto.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DfsMode.IsSet() {
		localVarFormParams.Add("dfsMode", parameterToString(localVarOptionals.DfsMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Prefer160MhzMode.IsSet() {
		localVarFormParams.Add("prefer160MhzMode", parameterToString(localVarOptionals.Prefer160MhzMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ZeroWaitDfsMode.IsSet() {
		localVarFormParams.Add("zeroWaitDfsMode", parameterToString(localVarOptionals.ZeroWaitDfsMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HopPenalty.IsSet() {
		localVarFormParams.Add("hopPenalty", parameterToString(localVarOptionals.HopPenalty.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PreCACScheduler.IsSet() {
		localVarFormParams.Add("preCACScheduler", parameterToString(localVarOptionals.PreCACScheduler.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Optimizations
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a Person for a location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or Person id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;409&lt;/strong&gt;: primaryDevice is not included in the list of assignedDevices[]&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Mac addresses must be valid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId
 * @param optional nil or *CustomerApiCustomerPrototypePatchPersonOpts - Optional Parameters:
     * @param "Nickname" (optional.String) - 
     * @param "ImageId" (optional.String) -  unique identifier for referencing a Person&#39;s hosted profile image
     * @param "PrimaryDevice" (optional.String) -  mac addresses of Person&#39;s primary device
     * @param "AssignedDevices" (optional.String) -  mac addresses assigned to this Person
     * @param "HomeAwayNotification" (optional.Bool) -  track person homeAway state
     * @param "Permission" (optional.String) -  permission object for creating or deleting the manager
     * @param "Email" (optional.String) -  email for sending the manager invite
     * @param "ServiceLinking" (optional.String) -  serviceLinking object that links this Person object to a 3rd party&#39;s Person

@return Person
*/

type CustomerApiCustomerPrototypePatchPersonOpts struct { 
	Nickname optional.String
	ImageId optional.String
	PrimaryDevice optional.String
	AssignedDevices optional.String
	HomeAwayNotification optional.Bool
	Permission optional.String
	Email optional.String
	ServiceLinking optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchPerson(ctx context.Context, id string, locationId string, personId string, localVarOptionals *CustomerApiCustomerPrototypePatchPersonOpts) (Person, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Person
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Nickname.IsSet() {
		localVarFormParams.Add("nickname", parameterToString(localVarOptionals.Nickname.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ImageId.IsSet() {
		localVarFormParams.Add("imageId", parameterToString(localVarOptionals.ImageId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PrimaryDevice.IsSet() {
		localVarFormParams.Add("primaryDevice", parameterToString(localVarOptionals.PrimaryDevice.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssignedDevices.IsSet() {
		localVarFormParams.Add("assignedDevices", parameterToString(localVarOptionals.AssignedDevices.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HomeAwayNotification.IsSet() {
		localVarFormParams.Add("homeAwayNotification", parameterToString(localVarOptionals.HomeAwayNotification.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Permission.IsSet() {
		localVarFormParams.Add("permission", parameterToString(localVarOptionals.Permission.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Email.IsSet() {
		localVarFormParams.Add("email", parameterToString(localVarOptionals.Email.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceLinking.IsSet() {
		localVarFormParams.Add("serviceLinking", parameterToString(localVarOptionals.ServiceLinking.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Person
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a Person&#39;s AppTime config by location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or person does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId
 * @param optional nil or *CustomerApiCustomerPrototypePatchPersonAppTimeOpts - Optional Parameters:
     * @param "Enable" (optional.Bool) - 

@return interface{}
*/

type CustomerApiCustomerPrototypePatchPersonAppTimeOpts struct { 
	Enable optional.Bool
}

func (a *CustomerApiService) CustomerPrototypePatchPersonAppTime(ctx context.Context, id string, locationId string, personId string, localVarOptionals *CustomerApiCustomerPrototypePatchPersonAppTimeOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/appTime"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Enable.IsSet() {
		localVarFormParams.Add("enable", parameterToString(localVarOptionals.Enable.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a Person&#39;s Profile for a location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, or Person id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId
 * @param optional nil or *CustomerApiCustomerPrototypePatchPersonProfileOpts - Optional Parameters:
     * @param "Type_" (optional.String) -  Valid values: &#39;employee&#39;

@return interface{}
*/

type CustomerApiCustomerPrototypePatchPersonProfileOpts struct { 
	Type_ optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchPersonProfile(ctx context.Context, id string, locationId string, personId string, localVarOptionals *CustomerApiCustomerPrototypePatchPersonProfileOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/profile"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a Person&#39;s Security Policy for a location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, or Person id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId
 * @param optional nil or *CustomerApiCustomerPrototypePatchPersonSecurityPolicyOpts - Optional Parameters:
     * @param "SecureAndProtect" (optional.Bool) - 
     * @param "IotProtect" (optional.Bool) - 
     * @param "Content" (optional.String) -  Valid values: &#39;kids || teenagers || adBlocking || adultAndSensitive || workAppropriate&#39;

@return interface{}
*/

type CustomerApiCustomerPrototypePatchPersonSecurityPolicyOpts struct { 
	SecureAndProtect optional.Bool
	IotProtect optional.Bool
	Content optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchPersonSecurityPolicy(ctx context.Context, id string, locationId string, personId string, localVarOptionals *CustomerApiCustomerPrototypePatchPersonSecurityPolicyOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/securityPolicy"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.SecureAndProtect.IsSet() {
		localVarFormParams.Add("secureAndProtect", parameterToString(localVarOptionals.SecureAndProtect.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IotProtect.IsSet() {
		localVarFormParams.Add("iotProtect", parameterToString(localVarOptionals.IotProtect.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Content.IsSet() {
		localVarFormParams.Add("content", parameterToString(localVarOptionals.Content.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Patch a Remote Connections Config for the given Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mode Any of \&quot;auto\&quot;, \&quot;enabled\&quot;, \&quot;disabled\&quot;, \&quot;highRiskOnly\&quot;

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypePatchRemoteConnectionsConfig(ctx context.Context, id string, locationId string, mode string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy/remoteConnections"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("mode", parameterToString(mode, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Patch a Room for a Location ID/Room ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Devices and Nodes must be defined and mac addresses must be valid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param roomId
 * @param optional nil or *CustomerApiCustomerPrototypePatchRoomOpts - Optional Parameters:
     * @param "Name" (optional.String) -  name of this Room
     * @param "Devices" (optional.String) -  mac addresses of devices assigned to this Room
     * @param "Nodes" (optional.String) -  nodeIds assigned to this Room

@return Room
*/

type CustomerApiCustomerPrototypePatchRoomOpts struct { 
	Name optional.String
	Devices optional.String
	Nodes optional.String
}

func (a *CustomerApiService) CustomerPrototypePatchRoom(ctx context.Context, id string, locationId string, roomId string, localVarOptionals *CustomerApiCustomerPrototypePatchRoomOpts) (Room, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Room
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/rooms/{roomId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roomId"+"}", fmt.Sprintf("%v", roomId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Devices.IsSet() {
		localVarFormParams.Add("devices", parameterToString(localVarOptionals.Devices.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Nodes.IsSet() {
		localVarFormParams.Add("nodes", parameterToString(localVarOptionals.Nodes.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Room
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Patch Security Configurations for location (preferredIntelligence, etc)
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid securityConfig.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param securityConfig

@return SecurityConfiguration
*/
func (a *CustomerApiService) CustomerPrototypePatchSecurityConfiguration(ctx context.Context, id string, locationId string, securityConfig string) (SecurityConfiguration, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SecurityConfiguration
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityConfiguration"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("securityConfig", parameterToString(securityConfig, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v SecurityConfiguration
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Set the service level for this location
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated service Level object returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid &#39;status&#39; value.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param status

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypePatchServiceLevel(ctx context.Context, id string, locationId string, status string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/serviceLevel"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("status", parameterToString(status, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Patch Subscription details for this location
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success, status patched&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Status is invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param status enum of values include: Active, Suspended


*/
func (a *CustomerApiService) CustomerPrototypePatchSubscription(ctx context.Context, id string, locationId string, status string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/subscription"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("status", parameterToString(status, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Enable/disable WifiMotion feature for this location
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated object returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param auto

@return WifiMotion
*/
func (a *CustomerApiService) CustomerPrototypePatchWifiMotion(ctx context.Context, id string, locationId string, auto bool) (WifiMotion, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue WifiMotion
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiMotion"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("auto", parameterToString(auto, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v WifiMotion
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update the SSID of the WifiNetwork
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, access zone returned&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Customer id, location id, or WifiNetwork does not exist&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Validation failed&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePatchWifiNetworkOpts - Optional Parameters:
     * @param "Ssid" (optional.String) - 
     * @param "Uapsd" (optional.Bool) - 
     * @param "GroupRekey" (optional.String) -  auto || enable || disable
     * @param "FastTransition" (optional.String) -  auto || enable || disable
     * @param "MinWifiMode24" (optional.String) -  auto || 11b || 11g || 11n
     * @param "PrivateMode" (optional.Bool) -  Stop collecting user info like DNS-Queries, UserAgent etc
     * @param "Enabled" (optional.Bool) -  enabled:true for active WiFi radios, enabled:false to turn &#x60;off&#x60; all WiFi radios

@return WifiNetwork
*/

type CustomerApiCustomerPrototypePatchWifiNetworkOpts struct { 
	Ssid optional.String
	Uapsd optional.Bool
	GroupRekey optional.String
	FastTransition optional.String
	MinWifiMode24 optional.String
	PrivateMode optional.Bool
	Enabled optional.Bool
}

func (a *CustomerApiService) CustomerPrototypePatchWifiNetwork(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePatchWifiNetworkOpts) (WifiNetwork, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue WifiNetwork
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Ssid.IsSet() {
		localVarFormParams.Add("ssid", parameterToString(localVarOptionals.Ssid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uapsd.IsSet() {
		localVarFormParams.Add("uapsd", parameterToString(localVarOptionals.Uapsd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GroupRekey.IsSet() {
		localVarFormParams.Add("groupRekey", parameterToString(localVarOptionals.GroupRekey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FastTransition.IsSet() {
		localVarFormParams.Add("fastTransition", parameterToString(localVarOptionals.FastTransition.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MinWifiMode24.IsSet() {
		localVarFormParams.Add("minWifiMode24", parameterToString(localVarOptionals.MinWifiMode24.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PrivateMode.IsSet() {
		localVarFormParams.Add("privateMode", parameterToString(localVarOptionals.PrivateMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarFormParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v WifiNetwork
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService POST Captive Portal campaign preview for a given Location ID/NetworkId.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, campaign posted.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or CaptivePortal Network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param optional nil or *CustomerApiCustomerPrototypePostCampaignPreviewCaptivePortalNetworkOpts - Optional Parameters:
     * @param "CampaignPayload" (optional.String) - 

@return NetworkConfig
*/

type CustomerApiCustomerPrototypePostCampaignPreviewCaptivePortalNetworkOpts struct { 
	CampaignPayload optional.String
}

func (a *CustomerApiService) CustomerPrototypePostCampaignPreviewCaptivePortalNetwork(ctx context.Context, id string, locationId string, networkId string, localVarOptionals *CustomerApiCustomerPrototypePostCampaignPreviewCaptivePortalNetworkOpts) (NetworkConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NetworkConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/{networkId}/campaign/preview"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.CampaignPayload.IsSet() {
		localVarFormParams.Add("campaignPayload", parameterToString(localVarOptionals.CampaignPayload.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NetworkConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create a Captive Portal Network for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or NetworkId does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: NetworkId/SSIDs must be the unique and valid values.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param ssid
 * @param optional nil or *CustomerApiCustomerPrototypePostCaptivePortalOpts - Optional Parameters:
     * @param "NetworkId" (optional.String) - 
     * @param "Enable" (optional.Bool) - 
     * @param "EncryptionKey" (optional.String) - 
     * @param "BandwidthLimit" (optional.String) -  attributes: \&quot;enabled\&quot; boolean, \&quot;type\&quot;: \&quot;absolute\&quot;|\&quot;percentage\&quot;, \&quot;upload\&quot;/\&quot;download\&quot; - either as percentage or absolute (Mbps)
     * @param "SessionTimeLimitSec" (optional.Float64) - 
     * @param "WpaMode" (optional.String) - 
     * @param "Language" (optional.String) - 

@return NetworkConfig
*/

type CustomerApiCustomerPrototypePostCaptivePortalOpts struct { 
	NetworkId optional.String
	Enable optional.Bool
	EncryptionKey optional.String
	BandwidthLimit optional.String
	SessionTimeLimitSec optional.Float64
	WpaMode optional.String
	Language optional.String
}

func (a *CustomerApiService) CustomerPrototypePostCaptivePortal(ctx context.Context, id string, locationId string, ssid string, localVarOptionals *CustomerApiCustomerPrototypePostCaptivePortalOpts) (NetworkConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NetworkConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.NetworkId.IsSet() {
		localVarFormParams.Add("networkId", parameterToString(localVarOptionals.NetworkId.Value(), ""))
	}
	localVarFormParams.Add("ssid", parameterToString(ssid, ""))
	if localVarOptionals != nil && localVarOptionals.Enable.IsSet() {
		localVarFormParams.Add("enable", parameterToString(localVarOptionals.Enable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EncryptionKey.IsSet() {
		localVarFormParams.Add("encryptionKey", parameterToString(localVarOptionals.EncryptionKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BandwidthLimit.IsSet() {
		localVarFormParams.Add("bandwidthLimit", parameterToString(localVarOptionals.BandwidthLimit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SessionTimeLimitSec.IsSet() {
		localVarFormParams.Add("sessionTimeLimitSec", parameterToString(localVarOptionals.SessionTimeLimitSec.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WpaMode.IsSet() {
		localVarFormParams.Add("wpaMode", parameterToString(localVarOptionals.WpaMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Language.IsSet() {
		localVarFormParams.Add("language", parameterToString(localVarOptionals.Language.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NetworkConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Post CaptivePortal authorized clients
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id/NetworkId does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param mac
 * @param expireAt

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypePostCaptivePortalAuthorizedClients(ctx context.Context, id string, locationId string, networkId string, mac string, expireAt string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/{networkId}/authorizedClients"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("mac", parameterToString(mac, ""))
	localVarFormParams.Add("expireAt", parameterToString(expireAt, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Upload campaign asset for given location.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, appId info returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or url does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return NetworkConfig
*/
func (a *CustomerApiService) CustomerPrototypePostCaptivePortalCampaignAsset(ctx context.Context, id string, locationId string) (NetworkConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NetworkConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/uploadCampaignAsset"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NetworkConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Patch the Captive Portal Network to be compliant for guest email collection.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, CaptivePortal Networks has been patched.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or secondary networks does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypePostCaptivePortalEnableGuestEmailCollection(ctx context.Context, id string, locationId string, networkId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/{networkId}/enableGuestEmailCollection"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Fetch the Captive Portal Network Usage stats for the given network.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, CaptivePortal Networks returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or secondary networks does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param optional nil or *CustomerApiCustomerPrototypePostCaptivePortalNetworkUsageStatsOpts - Optional Parameters:
     * @param "Inclusions" (optional.String) -  Fields to include in response

@return []interface{}
*/

type CustomerApiCustomerPrototypePostCaptivePortalNetworkUsageStatsOpts struct { 
	Inclusions optional.String
}

func (a *CustomerApiService) CustomerPrototypePostCaptivePortalNetworkUsageStats(ctx context.Context, id string, locationId string, networkId string, localVarOptionals *CustomerApiCustomerPrototypePostCaptivePortalNetworkUsageStatsOpts) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/{networkId}/networkUsage"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Inclusions.IsSet() {
		localVarFormParams.Add("inclusions", parameterToString(localVarOptionals.Inclusions.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create \&quot;custom shared\&quot; schedules that shared by all persons and devices in a location.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, custom shared schedules applied.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id does not exist or is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: schedules value is invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param name
 * @param type_
 * @param schedules

@return LocationCustomSchedule
*/
func (a *CustomerApiService) CustomerPrototypePostCustomSharedSchedule(ctx context.Context, id string, locationId string, name string, type_ string, schedules string) (LocationCustomSchedule, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue LocationCustomSchedule
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/schedules"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	localVarFormParams.Add("type", parameterToString(type_, ""))
	localVarFormParams.Add("schedules", parameterToString(schedules, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v LocationCustomSchedule
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Post a shared schedule uuid freeze for a device for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: FreezeTemplateId not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Device not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: GroupOfUnassignedDevices has active freeze schedule&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Person has active freeze schedule&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param freezeTemplateId Valid templates are uuids

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypePostDeviceFreeze(ctx context.Context, id string, locationId string, mac string, freezeTemplateId string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/freeze/{freezeTemplateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"freezeTemplateId"+"}", fmt.Sprintf("%v", freezeTemplateId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create a named device group within a network and optionally specify member devices.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Schema validation failed.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;403&lt;/strong&gt;: Not allowed to create groups in unsupported networks.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Unauthorized.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Invalid JSON or missing arguments.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param name
 * @param optional nil or *CustomerApiCustomerPrototypePostDeviceGroupOpts - Optional Parameters:
     * @param "Devices" (optional.String) - 

@return NetworkAccessDeviceGroup
*/

type CustomerApiCustomerPrototypePostDeviceGroupOpts struct { 
	Devices optional.String
}

func (a *CustomerApiService) CustomerPrototypePostDeviceGroup(ctx context.Context, id string, locationId string, networkId string, name string, localVarOptionals *CustomerApiCustomerPrototypePostDeviceGroupOpts) (NetworkAccessDeviceGroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NetworkAccessDeviceGroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkAccess/networks/{networkId}/deviceGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	if localVarOptionals != nil && localVarOptionals.Devices.IsSet() {
		localVarFormParams.Add("devices", parameterToString(localVarOptionals.Devices.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NetworkAccessDeviceGroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Set QoS of a single device
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Prioritization is not a valid value.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param prioritization

@return []XAny
*/
func (a *CustomerApiService) CustomerPrototypePostDeviceQos(ctx context.Context, id string, locationId string, mac string, prioritization string) ([]XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/qos"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("prioritization", parameterToString(prioritization, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 202 {
			var v []XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Initiate an Anomaly Experience (demo) for a Device on a location.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param fqdn

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypePostDeviceSecurityPolicyAnomalyExperience(ctx context.Context, id string, locationId string, mac string, fqdn string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/securityPolicy/anomaly/experience"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("fqdn", parameterToString(fqdn, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Approve a previously blacklisted anomalous dns for a Device on a location.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: DNS value is invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param fqdn
 * @param optional nil or *CustomerApiCustomerPrototypePostDeviceSecurityPolicyAnomalyWhitelistOpts - Optional Parameters:
     * @param "Reason" (optional.String) - 
     * @param "Ttl" (optional.Float64) - 

@return interface{}
*/

type CustomerApiCustomerPrototypePostDeviceSecurityPolicyAnomalyWhitelistOpts struct { 
	Reason optional.String
	Ttl optional.Float64
}

func (a *CustomerApiService) CustomerPrototypePostDeviceSecurityPolicyAnomalyWhitelist(ctx context.Context, id string, locationId string, mac string, fqdn string, localVarOptionals *CustomerApiCustomerPrototypePostDeviceSecurityPolicyAnomalyWhitelistOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/securityPolicy/anomaly/websites/whitelist"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("fqdn", parameterToString(fqdn, ""))
	if localVarOptionals != nil && localVarOptionals.Reason.IsSet() {
		localVarFormParams.Add("reason", parameterToString(localVarOptionals.Reason.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ttl.IsSet() {
		localVarFormParams.Add("ttl", parameterToString(localVarOptionals.Ttl.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a Device&#39;s Security Policy for a location ID to include a blacklisted DNS entry.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, or Device does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: DNS value is invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param optional nil or *CustomerApiCustomerPrototypePostDeviceSecurityPolicyWebsitesBlacklistOpts - Optional Parameters:
     * @param "Dns" (optional.String) - 
     * @param "Type_" (optional.String) - 
     * @param "Value" (optional.String) - 
     * @param "Direction" (optional.String) - 
     * @param "GeoLocation" (optional.String) - 
     * @param "EndTimestamp" (optional.Float64) -  the end time stamp,  UTC unix epoch timestamp in ms
     * @param "AkamaiCategoryId" (optional.Float64) -  the akamai category id, number

@return interface{}
*/

type CustomerApiCustomerPrototypePostDeviceSecurityPolicyWebsitesBlacklistOpts struct { 
	Dns optional.String
	Type_ optional.String
	Value optional.String
	Direction optional.String
	GeoLocation optional.String
	EndTimestamp optional.Float64
	AkamaiCategoryId optional.Float64
}

func (a *CustomerApiService) CustomerPrototypePostDeviceSecurityPolicyWebsitesBlacklist(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypePostDeviceSecurityPolicyWebsitesBlacklistOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/securityPolicy/websites/blacklist"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Dns.IsSet() {
		localVarFormParams.Add("dns", parameterToString(localVarOptionals.Dns.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Value.IsSet() {
		localVarFormParams.Add("value", parameterToString(localVarOptionals.Value.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Direction.IsSet() {
		localVarFormParams.Add("direction", parameterToString(localVarOptionals.Direction.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GeoLocation.IsSet() {
		localVarFormParams.Add("geoLocation", parameterToString(localVarOptionals.GeoLocation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndTimestamp.IsSet() {
		localVarFormParams.Add("endTimestamp", parameterToString(localVarOptionals.EndTimestamp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AkamaiCategoryId.IsSet() {
		localVarFormParams.Add("akamaiCategoryId", parameterToString(localVarOptionals.AkamaiCategoryId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a Device&#39;s Security Policy for a location ID to include a whitelisted DNS entry.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, or Device does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: DNS value is invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param optional nil or *CustomerApiCustomerPrototypePostDeviceSecurityPolicyWebsitesWhitelistOpts - Optional Parameters:
     * @param "Dns" (optional.String) - 
     * @param "Type_" (optional.String) - 
     * @param "Value" (optional.String) - 
     * @param "Direction" (optional.String) - 
     * @param "GeoLocation" (optional.String) - 
     * @param "EventType" (optional.String) -  EventType field from event response - can be &#39;kids&#39;, &#39;teenagers&#39;, &#39;secureAndProtect, etc&#39;
     * @param "Source" (optional.String) -  Source field from events response - can be &#39;brightcloud&#39;, &#39;webpulse&#39;, &#39;gatekeeper&#39;, &#39;gatekeeper-ohp&#39;
     * @param "EndTimestamp" (optional.Float64) -  the end time stamp,  UTC unix epoch timestamp in ms
     * @param "AkamaiCategoryId" (optional.Float64) -  the akamai category id, number

@return interface{}
*/

type CustomerApiCustomerPrototypePostDeviceSecurityPolicyWebsitesWhitelistOpts struct { 
	Dns optional.String
	Type_ optional.String
	Value optional.String
	Direction optional.String
	GeoLocation optional.String
	EventType optional.String
	Source optional.String
	EndTimestamp optional.Float64
	AkamaiCategoryId optional.Float64
}

func (a *CustomerApiService) CustomerPrototypePostDeviceSecurityPolicyWebsitesWhitelist(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypePostDeviceSecurityPolicyWebsitesWhitelistOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/securityPolicy/websites/whitelist"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Dns.IsSet() {
		localVarFormParams.Add("dns", parameterToString(localVarOptionals.Dns.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Value.IsSet() {
		localVarFormParams.Add("value", parameterToString(localVarOptionals.Value.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Direction.IsSet() {
		localVarFormParams.Add("direction", parameterToString(localVarOptionals.Direction.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GeoLocation.IsSet() {
		localVarFormParams.Add("geoLocation", parameterToString(localVarOptionals.GeoLocation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventType.IsSet() {
		localVarFormParams.Add("eventType", parameterToString(localVarOptionals.EventType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Source.IsSet() {
		localVarFormParams.Add("source", parameterToString(localVarOptionals.Source.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndTimestamp.IsSet() {
		localVarFormParams.Add("endTimestamp", parameterToString(localVarOptionals.EndTimestamp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AkamaiCategoryId.IsSet() {
		localVarFormParams.Add("akamaiCategoryId", parameterToString(localVarOptionals.AkamaiCategoryId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Add a device mac to a WiFi Access Zone
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, all access zones returned&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Customer id, location id, or WifiNetwork does not exist&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Validation failed&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param zoneId id of access zone
 * @param mac the device mac to be added to the access zone

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypePostDeviceToAccessZone(ctx context.Context, id string, locationId string, zoneId float64, mac string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork/accessZones/{zoneId}/accessibleDevices/{mac}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", fmt.Sprintf("%v", zoneId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create a Front Haul Network for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or NetworkId does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: NetworkId/SSIDs must be the unique and valid values.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param ssid
 * @param encryptionKey
 * @param optional nil or *CustomerApiCustomerPrototypePostFrontHaulOpts - Optional Parameters:
     * @param "NetworkId" (optional.String) - 
     * @param "Enable" (optional.Bool) - 
     * @param "AccessZone" (optional.String) - 
     * @param "WpaMode" (optional.String) - 
     * @param "SsidBroadcast" (optional.Bool) - 

@return NetworkConfig
*/

type CustomerApiCustomerPrototypePostFrontHaulOpts struct { 
	NetworkId optional.String
	Enable optional.Bool
	AccessZone optional.String
	WpaMode optional.String
	SsidBroadcast optional.Bool
}

func (a *CustomerApiService) CustomerPrototypePostFrontHaul(ctx context.Context, id string, locationId string, ssid string, encryptionKey string, localVarOptionals *CustomerApiCustomerPrototypePostFrontHaulOpts) (NetworkConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NetworkConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/fronthauls"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.NetworkId.IsSet() {
		localVarFormParams.Add("networkId", parameterToString(localVarOptionals.NetworkId.Value(), ""))
	}
	localVarFormParams.Add("ssid", parameterToString(ssid, ""))
	if localVarOptionals != nil && localVarOptionals.Enable.IsSet() {
		localVarFormParams.Add("enable", parameterToString(localVarOptionals.Enable.Value(), ""))
	}
	localVarFormParams.Add("encryptionKey", parameterToString(encryptionKey, ""))
	if localVarOptionals != nil && localVarOptionals.AccessZone.IsSet() {
		localVarFormParams.Add("accessZone", parameterToString(localVarOptionals.AccessZone.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WpaMode.IsSet() {
		localVarFormParams.Add("wpaMode", parameterToString(localVarOptionals.WpaMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SsidBroadcast.IsSet() {
		localVarFormParams.Add("ssidBroadcast", parameterToString(localVarOptionals.SsidBroadcast.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NetworkConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create the DPP setting for a Fronthaul Network.
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success, new DPP configurator generated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or Fronthaul Network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid keys.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param optional nil or *CustomerApiCustomerPrototypePostFrontHaulsDppOpts - Optional Parameters:
     * @param "Enabled" (optional.Bool) -  should we configure dpp for this network - defaults to true
     * @param "Curve" (optional.String) -  one of predefined elliptic curves, - optional,  if missing in request default to prime256v1
     * @param "PrivateKey" (optional.String) -  privateKey, must also provide public part if present, optional
     * @param "PublicKey" (optional.String) -  publicKey

@return interface{}
*/

type CustomerApiCustomerPrototypePostFrontHaulsDppOpts struct { 
	Enabled optional.Bool
	Curve optional.String
	PrivateKey optional.String
	PublicKey optional.String
}

func (a *CustomerApiService) CustomerPrototypePostFrontHaulsDpp(ctx context.Context, id string, locationId string, networkId string, localVarOptionals *CustomerApiCustomerPrototypePostFrontHaulsDppOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/fronthauls/{networkId}/dpp"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarFormParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Curve.IsSet() {
		localVarFormParams.Add("curve", parameterToString(localVarOptionals.Curve.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PrivateKey.IsSet() {
		localVarFormParams.Add("privateKey", parameterToString(localVarOptionals.PrivateKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PublicKey.IsSet() {
		localVarFormParams.Add("publicKey", parameterToString(localVarOptionals.PublicKey.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 202 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create a bootstrap for DPP setting for a Fronthaul Network.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, new DPP configurator generated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or Fronthaul Network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid curve.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param optional nil or *CustomerApiCustomerPrototypePostFrontHaulsDppBootstrapOpts - Optional Parameters:
     * @param "Curve" (optional.String) -  one of predefined elliptic curves, - optional,  if missing in requset default to prime256v1

@return interface{}
*/

type CustomerApiCustomerPrototypePostFrontHaulsDppBootstrapOpts struct { 
	Curve optional.String
}

func (a *CustomerApiService) CustomerPrototypePostFrontHaulsDppBootstrap(ctx context.Context, id string, locationId string, networkId string, localVarOptionals *CustomerApiCustomerPrototypePostFrontHaulsDppBootstrapOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/fronthauls/{networkId}/dpp/bootstrapUris"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Curve.IsSet() {
		localVarFormParams.Add("curve", parameterToString(localVarOptionals.Curve.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create an enrollment for DPP setting for a fronthaul secondary network.
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success, new DPP configurator generated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or wifi network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Configurator keys for network not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param bootstrapUri

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypePostFrontHaulsDppEnrollment(ctx context.Context, id string, locationId string, networkId string, bootstrapUri string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/fronthauls/{networkId}/dpp/enrollments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("bootstrapUri", parameterToString(bootstrapUri, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 202 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService POST GroupOfUnassignedDevices to be frozen for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Freeze Template Id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;409&lt;/strong&gt;: Freeze Template Id already applied.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param freezeTemplateId Valid templates are uuids

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypePostGroupOfUnassignedDevicesFreezeTemplateId(ctx context.Context, id string, locationId string, freezeTemplateId string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/groupOfUnassignedDevices/freeze/{freezeTemplateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"freezeTemplateId"+"}", fmt.Sprintf("%v", freezeTemplateId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a Location&#39;s Default Device Group Security Policy for a location ID to include a blacklisted DNS entry.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, or Device does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: DNS value is invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePostGroupOfUnassignedDevicesSecurityPolicyWebsitesBlacklistOpts - Optional Parameters:
     * @param "Dns" (optional.String) - 
     * @param "Type_" (optional.String) - 
     * @param "Value" (optional.String) - 
     * @param "Direction" (optional.String) - 
     * @param "GeoLocation" (optional.String) - 
     * @param "EndTimestamp" (optional.Float64) -  the end time stamp,  UTC unix epoch timestamp in ms
     * @param "AkamaiCategoryId" (optional.Float64) -  the akamai category id, number

@return interface{}
*/

type CustomerApiCustomerPrototypePostGroupOfUnassignedDevicesSecurityPolicyWebsitesBlacklistOpts struct { 
	Dns optional.String
	Type_ optional.String
	Value optional.String
	Direction optional.String
	GeoLocation optional.String
	EndTimestamp optional.Float64
	AkamaiCategoryId optional.Float64
}

func (a *CustomerApiService) CustomerPrototypePostGroupOfUnassignedDevicesSecurityPolicyWebsitesBlacklist(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePostGroupOfUnassignedDevicesSecurityPolicyWebsitesBlacklistOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/groupOfUnassignedDevices/securityPolicy/websites/blacklist"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Dns.IsSet() {
		localVarFormParams.Add("dns", parameterToString(localVarOptionals.Dns.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Value.IsSet() {
		localVarFormParams.Add("value", parameterToString(localVarOptionals.Value.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Direction.IsSet() {
		localVarFormParams.Add("direction", parameterToString(localVarOptionals.Direction.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GeoLocation.IsSet() {
		localVarFormParams.Add("geoLocation", parameterToString(localVarOptionals.GeoLocation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndTimestamp.IsSet() {
		localVarFormParams.Add("endTimestamp", parameterToString(localVarOptionals.EndTimestamp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AkamaiCategoryId.IsSet() {
		localVarFormParams.Add("akamaiCategoryId", parameterToString(localVarOptionals.AkamaiCategoryId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 202 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a Location&#39;s Default Device Group Security Policy for a location ID to include a whitelisted DNS entry.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, or Device does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: DNS value is invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePostGroupOfUnassignedDevicesSecurityPolicyWebsitesWhitelistOpts - Optional Parameters:
     * @param "Dns" (optional.String) - 
     * @param "Type_" (optional.String) - 
     * @param "Value" (optional.String) - 
     * @param "Direction" (optional.String) - 
     * @param "GeoLocation" (optional.String) - 
     * @param "EndTimestamp" (optional.Float64) -  the end time stamp,  UTC unix epoch timestamp in ms
     * @param "AkamaiCategoryId" (optional.Float64) -  the akamai category id, number

@return interface{}
*/

type CustomerApiCustomerPrototypePostGroupOfUnassignedDevicesSecurityPolicyWebsitesWhitelistOpts struct { 
	Dns optional.String
	Type_ optional.String
	Value optional.String
	Direction optional.String
	GeoLocation optional.String
	EndTimestamp optional.Float64
	AkamaiCategoryId optional.Float64
}

func (a *CustomerApiService) CustomerPrototypePostGroupOfUnassignedDevicesSecurityPolicyWebsitesWhitelist(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePostGroupOfUnassignedDevicesSecurityPolicyWebsitesWhitelistOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/groupOfUnassignedDevices/securityPolicy/websites/whitelist"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Dns.IsSet() {
		localVarFormParams.Add("dns", parameterToString(localVarOptionals.Dns.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Value.IsSet() {
		localVarFormParams.Add("value", parameterToString(localVarOptionals.Value.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Direction.IsSet() {
		localVarFormParams.Add("direction", parameterToString(localVarOptionals.Direction.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GeoLocation.IsSet() {
		localVarFormParams.Add("geoLocation", parameterToString(localVarOptionals.GeoLocation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndTimestamp.IsSet() {
		localVarFormParams.Add("endTimestamp", parameterToString(localVarOptionals.EndTimestamp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AkamaiCategoryId.IsSet() {
		localVarFormParams.Add("akamaiCategoryId", parameterToString(localVarOptionals.AkamaiCategoryId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 202 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Retrieve all kvConfigs on a particular Node for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, your new info looks good.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: nodeId must be defined.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;425&lt;/strong&gt;: nodeId must belong to the location.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param nodeId
 * @param module
 * @param key
 * @param value
 * @param optional nil or *CustomerApiCustomerPrototypePostKvConfigsOpts - Optional Parameters:
     * @param "Persist" (optional.Bool) - 

@return KvConfig
*/

type CustomerApiCustomerPrototypePostKvConfigsOpts struct { 
	Persist optional.Bool
}

func (a *CustomerApiService) CustomerPrototypePostKvConfigs(ctx context.Context, id string, locationId string, nodeId string, module string, key string, value string, localVarOptionals *CustomerApiCustomerPrototypePostKvConfigsOpts) (KvConfig, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue KvConfig
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodes/{nodeId}/kvConfigs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("module", parameterToString(module, ""))
	localVarFormParams.Add("key", parameterToString(key, ""))
	localVarFormParams.Add("value", parameterToString(value, ""))
	if localVarOptionals != nil && localVarOptionals.Persist.IsSet() {
		localVarFormParams.Add("persist", parameterToString(localVarOptionals.Persist.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v KvConfig
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Setup a Mobile Device for Security Out of Home Protection (returns a Deeplink for use with Mobolize).
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePostLocationSecurityPolicyOHPDeviceSetupOpts - Optional Parameters:
     * @param "LanIpv4" (optional.String) -  Mobile device lanIpv4 address, if any
     * @param "LanIpv6" (optional.String) -  Mobile device lanIpv6 address, if any

@return interface{}
*/

type CustomerApiCustomerPrototypePostLocationSecurityPolicyOHPDeviceSetupOpts struct { 
	LanIpv4 optional.String
	LanIpv6 optional.String
}

func (a *CustomerApiService) CustomerPrototypePostLocationSecurityPolicyOHPDeviceSetup(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePostLocationSecurityPolicyOHPDeviceSetupOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy/ohp/deviceSetup"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.LanIpv4.IsSet() {
		localVarFormParams.Add("lanIpv4", parameterToString(localVarOptionals.LanIpv4.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LanIpv6.IsSet() {
		localVarFormParams.Add("lanIpv6", parameterToString(localVarOptionals.LanIpv6.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a Location&#39;s Security Policy for a location ID to include a blacklisted DNS entry.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, or Device does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: DNS value is invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePostLocationSecurityPolicyWebsitesBlacklistOpts - Optional Parameters:
     * @param "Dns" (optional.String) - 
     * @param "Type_" (optional.String) - 
     * @param "Value" (optional.String) - 
     * @param "Direction" (optional.String) - 
     * @param "GeoLocation" (optional.String) - 
     * @param "EndTimestamp" (optional.Float64) -  the end time stamp,  UTC unix epoch timestamp in ms
     * @param "AkamaiCategoryId" (optional.Float64) -  the akamai category id, number

@return interface{}
*/

type CustomerApiCustomerPrototypePostLocationSecurityPolicyWebsitesBlacklistOpts struct { 
	Dns optional.String
	Type_ optional.String
	Value optional.String
	Direction optional.String
	GeoLocation optional.String
	EndTimestamp optional.Float64
	AkamaiCategoryId optional.Float64
}

func (a *CustomerApiService) CustomerPrototypePostLocationSecurityPolicyWebsitesBlacklist(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePostLocationSecurityPolicyWebsitesBlacklistOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy/websites/blacklist"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Dns.IsSet() {
		localVarFormParams.Add("dns", parameterToString(localVarOptionals.Dns.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Value.IsSet() {
		localVarFormParams.Add("value", parameterToString(localVarOptionals.Value.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Direction.IsSet() {
		localVarFormParams.Add("direction", parameterToString(localVarOptionals.Direction.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GeoLocation.IsSet() {
		localVarFormParams.Add("geoLocation", parameterToString(localVarOptionals.GeoLocation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndTimestamp.IsSet() {
		localVarFormParams.Add("endTimestamp", parameterToString(localVarOptionals.EndTimestamp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AkamaiCategoryId.IsSet() {
		localVarFormParams.Add("akamaiCategoryId", parameterToString(localVarOptionals.AkamaiCategoryId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a Location&#39;s Security Policy for a location ID to include a whitelisted DNS entry.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, or Device does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: DNS value is invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePostLocationSecurityPolicyWebsitesWhitelistOpts - Optional Parameters:
     * @param "Dns" (optional.String) - 
     * @param "Type_" (optional.String) - 
     * @param "Value" (optional.String) - 
     * @param "Direction" (optional.String) - 
     * @param "GeoLocation" (optional.String) - 
     * @param "EventType" (optional.String) -  EventType field from events response - can be &#39;kids&#39;, &#39;teenagers&#39;, &#39;secureAndProtect&#39;, etc
     * @param "Source" (optional.String) -  Source field from events response - can be &#39;brightcloud&#39;, &#39;webpulse&#39;, &#39;gatekeeper&#39;, &#39;gatekeeper-ohp&#39;
     * @param "EndTimestamp" (optional.Float64) -  the end time stamp,  UTC unix epoch timestamp in ms
     * @param "AkamaiCategoryId" (optional.Float64) -  the akamai category id, number

@return interface{}
*/

type CustomerApiCustomerPrototypePostLocationSecurityPolicyWebsitesWhitelistOpts struct { 
	Dns optional.String
	Type_ optional.String
	Value optional.String
	Direction optional.String
	GeoLocation optional.String
	EventType optional.String
	Source optional.String
	EndTimestamp optional.Float64
	AkamaiCategoryId optional.Float64
}

func (a *CustomerApiService) CustomerPrototypePostLocationSecurityPolicyWebsitesWhitelist(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePostLocationSecurityPolicyWebsitesWhitelistOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy/websites/whitelist"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Dns.IsSet() {
		localVarFormParams.Add("dns", parameterToString(localVarOptionals.Dns.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Value.IsSet() {
		localVarFormParams.Add("value", parameterToString(localVarOptionals.Value.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Direction.IsSet() {
		localVarFormParams.Add("direction", parameterToString(localVarOptionals.Direction.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GeoLocation.IsSet() {
		localVarFormParams.Add("geoLocation", parameterToString(localVarOptionals.GeoLocation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventType.IsSet() {
		localVarFormParams.Add("eventType", parameterToString(localVarOptionals.EventType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Source.IsSet() {
		localVarFormParams.Add("source", parameterToString(localVarOptionals.Source.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndTimestamp.IsSet() {
		localVarFormParams.Add("endTimestamp", parameterToString(localVarOptionals.EndTimestamp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AkamaiCategoryId.IsSet() {
		localVarFormParams.Add("akamaiCategoryId", parameterToString(localVarOptionals.AkamaiCategoryId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Assign a manager to your location 
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid email, name, access type or manager is already assigned to this location &lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param email
 * @param name
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePostManagerOpts - Optional Parameters:
     * @param "AccessType" (optional.String) - 
     * @param "NotificationOptions" (optional.String) - 

@return LocationAccess
*/

type CustomerApiCustomerPrototypePostManagerOpts struct { 
	AccessType optional.String
	NotificationOptions optional.String
}

func (a *CustomerApiService) CustomerPrototypePostManager(ctx context.Context, id string, email string, name string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePostManagerOpts) (LocationAccess, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue LocationAccess
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/managers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("email", parameterToString(email, ""))
	localVarFormParams.Add("name", parameterToString(name, ""))
	if localVarOptionals != nil && localVarOptionals.AccessType.IsSet() {
		localVarFormParams.Add("accessType", parameterToString(localVarOptionals.AccessType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotificationOptions.IsSet() {
		localVarFormParams.Add("notificationOptions", parameterToString(localVarOptionals.NotificationOptions.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v LocationAccess
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Record the new Onboarding Checkpoint for the Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, most recent checkpoint saved.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: checkpoint value must be defined.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePostOnboardingCheckpointOpts - Optional Parameters:
     * @param "Checkpoint" (optional.String) -  is the last passed onboarding step by the customer: &#39;PodsAdded&#39; or &#39;OnboardingComplete&#39;;
     * @param "PodsSeenByBle" (optional.String) -  is the number of Nodes the app discovered by BLE when the onboarding was completed by the customer, submit with PodsAdded
     * @param "AppOs" (optional.String) -  is the version of the app used during the onboarding, submit with PodsAdded
     * @param "OsVersion" (optional.String) -  is the phone OS version used during the onboarding, submit with PodsAdded

@return InlineResponse2009
*/

type CustomerApiCustomerPrototypePostOnboardingCheckpointOpts struct { 
	Checkpoint optional.String
	PodsSeenByBle optional.String
	AppOs optional.String
	OsVersion optional.String
}

func (a *CustomerApiService) CustomerPrototypePostOnboardingCheckpoint(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePostOnboardingCheckpointOpts) (InlineResponse2009, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2009
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/onboardingCheckpoint"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Checkpoint.IsSet() {
		localVarFormParams.Add("checkpoint", parameterToString(localVarOptionals.Checkpoint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PodsSeenByBle.IsSet() {
		localVarFormParams.Add("podsSeenByBle", parameterToString(localVarOptionals.PodsSeenByBle.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AppOs.IsSet() {
		localVarFormParams.Add("appOs", parameterToString(localVarOptionals.AppOs.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OsVersion.IsSet() {
		localVarFormParams.Add("osVersion", parameterToString(localVarOptionals.OsVersion.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2009
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Post a shared schedule uuid freeze for a person for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: FreezeTemplateId not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Person not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId
 * @param freezeTemplateId Valid templates are uuids

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypePostPersonFreeze(ctx context.Context, id string, locationId string, personId string, freezeTemplateId string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/freeze/{freezeTemplateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"freezeTemplateId"+"}", fmt.Sprintf("%v", freezeTemplateId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a Person&#39;s Security Policy for a location ID to include a blacklisted DNS entry.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, or Person id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: DNS value is invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId
 * @param optional nil or *CustomerApiCustomerPrototypePostPersonSecurityPolicyWebsitesBlacklistOpts - Optional Parameters:
     * @param "Dns" (optional.String) - 
     * @param "Type_" (optional.String) - 
     * @param "Value" (optional.String) - 
     * @param "Direction" (optional.String) - 
     * @param "GeoLocation" (optional.String) - 
     * @param "EndTimestamp" (optional.Float64) -  the end time stamp,  UTC unix epoch timestamp in ms
     * @param "AkamaiCategoryId" (optional.Float64) -  the akamai category id, number

@return interface{}
*/

type CustomerApiCustomerPrototypePostPersonSecurityPolicyWebsitesBlacklistOpts struct { 
	Dns optional.String
	Type_ optional.String
	Value optional.String
	Direction optional.String
	GeoLocation optional.String
	EndTimestamp optional.Float64
	AkamaiCategoryId optional.Float64
}

func (a *CustomerApiService) CustomerPrototypePostPersonSecurityPolicyWebsitesBlacklist(ctx context.Context, id string, locationId string, personId string, localVarOptionals *CustomerApiCustomerPrototypePostPersonSecurityPolicyWebsitesBlacklistOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/securityPolicy/websites/blacklist"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Dns.IsSet() {
		localVarFormParams.Add("dns", parameterToString(localVarOptionals.Dns.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Value.IsSet() {
		localVarFormParams.Add("value", parameterToString(localVarOptionals.Value.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Direction.IsSet() {
		localVarFormParams.Add("direction", parameterToString(localVarOptionals.Direction.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GeoLocation.IsSet() {
		localVarFormParams.Add("geoLocation", parameterToString(localVarOptionals.GeoLocation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndTimestamp.IsSet() {
		localVarFormParams.Add("endTimestamp", parameterToString(localVarOptionals.EndTimestamp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AkamaiCategoryId.IsSet() {
		localVarFormParams.Add("akamaiCategoryId", parameterToString(localVarOptionals.AkamaiCategoryId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a Person&#39;s Security Policy for a location ID to include a whitelisted DNS entry.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, WifiNetwork, or Person id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: DNS value is invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId
 * @param optional nil or *CustomerApiCustomerPrototypePostPersonSecurityPolicyWebsitesWhitelistOpts - Optional Parameters:
     * @param "Dns" (optional.String) - 
     * @param "Type_" (optional.String) - 
     * @param "Value" (optional.String) - 
     * @param "Direction" (optional.String) - 
     * @param "GeoLocation" (optional.String) - 
     * @param "EventType" (optional.String) -  EventType field from events response - can be &#39;kids&#39;, &#39;teenagers&#39;, &#39;secureAndProtect&#39;, etc
     * @param "Source" (optional.String) -  Source field from events response - can be &#39;brightcloud&#39;, &#39;webpulse&#39;, &#39;gatekeeper&#39;, &#39;gatekeeper-ohp&#39;
     * @param "EndTimestamp" (optional.Float64) -  the end time stamp,  UTC unix epoch timestamp in ms
     * @param "AkamaiCategoryId" (optional.Float64) -  the akamai category id, number

@return interface{}
*/

type CustomerApiCustomerPrototypePostPersonSecurityPolicyWebsitesWhitelistOpts struct { 
	Dns optional.String
	Type_ optional.String
	Value optional.String
	Direction optional.String
	GeoLocation optional.String
	EventType optional.String
	Source optional.String
	EndTimestamp optional.Float64
	AkamaiCategoryId optional.Float64
}

func (a *CustomerApiService) CustomerPrototypePostPersonSecurityPolicyWebsitesWhitelist(ctx context.Context, id string, locationId string, personId string, localVarOptionals *CustomerApiCustomerPrototypePostPersonSecurityPolicyWebsitesWhitelistOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/securityPolicy/websites/whitelist"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Dns.IsSet() {
		localVarFormParams.Add("dns", parameterToString(localVarOptionals.Dns.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Value.IsSet() {
		localVarFormParams.Add("value", parameterToString(localVarOptionals.Value.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Direction.IsSet() {
		localVarFormParams.Add("direction", parameterToString(localVarOptionals.Direction.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GeoLocation.IsSet() {
		localVarFormParams.Add("geoLocation", parameterToString(localVarOptionals.GeoLocation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventType.IsSet() {
		localVarFormParams.Add("eventType", parameterToString(localVarOptionals.EventType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Source.IsSet() {
		localVarFormParams.Add("source", parameterToString(localVarOptionals.Source.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndTimestamp.IsSet() {
		localVarFormParams.Add("endTimestamp", parameterToString(localVarOptionals.EndTimestamp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AkamaiCategoryId.IsSet() {
		localVarFormParams.Add("akamaiCategoryId", parameterToString(localVarOptionals.AkamaiCategoryId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create  a Person for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Nickname must be defined and mac addresses must be valid and email needs to be provided when permission is provided.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param nickname
 * @param imageId unique identifier for referencing a Person&#39;s hosted profile image, defaults are PROFILE_MAN and PROFILE_WOMAN
 * @param optional nil or *CustomerApiCustomerPrototypePostPersonsOpts - Optional Parameters:
     * @param "AssignedDevices" (optional.String) -  mac addresses of devices assigned to this Person
     * @param "Profile" (optional.String) -  Profile object contains &#39;type&#39; field - valid values: &#39;employee&#39;
     * @param "Email" (optional.String) -  email
     * @param "Permission" (optional.String) -  Permission object for creating a manager for the location
     * @param "ServiceLinking" (optional.String) -  serviceLinking object that links this Person object to a 3rd party&#39;s Person

@return Person
*/

type CustomerApiCustomerPrototypePostPersonsOpts struct { 
	AssignedDevices optional.String
	Profile optional.String
	Email optional.String
	Permission optional.String
	ServiceLinking optional.String
}

func (a *CustomerApiService) CustomerPrototypePostPersons(ctx context.Context, id string, locationId string, nickname string, imageId string, localVarOptionals *CustomerApiCustomerPrototypePostPersonsOpts) (Person, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Person
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("nickname", parameterToString(nickname, ""))
	localVarFormParams.Add("imageId", parameterToString(imageId, ""))
	if localVarOptionals != nil && localVarOptionals.AssignedDevices.IsSet() {
		localVarFormParams.Add("assignedDevices", parameterToString(localVarOptionals.AssignedDevices.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Profile.IsSet() {
		localVarFormParams.Add("profile", parameterToString(localVarOptionals.Profile.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Email.IsSet() {
		localVarFormParams.Add("email", parameterToString(localVarOptionals.Email.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Permission.IsSet() {
		localVarFormParams.Add("permission", parameterToString(localVarOptionals.Permission.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceLinking.IsSet() {
		localVarFormParams.Add("serviceLinking", parameterToString(localVarOptionals.ServiceLinking.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Person
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Record a new Port Forwarding entry for an existing DHCP IP reservation tied to a MAC address at a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, all PortForwards are returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: networkConfiguration, dhcpReservation, PortForward is empty.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: mac is empty, or invalid, externalPort/internalPort is out of range, or protocol is invalid, or duplicate externalPort.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param optional nil or *CustomerApiCustomerPrototypePostPortForwardOpts - Optional Parameters:
     * @param "ExternalPort" (optional.String) - 
     * @param "InternalPort" (optional.String) - 
     * @param "Protocol" (optional.String) - 
     * @param "Name" (optional.String) - 

@return PortForward
*/

type CustomerApiCustomerPrototypePostPortForwardOpts struct { 
	ExternalPort optional.String
	InternalPort optional.String
	Protocol optional.String
	Name optional.String
}

func (a *CustomerApiService) CustomerPrototypePostPortForward(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypePostPortForwardOpts) (PortForward, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PortForward
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkConfiguration/dhcpReservations/{mac}/portForward"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ExternalPort.IsSet() {
		localVarFormParams.Add("externalPort", parameterToString(localVarOptionals.ExternalPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InternalPort.IsSet() {
		localVarFormParams.Add("internalPort", parameterToString(localVarOptionals.InternalPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Protocol.IsSet() {
		localVarFormParams.Add("protocol", parameterToString(localVarOptionals.Protocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v PortForward
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Post a Remote Connection Allow IpAddress/ttl for the given device and Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or Device mac does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Fields have an invalid type or value.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param type_ either ipv4 or ipv6
 * @param value ipaddress
 * @param expiresAt UTC timestamp in ISO 8601 format

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypePostRemoteConnectionsAllow(ctx context.Context, id string, locationId string, mac string, type_ string, value string, expiresAt string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/securityPolicy/remoteConnections/allow"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("type", parameterToString(type_, ""))
	localVarFormParams.Add("value", parameterToString(value, ""))
	localVarFormParams.Add("expiresAt", parameterToString(expiresAt, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Post a Remote Connection Allow All/ttl for the given device and Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or Device mac does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Fields have an invalid type or value.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param expiresAt UTC timestamp in ISO 8601 format

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypePostRemoteConnectionsAllowAll(ctx context.Context, id string, locationId string, mac string, expiresAt string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/securityPolicy/remoteConnections/allowAll"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("expiresAt", parameterToString(expiresAt, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create a Room for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Devices and Nodes must be defined and mac addresses must be valid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param name name of this Room
 * @param optional nil or *CustomerApiCustomerPrototypePostRoomsOpts - Optional Parameters:
     * @param "Devices" (optional.String) -  mac addresses of devices assigned to this Room
     * @param "Nodes" (optional.String) -  nodeIds assigned to this Room

@return Room
*/

type CustomerApiCustomerPrototypePostRoomsOpts struct { 
	Devices optional.String
	Nodes optional.String
}

func (a *CustomerApiService) CustomerPrototypePostRooms(ctx context.Context, id string, locationId string, name string, localVarOptionals *CustomerApiCustomerPrototypePostRoomsOpts) (Room, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Room
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/rooms"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	if localVarOptionals != nil && localVarOptionals.Devices.IsSet() {
		localVarFormParams.Add("devices", parameterToString(localVarOptionals.Devices.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Nodes.IsSet() {
		localVarFormParams.Add("nodes", parameterToString(localVarOptionals.Nodes.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Room
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Run ISP speed test for GW node on mobile request.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, run.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Customer or location does not exists.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePostRunMobileIspSpeedTestOpts - Optional Parameters:
     * @param "RequestId" (optional.String) - 
     * @param "ServerId" (optional.Float64) - 
     * @param "UplinkType" (optional.String) - 

@return interface{}
*/

type CustomerApiCustomerPrototypePostRunMobileIspSpeedTestOpts struct { 
	RequestId optional.String
	ServerId optional.Float64
	UplinkType optional.String
}

func (a *CustomerApiService) CustomerPrototypePostRunMobileIspSpeedTest(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePostRunMobileIspSpeedTestOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/ispSpeedTest"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.RequestId.IsSet() {
		localVarFormParams.Add("requestId", parameterToString(localVarOptionals.RequestId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServerId.IsSet() {
		localVarFormParams.Add("serverId", parameterToString(localVarOptionals.ServerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UplinkType.IsSet() {
		localVarFormParams.Add("uplinkType", parameterToString(localVarOptionals.UplinkType.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Run speed test for a node.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, run.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Customer, location or node does not exists.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid test type.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param nodeId
 * @param testType
 * @param optional nil or *CustomerApiCustomerPrototypePostSpeedTestOpts - Optional Parameters:
     * @param "ServerId" (optional.Float64) - 
     * @param "UplinkType" (optional.String) - 

@return interface{}
*/

type CustomerApiCustomerPrototypePostSpeedTestOpts struct { 
	ServerId optional.Float64
	UplinkType optional.String
}

func (a *CustomerApiService) CustomerPrototypePostSpeedTest(ctx context.Context, id string, locationId string, nodeId string, testType string, localVarOptionals *CustomerApiCustomerPrototypePostSpeedTestOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodes/{nodeId}/speedTest"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("testType", parameterToString(testType, ""))
	if localVarOptionals != nil && localVarOptionals.ServerId.IsSet() {
		localVarFormParams.Add("serverId", parameterToString(localVarOptionals.ServerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UplinkType.IsSet() {
		localVarFormParams.Add("uplinkType", parameterToString(localVarOptionals.UplinkType.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Post a request for a whitelist exception to be added to your person profile.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, CustomerId or requst id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param value
 * @param type_

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypePostWhitelistApprovalRequest(ctx context.Context, id string, locationId string, value string, type_ string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy/websites/whitelist/approvalRequests"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("value", parameterToString(value, ""))
	localVarFormParams.Add("type", parameterToString(type_, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create a new WiFi Access Zone
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, all access zones returned&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Customer id, location id, or WifiNetwork does not exist&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Validation failed&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param description name of access zone
 * @param type_ for now, must be &#39;guests&#39;
 * @param optional nil or *CustomerApiCustomerPrototypePostWifiAccessZoneOpts - Optional Parameters:
     * @param "AccessibleDevices" (optional.String) -  macs of home devices visible to this guest access zone

@return []WifiAccessZone
*/

type CustomerApiCustomerPrototypePostWifiAccessZoneOpts struct { 
	AccessibleDevices optional.String
}

func (a *CustomerApiService) CustomerPrototypePostWifiAccessZone(ctx context.Context, id string, locationId string, description string, type_ string, localVarOptionals *CustomerApiCustomerPrototypePostWifiAccessZoneOpts) ([]WifiAccessZone, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []WifiAccessZone
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork/accessZones"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("description", parameterToString(description, ""))
	localVarFormParams.Add("type", parameterToString(type_, ""))
	if localVarOptionals != nil && localVarOptionals.AccessibleDevices.IsSet() {
		localVarFormParams.Add("accessibleDevices", parameterToString(localVarOptionals.AccessibleDevices.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []WifiAccessZone
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create a new WiFi Password
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, all passwords returned&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Customer id, location id, or WifiNetwork does not exist&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Password validation failed&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param accessZone home | guests | internetAccessOnly
 * @param encryptionKey
 * @param enable devices can connect using this encryptionKey
 * @param format encryptionKey | phoneNumber
 * @param optional nil or *CustomerApiCustomerPrototypePostWifiKeyOpts - Optional Parameters:
     * @param "ExpiresAt" (optional.Time) -  UTC in ISO 8601 String format
     * @param "Content" (optional.String) -  Valid values: &#39;adultAndSensitive&#39;

@return []WifiNetworkKey
*/

type CustomerApiCustomerPrototypePostWifiKeyOpts struct { 
	ExpiresAt optional.Time
	Content optional.String
}

func (a *CustomerApiService) CustomerPrototypePostWifiKey(ctx context.Context, id string, locationId string, accessZone string, encryptionKey string, enable bool, format string, localVarOptionals *CustomerApiCustomerPrototypePostWifiKeyOpts) ([]WifiNetworkKey, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []WifiNetworkKey
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork/accessZones/{accessZone}/keys"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessZone"+"}", fmt.Sprintf("%v", accessZone), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("encryptionKey", parameterToString(encryptionKey, ""))
	localVarFormParams.Add("enable", parameterToString(enable, ""))
	localVarFormParams.Add("format", parameterToString(format, ""))
	if localVarOptionals != nil && localVarOptionals.ExpiresAt.IsSet() {
		localVarFormParams.Add("expiresAt", parameterToString(localVarOptionals.ExpiresAt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Content.IsSet() {
		localVarFormParams.Add("content", parameterToString(localVarOptionals.Content.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []WifiNetworkKey
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a WiFi SSID and/or PSK for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, in your future 100 mbps for all devices I see. -Yoda.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;409&lt;/strong&gt;: A WifiNetwork already exists for this location.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: encryptionKey or ssid must be defined, or key length &lt; 8.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePostWifiNetworkOpts - Optional Parameters:
     * @param "EncryptionKey" (optional.String) -  Needs to be a minimum of 8 characters
     * @param "Ssid" (optional.String) - 
     * @param "WpaMode" (optional.String) -  psk-mixed (WPA+WPA2) || sae-mixed (WPA2+WPA3) || psk2 (WPA2 only) || sae (WPA3 only)

@return InlineResponse2002
*/

type CustomerApiCustomerPrototypePostWifiNetworkOpts struct { 
	EncryptionKey optional.String
	Ssid optional.String
	WpaMode optional.String
}

func (a *CustomerApiService) CustomerPrototypePostWifiNetwork(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePostWifiNetworkOpts) (InlineResponse2002, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2002
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.EncryptionKey.IsSet() {
		localVarFormParams.Add("encryptionKey", parameterToString(localVarOptionals.EncryptionKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ssid.IsSet() {
		localVarFormParams.Add("ssid", parameterToString(localVarOptionals.Ssid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WpaMode.IsSet() {
		localVarFormParams.Add("wpaMode", parameterToString(localVarOptionals.WpaMode.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2002
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create the DPP setting for a Location ID.
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success, new DPP configurator generated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePostWifiNetworkDppOpts - Optional Parameters:
     * @param "Enabled" (optional.Bool) -  should we configure dpp for this network - defaults to true
     * @param "Curve" (optional.String) -  one of predefined elliptic curves, - optional,  if missing in request default to prime256v1
     * @param "PrivateKey" (optional.String) -  privateKey, must also provide public part if present, optional
     * @param "PublicKey" (optional.String) -  publicKey

@return interface{}
*/

type CustomerApiCustomerPrototypePostWifiNetworkDppOpts struct { 
	Enabled optional.Bool
	Curve optional.String
	PrivateKey optional.String
	PublicKey optional.String
}

func (a *CustomerApiService) CustomerPrototypePostWifiNetworkDpp(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePostWifiNetworkDppOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork/dpp"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarFormParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Curve.IsSet() {
		localVarFormParams.Add("curve", parameterToString(localVarOptionals.Curve.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PrivateKey.IsSet() {
		localVarFormParams.Add("privateKey", parameterToString(localVarOptionals.PrivateKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PublicKey.IsSet() {
		localVarFormParams.Add("publicKey", parameterToString(localVarOptionals.PublicKey.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 202 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create a bootstrap for DPP setting for a wifi network.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, new DPP configurator generated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or wifi network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid curve.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePostWifiNetworkDppBootstrapOpts - Optional Parameters:
     * @param "Curve" (optional.String) -  one of predefined elliptic curves, - optional,  if missing in requset default to prime256v1

@return interface{}
*/

type CustomerApiCustomerPrototypePostWifiNetworkDppBootstrapOpts struct { 
	Curve optional.String
}

func (a *CustomerApiService) CustomerPrototypePostWifiNetworkDppBootstrap(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePostWifiNetworkDppBootstrapOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork/dpp/bootstrapUris"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Curve.IsSet() {
		localVarFormParams.Add("curve", parameterToString(localVarOptionals.Curve.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create an enrollment for DPP setting for a wifi network.
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success, new DPP configurator generated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or wifi network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Configurator keys for network not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param bootstrapUri

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypePostWifiNetworkDppEnrollment(ctx context.Context, id string, locationId string, bootstrapUri string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork/dpp/enrollments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("bootstrapUri", parameterToString(bootstrapUri, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 202 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Publish all slow changing dimension Kafka messages
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypePublishSlowChangingDimensionConfigs(ctx context.Context, id string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/publishSlowChangingDimensionConfigs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Configure number of authorized leaf pods for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields are missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePutAuthorizationsPutCustomersidLocationslocationIdAuthorizationsOpts - Optional Parameters:
     * @param "NumPodsAuthorized" (optional.Float64) -  number of leaf pods that are authorized to be claimed and be a part of the Plume network

@return Authorizations
*/

type CustomerApiCustomerPrototypePutAuthorizationsPutCustomersidLocationslocationIdAuthorizationsOpts struct { 
	NumPodsAuthorized optional.Float64
}

func (a *CustomerApiService) CustomerPrototypePutAuthorizationsPutCustomersidLocationslocationIdAuthorizations(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePutAuthorizationsPutCustomersidLocationslocationIdAuthorizationsOpts) (Authorizations, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Authorizations
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/authorizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.NumPodsAuthorized.IsSet() {
		localVarFormParams.Add("numPodsAuthorized", parameterToString(localVarOptionals.NumPodsAuthorized.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Authorizations
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Configure number of authorized leaf pods grouped by model id for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields are missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePutAuthorizationsPutCustomersidLocationslocationIdNodeAuthorizationsOpts - Optional Parameters:
     * @param "NumNodesAuthorized" (optional.String) -  number of leaf pods grouped by model id that are authorized to be claimed and be a part of the Plume network

@return Authorizations
*/

type CustomerApiCustomerPrototypePutAuthorizationsPutCustomersidLocationslocationIdNodeAuthorizationsOpts struct { 
	NumNodesAuthorized optional.String
}

func (a *CustomerApiService) CustomerPrototypePutAuthorizationsPutCustomersidLocationslocationIdNodeAuthorizations(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePutAuthorizationsPutCustomersidLocationslocationIdNodeAuthorizationsOpts) (Authorizations, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Authorizations
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodeAuthorizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.NumNodesAuthorized.IsSet() {
		localVarFormParams.Add("numNodesAuthorized", parameterToString(localVarOptionals.NumNodesAuthorized.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Authorizations
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Toggle secure backhaul for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePutBackhaulOpts - Optional Parameters:
     * @param "Mode" (optional.String) -  auto || enable || disable
     * @param "DynamicBeacon" (optional.String) -  A valid state for the dynamic beaconing setting. Either auto, enable, or disable
     * @param "Wds" (optional.String) -  auto || enable || disable
     * @param "WpaMode" (optional.String) -  auto || psk2 || sae-mixed

@return LocationBackhaul
*/

type CustomerApiCustomerPrototypePutBackhaulOpts struct { 
	Mode optional.String
	DynamicBeacon optional.String
	Wds optional.String
	WpaMode optional.String
}

func (a *CustomerApiService) CustomerPrototypePutBackhaul(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePutBackhaulOpts) (LocationBackhaul, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue LocationBackhaul
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/backhaul"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Mode.IsSet() {
		localVarFormParams.Add("mode", parameterToString(localVarOptionals.Mode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DynamicBeacon.IsSet() {
		localVarFormParams.Add("dynamicBeacon", parameterToString(localVarOptionals.DynamicBeacon.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Wds.IsSet() {
		localVarFormParams.Add("wds", parameterToString(localVarOptionals.Wds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WpaMode.IsSet() {
		localVarFormParams.Add("wpaMode", parameterToString(localVarOptionals.WpaMode.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v LocationBackhaul
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Enable/disable band steering for a Location ID (deprecated)
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param auto

@return LocationBandSteering
*/
func (a *CustomerApiService) CustomerPrototypePutBandSteering(ctx context.Context, id string, locationId string, auto bool) (LocationBandSteering, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue LocationBandSteering
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/bandSteering"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("auto", parameterToString(auto, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v LocationBandSteering
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Enable or Disable BLE beaconing for all Pods at a location for Pod location services (e.g. for Pods Naming).
&lt;div&gt;With the mode of \&quot;on\&quot;, all connected pods at this location will have their bluetooth beacon turned on for locating purposes. Each BLE beacon contains the serial number of the transmitting Pod. A setting of \&quot;off\&quot;, turns off the BLE beaconing for all Pods. With mode set to \&quot;wps\&quot;, all connected pods at this location will have their bluetooth beacon turned on for WPS related proximity measurements.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, your new info looks good.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: bleMode must be defined.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePutBleModeOpts - Optional Parameters:
     * @param "Mode" (optional.String) -  on/off/wps/connectable

@return InlineResponse2003
*/

type CustomerApiCustomerPrototypePutBleModeOpts struct { 
	Mode optional.String
}

func (a *CustomerApiService) CustomerPrototypePutBleMode(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePutBleModeOpts) (InlineResponse2003, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2003
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/bleMode"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Mode.IsSet() {
		localVarFormParams.Add("mode", parameterToString(localVarOptionals.Mode.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2003
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Enable or Disable BLE beaconing for the specific Pod at a location.
&lt;div&gt;With the mode of \&quot;on\&quot;, all connected pods at this location will have their bluetooth beacon turned on for locating purposes. Each BLE beacon contains the serial number of the transmitting Pod. A setting of \&quot;off\&quot;, turns off the BLE beaconing for all Pods. With mode set to \&quot;wps\&quot;, all connected pods at this location will have their bluetooth beacon turned on for WPS related proximity measurements.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, your new info looks good.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: bleMode must be defined.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param nodeId
 * @param optional nil or *CustomerApiCustomerPrototypePutBleModeForNodeOpts - Optional Parameters:
     * @param "Mode" (optional.String) -  on/off/wps/connectable

@return InlineResponse2003
*/

type CustomerApiCustomerPrototypePutBleModeForNodeOpts struct { 
	Mode optional.String
}

func (a *CustomerApiService) CustomerPrototypePutBleModeForNode(ctx context.Context, id string, locationId string, nodeId string, localVarOptionals *CustomerApiCustomerPrototypePutBleModeForNodeOpts) (InlineResponse2003, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2003
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodes/{nodeId}/bleMode"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Mode.IsSet() {
		localVarFormParams.Add("mode", parameterToString(localVarOptionals.Mode.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2003
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Send Captive Portal Guest details to requesters email for a given Location ID/NetworkId.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or CaptivePortal Network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param optional nil or *CustomerApiCustomerPrototypePutCaptivePortalSendDetailsOpts - Optional Parameters:
     * @param "Duration" (optional.Float64) -  number of days for how far back in history for data
     * @param "Limit" (optional.Float64) -  limit how many emails we wish to return


*/

type CustomerApiCustomerPrototypePutCaptivePortalSendDetailsOpts struct { 
	Duration optional.Float64
	Limit optional.Float64
}

func (a *CustomerApiService) CustomerPrototypePutCaptivePortalSendDetails(ctx context.Context, id string, locationId string, networkId string, localVarOptionals *CustomerApiCustomerPrototypePutCaptivePortalSendDetailsOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/secondaryNetworks/captivePortals/{networkId}/sendGuestDetails"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Duration.IsSet() {
		localVarFormParams.Add("duration", parameterToString(localVarOptionals.Duration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarFormParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Returns cloud migration status for customer
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, no content.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Missing providerId body parameter&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;409&lt;/strong&gt;: Accounts are already linked for providerId&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid providerId&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param providerId enum to identify provider ex. commandAlexa


*/
func (a *CustomerApiService) CustomerPrototypePutCommand(ctx context.Context, id string, locationId string, providerId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/command"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("providerId", parameterToString(providerId, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Set control mode for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mode

@return LocationControlMode
*/
func (a *CustomerApiService) CustomerPrototypePutControlMode(ctx context.Context, id string, locationId string, mode string) (LocationControlMode, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue LocationControlMode
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/controlMode"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("mode", parameterToString(mode, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v LocationControlMode
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Push Security Configurations to Councilman.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId


*/
func (a *CustomerApiService) CustomerPrototypePutCouncilmanResync(ctx context.Context, id string, locationId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/councilman/resync"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Put a device to be frozen for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt; &lt;div&gt;&lt;strong&gt;501&lt;/strong&gt;: Not Implemented, if location is utilizing shared location freeze schedules&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param freezeTemplateId Valid templates are &#39;untilMidinight&#39;, &#39;schoolNights&#39;, etc.
 * @param optional nil or *CustomerApiCustomerPrototypePutDeviceFreezeOpts - Optional Parameters:
     * @param "DeleteAllExceptSuspend" (optional.Bool) - 
     * @param "Schedules" (optional.String) - 
     * @param "Enable" (optional.Bool) - 
     * @param "Name" (optional.String) - 

@return XAny
*/

type CustomerApiCustomerPrototypePutDeviceFreezeOpts struct { 
	DeleteAllExceptSuspend optional.Bool
	Schedules optional.String
	Enable optional.Bool
	Name optional.String
}

func (a *CustomerApiService) CustomerPrototypePutDeviceFreeze(ctx context.Context, id string, locationId string, mac string, freezeTemplateId string, localVarOptionals *CustomerApiCustomerPrototypePutDeviceFreezeOpts) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/freeze/{freezeTemplateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"freezeTemplateId"+"}", fmt.Sprintf("%v", freezeTemplateId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.DeleteAllExceptSuspend.IsSet() {
		localVarFormParams.Add("deleteAllExceptSuspend", parameterToString(localVarOptionals.DeleteAllExceptSuspend.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Schedules.IsSet() {
		localVarFormParams.Add("schedules", parameterToString(localVarOptionals.Schedules.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enable.IsSet() {
		localVarFormParams.Add("enable", parameterToString(localVarOptionals.Enable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Put a device to be frozen for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param expiresAt

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypePutDeviceFreezeAutoExpire(ctx context.Context, id string, locationId string, mac string, expiresAt string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/freeze/autoExpire"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("expiresAt", parameterToString(expiresAt, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Put a device forever freeze for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param optional nil or *CustomerApiCustomerPrototypePutDeviceFreezeForeverOpts - Optional Parameters:
     * @param "DeleteAllExceptSuspend" (optional.Bool) - 
     * @param "Enable" (optional.Bool) - 

@return XAny
*/

type CustomerApiCustomerPrototypePutDeviceFreezeForeverOpts struct { 
	DeleteAllExceptSuspend optional.Bool
	Enable optional.Bool
}

func (a *CustomerApiService) CustomerPrototypePutDeviceFreezeForever(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypePutDeviceFreezeForeverOpts) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/freeze/forever"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.DeleteAllExceptSuspend.IsSet() {
		localVarFormParams.Add("deleteAllExceptSuspend", parameterToString(localVarOptionals.DeleteAllExceptSuspend.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enable.IsSet() {
		localVarFormParams.Add("enable", parameterToString(localVarOptionals.Enable.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Put a device residentialGwManaged freeze for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param optional nil or *CustomerApiCustomerPrototypePutDeviceFreezeResidentialGwManagedOpts - Optional Parameters:
     * @param "DeleteAllExceptSuspend" (optional.Bool) - 
     * @param "Schedules" (optional.String) - 
     * @param "Enable" (optional.Bool) - 
     * @param "Name" (optional.String) - 

@return XAny
*/

type CustomerApiCustomerPrototypePutDeviceFreezeResidentialGwManagedOpts struct { 
	DeleteAllExceptSuspend optional.Bool
	Schedules optional.String
	Enable optional.Bool
	Name optional.String
}

func (a *CustomerApiService) CustomerPrototypePutDeviceFreezeResidentialGwManaged(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypePutDeviceFreezeResidentialGwManagedOpts) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/freeze/residentialGwManaged"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.DeleteAllExceptSuspend.IsSet() {
		localVarFormParams.Add("deleteAllExceptSuspend", parameterToString(localVarOptionals.DeleteAllExceptSuspend.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Schedules.IsSet() {
		localVarFormParams.Add("schedules", parameterToString(localVarOptionals.Schedules.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enable.IsSet() {
		localVarFormParams.Add("enable", parameterToString(localVarOptionals.Enable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Put a device suspend for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param optional nil or *CustomerApiCustomerPrototypePutDeviceFreezeSuspendOpts - Optional Parameters:
     * @param "DeleteAllExceptSuspend" (optional.Bool) - 
     * @param "Enable" (optional.Bool) - 

@return XAny
*/

type CustomerApiCustomerPrototypePutDeviceFreezeSuspendOpts struct { 
	DeleteAllExceptSuspend optional.Bool
	Enable optional.Bool
}

func (a *CustomerApiService) CustomerPrototypePutDeviceFreezeSuspend(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypePutDeviceFreezeSuspendOpts) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/freeze/suspend"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.DeleteAllExceptSuspend.IsSet() {
		localVarFormParams.Add("deleteAllExceptSuspend", parameterToString(localVarOptionals.DeleteAllExceptSuspend.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enable.IsSet() {
		localVarFormParams.Add("enable", parameterToString(localVarOptionals.Enable.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Nickname a Customer&#39;s device for all locations.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, device name has been updated&lt;br/&gt;but not validated as a device that &lt;br/&gt;has ever connected.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: nickname value must be defined.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id and/or mac does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: nickname value must be less than 33 characters.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param mac
 * @param optional nil or *CustomerApiCustomerPrototypePutDeviceNicknameOpts - Optional Parameters:
     * @param "Nickname" (optional.String) - 

@return Customer
*/

type CustomerApiCustomerPrototypePutDeviceNicknameOpts struct { 
	Nickname optional.String
}

func (a *CustomerApiService) CustomerPrototypePutDeviceNickname(ctx context.Context, id string, mac string, localVarOptionals *CustomerApiCustomerPrototypePutDeviceNicknameOpts) (Customer, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Customer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/devices/{mac}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Nickname.IsSet() {
		localVarFormParams.Add("nickname", parameterToString(localVarOptionals.Nickname.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Customer
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Sets autoExpire or freezeTemplateId suspend for specified mac addresses
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Succcess, updated&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Unathorized&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Mac not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid freezeTemplateID&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal Server Error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param devices

@return []interface{}
*/
func (a *CustomerApiService) CustomerPrototypePutDevicesFreezeCommand(ctx context.Context, id string, locationId string, devices []XAny) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/command/devices/freeze"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &devices
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 204 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService DEPRECATED: Update home devices visible to guests.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, devicesVisibleToGuests returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Customer id, location id, or WifiNetwork does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Device mac validation failed.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param devicesVisibleToGuests array of macs[]

@return []string
*/
func (a *CustomerApiService) CustomerPrototypePutDevicesVisibleToGuests(ctx context.Context, id string, locationId string, devicesVisibleToGuests string) ([]string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork/accessZones/home/devicesVisibleToGuests"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("devicesVisibleToGuests", parameterToString(devicesVisibleToGuests, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Record or update a new DHCP subnet/subnetMask for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, DHCP are returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: subnet value is empty, or invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param subnet
 * @param optional nil or *CustomerApiCustomerPrototypePutDhcpOpts - Optional Parameters:
     * @param "SubnetMask" (optional.String) - 
     * @param "StartIp" (optional.String) - 
     * @param "EndIp" (optional.String) - 

@return interface{}
*/

type CustomerApiCustomerPrototypePutDhcpOpts struct { 
	SubnetMask optional.String
	StartIp optional.String
	EndIp optional.String
}

func (a *CustomerApiService) CustomerPrototypePutDhcp(ctx context.Context, id string, locationId string, subnet string, localVarOptionals *CustomerApiCustomerPrototypePutDhcpOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkConfiguration/dhcp"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("subnet", parameterToString(subnet, ""))
	if localVarOptionals != nil && localVarOptionals.SubnetMask.IsSet() {
		localVarFormParams.Add("subnetMask", parameterToString(localVarOptionals.SubnetMask.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartIp.IsSet() {
		localVarFormParams.Add("startIp", parameterToString(localVarOptionals.StartIp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndIp.IsSet() {
		localVarFormParams.Add("endIp", parameterToString(localVarOptionals.EndIp.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Record or update a new DHCP IP Reservation for a particular MAC address at a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, all DHCP Reservations are returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;412&lt;/strong&gt;: Subnet prefix is unknown.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: IP/mac value is empty, or invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param ip
 * @param optional nil or *CustomerApiCustomerPrototypePutDhcpReservationOpts - Optional Parameters:
     * @param "HostName" (optional.String) - 

@return DhcpReservation
*/

type CustomerApiCustomerPrototypePutDhcpReservationOpts struct { 
	HostName optional.String
}

func (a *CustomerApiService) CustomerPrototypePutDhcpReservation(ctx context.Context, id string, locationId string, mac string, ip string, localVarOptionals *CustomerApiCustomerPrototypePutDhcpReservationOpts) (DhcpReservation, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DhcpReservation
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkConfiguration/dhcpReservations/{mac}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("ip", parameterToString(ip, ""))
	if localVarOptionals != nil && localVarOptionals.HostName.IsSet() {
		localVarFormParams.Add("hostName", parameterToString(localVarOptionals.HostName.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v DhcpReservation
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update the DNS IPv4 server addresses for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, new DNS Servers saved.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: primaryDns or secondaryDns DNS Servers value is empty.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePutDnsServersOpts - Optional Parameters:
     * @param "PrimaryDns" (optional.String) - 
     * @param "SecondaryDns" (optional.String) - 

@return DnsServers
*/

type CustomerApiCustomerPrototypePutDnsServersOpts struct { 
	PrimaryDns optional.String
	SecondaryDns optional.String
}

func (a *CustomerApiService) CustomerPrototypePutDnsServers(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePutDnsServersOpts) (DnsServers, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DnsServers
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkConfiguration/dnsServers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.PrimaryDns.IsSet() {
		localVarFormParams.Add("primaryDns", parameterToString(localVarOptionals.PrimaryDns.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SecondaryDns.IsSet() {
		localVarFormParams.Add("secondaryDns", parameterToString(localVarOptionals.SecondaryDns.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v DnsServers
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create and persist a list of DPP enrollments
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or wifi network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param enrollments

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypePutDppEnrollments(ctx context.Context, id string, locationId string, enrollments []XAny) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/dpp/enrollments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &enrollments
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 202 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Updates location nodes with ethernetLan modes
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Node does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: nodeEthernetLan does not exist.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param nodeId
 * @param nodeEthernetLan


*/
func (a *CustomerApiService) CustomerPrototypePutEthernetLan(ctx context.Context, id string, locationId string, nodeId string, nodeEthernetLan interface{}) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodes/{nodeId}/ethernetLan"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &nodeEthernetLan
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Request Firmware Upgrade for a Location ID
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return []interface{}
*/
func (a *CustomerApiService) CustomerPrototypePutFirmwareUpgradeRequest(ctx context.Context, id string, locationId string) ([]interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/firmware"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Create or Update the frontline storage for a Location ID
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param data


*/
func (a *CustomerApiService) CustomerPrototypePutFrontlineStorage(ctx context.Context, id string, locationId string, data string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/frontline/storage"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("data", parameterToString(data, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Put GroupOfUnassignedDevices autoExpire freeze for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param expiresAt

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypePutGroupOfUnassignedDevicesFreezeAutoExpire(ctx context.Context, id string, locationId string, expiresAt string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/groupOfUnassignedDevices/freeze/autoExpire"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("expiresAt", parameterToString(expiresAt, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService PUT GroupOfUnassignedDevices forever for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypePutGroupOfUnassignedDevicesFreezeForever(ctx context.Context, id string, locationId string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/groupOfUnassignedDevices/freeze/forever"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService PUT GroupOfUnassignedDevices suspend for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypePutGroupOfUnassignedDevicesFreezeSuspend(ctx context.Context, id string, locationId string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/groupOfUnassignedDevices/freeze/suspend"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Inserts the iOS device token for the Customer ID, which may be used for notification services.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, most recent IOS device Token saved.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: deviceToken value must be defined.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param deviceToken


*/
func (a *CustomerApiService) CustomerPrototypePutIosDeviceToken(ctx context.Context, id string, deviceToken string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/iosDeviceToken/{deviceToken}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceToken"+"}", fmt.Sprintf("%v", deviceToken), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Enable|Disable ispSpeedTestConfiguration to schedule speed tests.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, run.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Customer or location does not exists.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param enable boolean but marked as &#39;any&#39; because our mobile app platforms mixed string and boolean primitive
 * @param optional nil or *CustomerApiCustomerPrototypePutIspSpeedTestConfigurationOpts - Optional Parameters:
     * @param "EnableAllNodes" (optional.String) -  boolean but treated as a string since it is optional

@return InlineResponse2004
*/

type CustomerApiCustomerPrototypePutIspSpeedTestConfigurationOpts struct { 
	EnableAllNodes optional.String
}

func (a *CustomerApiService) CustomerPrototypePutIspSpeedTestConfiguration(ctx context.Context, id string, locationId string, enable string, localVarOptionals *CustomerApiCustomerPrototypePutIspSpeedTestConfigurationOpts) (InlineResponse2004, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2004
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/ispSpeedTestConfiguration"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("enable", parameterToString(enable, ""))
	if localVarOptionals != nil && localVarOptionals.EnableAllNodes.IsSet() {
		localVarFormParams.Add("enableAllNodes", parameterToString(localVarOptionals.EnableAllNodes.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2004
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update the LED mode on a particular Node for a Location ID.
When the mode is set to \&quot;locate\&quot;, the Node with that ID at this locationId, will have its LED blinked for locating purposes. The mode is set to \&quot;normal\&quot; to return the LED to its normal mode of operation. &lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, your new info looks good.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: ledMode must be defined.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: ledMode must be \&quot;locate\&quot; or \&quot;normal\&quot;.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: nodeId must be defined.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;425&lt;/strong&gt;: nodeId must belong to the location.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param nodeId
 * @param optional nil or *CustomerApiCustomerPrototypePutLedModeOpts - Optional Parameters:
     * @param "Mode" (optional.String) -  locate/normal

@return InlineResponse2003
*/

type CustomerApiCustomerPrototypePutLedModeOpts struct { 
	Mode optional.String
}

func (a *CustomerApiService) CustomerPrototypePutLedMode(ctx context.Context, id string, locationId string, nodeId string, localVarOptionals *CustomerApiCustomerPrototypePutLedModeOpts) (InlineResponse2003, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2003
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodes/{nodeId}/ledMode"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Mode.IsSet() {
		localVarFormParams.Add("mode", parameterToString(localVarOptionals.Mode.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2003
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Configure locale values for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Region value is not valid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param region during optimizations, used to determine allowed WiFi channels. Possible values: US, SINGAPORE, UK, EU, CANADA, JP.

@return Locale
*/
func (a *CustomerApiService) CustomerPrototypePutLocale(ctx context.Context, id string, locationId string, region string) (Locale, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Locale
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/locale"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("region", parameterToString(region, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Locale
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update the Device UUID Mapping for Out of Home Protection.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param uuid
 * @param optional nil or *CustomerApiCustomerPrototypePutLocationSecurityPolicyOHPDeviceUuidMappingOpts - Optional Parameters:
     * @param "LanIpv4" (optional.String) -  Mobile device lanIpv4 address, if any
     * @param "LanIpv6" (optional.String) -  Mobile device lanIpv6 address, if any

@return interface{}
*/

type CustomerApiCustomerPrototypePutLocationSecurityPolicyOHPDeviceUuidMappingOpts struct { 
	LanIpv4 optional.String
	LanIpv6 optional.String
}

func (a *CustomerApiService) CustomerPrototypePutLocationSecurityPolicyOHPDeviceUuidMapping(ctx context.Context, id string, locationId string, uuid string, localVarOptionals *CustomerApiCustomerPrototypePutLocationSecurityPolicyOHPDeviceUuidMappingOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy/ohp/deviceUuid"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.LanIpv4.IsSet() {
		localVarFormParams.Add("lanIpv4", parameterToString(localVarOptionals.LanIpv4.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LanIpv6.IsSet() {
		localVarFormParams.Add("lanIpv6", parameterToString(localVarOptionals.LanIpv6.Value(), ""))
	}
	localVarFormParams.Add("uuid", parameterToString(uuid, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update the Device Protection State for Out of Home Protection.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param uuid Mobile device uuid (as was assigned by Mobolize)
 * @param optional nil or *CustomerApiCustomerPrototypePutLocationSecurityPolicyOHPProtectionStateOpts - Optional Parameters:
     * @param "ProtectionState" (optional.String) -  ProtectionState info as obtained directly from the Mobolize SDK, null if deleting ProtectionState

@return interface{}
*/

type CustomerApiCustomerPrototypePutLocationSecurityPolicyOHPProtectionStateOpts struct { 
	ProtectionState optional.String
}

func (a *CustomerApiService) CustomerPrototypePutLocationSecurityPolicyOHPProtectionState(ctx context.Context, id string, locationId string, uuid string, localVarOptionals *CustomerApiCustomerPrototypePutLocationSecurityPolicyOHPProtectionStateOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy/ohp/protectionState"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("uuid", parameterToString(uuid, ""))
	if localVarOptionals != nil && localVarOptionals.ProtectionState.IsSet() {
		localVarFormParams.Add("protectionState", parameterToString(localVarOptionals.ProtectionState.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Persist WAN Configuration for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Required fields are not valid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePutLocationWanConfigurationOpts - Optional Parameters:
     * @param "Pppoe" (optional.String) - 
     * @param "Uplink" (optional.String) - 
     * @param "StaticIPv4" (optional.String) - 
     * @param "PublishedWithBLE" (optional.Bool) - 

@return interface{}
*/

type CustomerApiCustomerPrototypePutLocationWanConfigurationOpts struct { 
	Pppoe optional.String
	Uplink optional.String
	StaticIPv4 optional.String
	PublishedWithBLE optional.Bool
}

func (a *CustomerApiService) CustomerPrototypePutLocationWanConfiguration(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePutLocationWanConfigurationOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wanConfiguration"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Pppoe.IsSet() {
		localVarFormParams.Add("pppoe", parameterToString(localVarOptionals.Pppoe.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uplink.IsSet() {
		localVarFormParams.Add("uplink", parameterToString(localVarOptionals.Uplink.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StaticIPv4.IsSet() {
		localVarFormParams.Add("staticIPv4", parameterToString(localVarOptionals.StaticIPv4.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PublishedWithBLE.IsSet() {
		localVarFormParams.Add("publishedWithBLE", parameterToString(localVarOptionals.PublishedWithBLE.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService DEPRECATED: Persist WAN Settings for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Required fields are not valid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param wanSettings

@return LocationWanSettings
*/
func (a *CustomerApiService) CustomerPrototypePutLocationWanSettings(ctx context.Context, id string, locationId string, wanSettings LocationWanSettings) (LocationWanSettings, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue LocationWanSettings
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wanSettings"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &wanSettings
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v LocationWanSettings
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Enable/disable monitor mode for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param enable

@return LocationMonitorMode
*/
func (a *CustomerApiService) CustomerPrototypePutMonitorMode(ctx context.Context, id string, locationId string, enable string) (LocationMonitorMode, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue LocationMonitorMode
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/monitorMode"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("enable", parameterToString(enable, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v LocationMonitorMode
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update the Network Mode for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, your new info looks good.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePutNetworkModeOpts - Optional Parameters:
     * @param "NetworkMode" (optional.String) - 

@return InlineResponse2006
*/

type CustomerApiCustomerPrototypePutNetworkModeOpts struct { 
	NetworkMode optional.String
}

func (a *CustomerApiService) CustomerPrototypePutNetworkMode(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePutNetworkModeOpts) (InlineResponse2006, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2006
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkMode"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.NetworkMode.IsSet() {
		localVarFormParams.Add("networkMode", parameterToString(localVarOptionals.NetworkMode.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2006
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Enable/disable optimizations for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid dfsMode, prefer160MhzMode, hopPenalty or preCACScheduler provided.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param auto defaults to true
 * @param optional nil or *CustomerApiCustomerPrototypePutOptimizationsOpts - Optional Parameters:
     * @param "DfsMode" (optional.String) -  enum of values include: auto, enable, disable, demo, HomeNonDFSChannels, usDfs, deviceAware
     * @param "Prefer160MhzMode" (optional.String) -  enum of values include: auto, enable, disable
     * @param "HopPenalty" (optional.String) -  enum of values include: auto, low, medium, high
     * @param "PreCACScheduler" (optional.String) -  enum of values include: auto, enable, disable

@return Optimizations
*/

type CustomerApiCustomerPrototypePutOptimizationsOpts struct { 
	DfsMode optional.String
	Prefer160MhzMode optional.String
	HopPenalty optional.String
	PreCACScheduler optional.String
}

func (a *CustomerApiService) CustomerPrototypePutOptimizations(ctx context.Context, id string, locationId string, auto string, localVarOptionals *CustomerApiCustomerPrototypePutOptimizationsOpts) (Optimizations, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Optimizations
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/optimizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("auto", parameterToString(auto, ""))
	if localVarOptionals != nil && localVarOptionals.DfsMode.IsSet() {
		localVarFormParams.Add("dfsMode", parameterToString(localVarOptionals.DfsMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Prefer160MhzMode.IsSet() {
		localVarFormParams.Add("prefer160MhzMode", parameterToString(localVarOptionals.Prefer160MhzMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HopPenalty.IsSet() {
		localVarFormParams.Add("hopPenalty", parameterToString(localVarOptionals.HopPenalty.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PreCACScheduler.IsSet() {
		localVarFormParams.Add("preCACScheduler", parameterToString(localVarOptionals.PreCACScheduler.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Optimizations
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Push Secondary Network Configurations to Overlord.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId


*/
func (a *CustomerApiService) CustomerPrototypePutOverlordResync(ctx context.Context, id string, locationId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/overlord/resync"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Update settings for persistConfigurationOnGateway.
Supported modes are: * enable/disable/auto  &lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, new ethernetLan settings saved.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Input validation error, see output for details.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param persistConfigurationOnGateway ethernetLan object

@return EthernetLan
*/
func (a *CustomerApiService) CustomerPrototypePutPersistConfigurationOnGateway(ctx context.Context, id string, locationId string, persistConfigurationOnGateway EthernetLan) (EthernetLan, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue EthernetLan
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkConfiguration/persistConfigurationOnGateway"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &persistConfigurationOnGateway
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v EthernetLan
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Put a person to be frozen for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt; &lt;div&gt;&lt;strong&gt;501&lt;/strong&gt;: Not Implemented, if location is utilizing shared location freeze schedules&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId
 * @param freezeTemplateId Valid templates are &#39;untilMidinight&#39;, &#39;schoolNights&#39;, etc.
 * @param optional nil or *CustomerApiCustomerPrototypePutPersonFreezeOpts - Optional Parameters:
     * @param "DeleteAllExceptSuspend" (optional.Bool) - 
     * @param "Schedules" (optional.String) - 
     * @param "Enable" (optional.Bool) - 
     * @param "Name" (optional.String) - 

@return XAny
*/

type CustomerApiCustomerPrototypePutPersonFreezeOpts struct { 
	DeleteAllExceptSuspend optional.Bool
	Schedules optional.String
	Enable optional.Bool
	Name optional.String
}

func (a *CustomerApiService) CustomerPrototypePutPersonFreeze(ctx context.Context, id string, locationId string, personId string, freezeTemplateId string, localVarOptionals *CustomerApiCustomerPrototypePutPersonFreezeOpts) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/freeze/{freezeTemplateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"freezeTemplateId"+"}", fmt.Sprintf("%v", freezeTemplateId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.DeleteAllExceptSuspend.IsSet() {
		localVarFormParams.Add("deleteAllExceptSuspend", parameterToString(localVarOptionals.DeleteAllExceptSuspend.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Schedules.IsSet() {
		localVarFormParams.Add("schedules", parameterToString(localVarOptionals.Schedules.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enable.IsSet() {
		localVarFormParams.Add("enable", parameterToString(localVarOptionals.Enable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Put all devices from a person to be frozen for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId
 * @param expiresAt

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypePutPersonFreezeAutoExpire(ctx context.Context, id string, locationId string, personId string, expiresAt string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/freeze/autoExpire"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("expiresAt", parameterToString(expiresAt, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Put a person forever freeze for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId
 * @param optional nil or *CustomerApiCustomerPrototypePutPersonFreezeForeverOpts - Optional Parameters:
     * @param "DeleteAllExceptSuspend" (optional.Bool) - 
     * @param "Enable" (optional.Bool) - 

@return XAny
*/

type CustomerApiCustomerPrototypePutPersonFreezeForeverOpts struct { 
	DeleteAllExceptSuspend optional.Bool
	Enable optional.Bool
}

func (a *CustomerApiService) CustomerPrototypePutPersonFreezeForever(ctx context.Context, id string, locationId string, personId string, localVarOptionals *CustomerApiCustomerPrototypePutPersonFreezeForeverOpts) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/freeze/forever"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.DeleteAllExceptSuspend.IsSet() {
		localVarFormParams.Add("deleteAllExceptSuspend", parameterToString(localVarOptionals.DeleteAllExceptSuspend.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enable.IsSet() {
		localVarFormParams.Add("enable", parameterToString(localVarOptionals.Enable.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Put a person suspend for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param personId
 * @param optional nil or *CustomerApiCustomerPrototypePutPersonFreezeSuspendOpts - Optional Parameters:
     * @param "DeleteAllExceptSuspend" (optional.Bool) - 
     * @param "Enable" (optional.Bool) - 

@return XAny
*/

type CustomerApiCustomerPrototypePutPersonFreezeSuspendOpts struct { 
	DeleteAllExceptSuspend optional.Bool
	Enable optional.Bool
}

func (a *CustomerApiService) CustomerPrototypePutPersonFreezeSuspend(ctx context.Context, id string, locationId string, personId string, localVarOptionals *CustomerApiCustomerPrototypePutPersonFreezeSuspendOpts) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/persons/{personId}/freeze/suspend"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"personId"+"}", fmt.Sprintf("%v", personId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.DeleteAllExceptSuspend.IsSet() {
		localVarFormParams.Add("deleteAllExceptSuspend", parameterToString(localVarOptionals.DeleteAllExceptSuspend.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enable.IsSet() {
		localVarFormParams.Add("enable", parameterToString(localVarOptionals.Enable.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update an existing Port Forwarding entry for an existing DHCP IP reservation tied to a MAC address at a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, all PortForwards are returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: networkConfiguration, dhcpReservation, PortForward is empty.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: mac is empty, or invalid, externalPort/internalPort is out of range, or protocol is invalid.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac
 * @param externalPort
 * @param optional nil or *CustomerApiCustomerPrototypePutPortForwardOpts - Optional Parameters:
     * @param "InternalPort" (optional.String) - 
     * @param "Protocol" (optional.String) - 
     * @param "Name" (optional.String) - 

@return PortForward
*/

type CustomerApiCustomerPrototypePutPortForwardOpts struct { 
	InternalPort optional.String
	Protocol optional.String
	Name optional.String
}

func (a *CustomerApiService) CustomerPrototypePutPortForward(ctx context.Context, id string, locationId string, mac string, externalPort string, localVarOptionals *CustomerApiCustomerPrototypePutPortForwardOpts) (PortForward, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PortForward
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkConfiguration/dhcpReservations/{mac}/portForward/{externalPort}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"externalPort"+"}", fmt.Sprintf("%v", externalPort), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.InternalPort.IsSet() {
		localVarFormParams.Add("internalPort", parameterToString(localVarOptionals.InternalPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Protocol.IsSet() {
		localVarFormParams.Add("protocol", parameterToString(localVarOptionals.Protocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v PortForward
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Updates location sniffing toggle modes
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param dns object with property \&quot;mode\&quot;: an enum of values which include: auto, enable, disable
 * @param http object with property \&quot;mode\&quot;: an enum of values which include: auto, enable, disable
 * @param upnp object with property \&quot;mode\&quot;: an enum of values which include: auto, enable, disable
 * @param mdns object with property \&quot;mode\&quot;: an enum of values which include: auto, enable, disable


*/
func (a *CustomerApiService) CustomerPrototypePutSniffing(ctx context.Context, id string, locationId string, dns string, http string, upnp string, mdns string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/sniffing"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("dns", parameterToString(dns, ""))
	localVarFormParams.Add("http", parameterToString(http, ""))
	localVarFormParams.Add("upnp", parameterToString(upnp, ""))
	localVarFormParams.Add("mdns", parameterToString(mdns, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Snooze an alert on a device.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id does not exist or device mac not in this account&#39;s recent history.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid alert type and/or state.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac mac of device
 * @param type_ enum of values include: poorHealth
 * @param optional nil or *CustomerApiCustomerPrototypePutSnoozeOnDeviceAlertOpts - Optional Parameters:
     * @param "State" (optional.String) -  enum of values include: snooze, ignore, performanceAcceptable

@return Device
*/

type CustomerApiCustomerPrototypePutSnoozeOnDeviceAlertOpts struct { 
	State optional.String
}

func (a *CustomerApiService) CustomerPrototypePutSnoozeOnDeviceAlert(ctx context.Context, id string, locationId string, mac string, type_ string, localVarOptionals *CustomerApiCustomerPrototypePutSnoozeOnDeviceAlertOpts) (Device, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Device
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/alerts/{type}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", fmt.Sprintf("%v", type_), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarFormParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Device
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Snooze an alert on a node.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id does not exist or nodeId not claimed to this account.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid alert type and/or state.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param nodeId id of node
 * @param type_ enum of values include: poorHealth
 * @param optional nil or *CustomerApiCustomerPrototypePutSnoozeOnNodeAlertOpts - Optional Parameters:
     * @param "State" (optional.String) -  enum of values include: snooze, ignore, performanceAcceptable, reset

@return Node
*/

type CustomerApiCustomerPrototypePutSnoozeOnNodeAlertOpts struct { 
	State optional.String
}

func (a *CustomerApiService) CustomerPrototypePutSnoozeOnNodeAlert(ctx context.Context, id string, locationId string, nodeId string, type_ string, localVarOptionals *CustomerApiCustomerPrototypePutSnoozeOnNodeAlertOpts) (Node, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Node
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodes/{nodeId}/alerts/{type}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", fmt.Sprintf("%v", nodeId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", fmt.Sprintf("%v", type_), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarFormParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Node
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Put Subscription details for this location
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, service level returned&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: customer id or location id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param ratePlanId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypePutSubscription(ctx context.Context, id string, locationId string, ratePlanId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/subscription"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("ratePlanId", parameterToString(ratePlanId, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update the UPnP setting for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, new Upnp saved.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Upnp value is empty.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePutUpnpOpts - Optional Parameters:
     * @param "Enabled" (optional.String) -  DEPRECATED: boolean but marked as &#39;any&#39; because our mobile app platforms mixed string and boolean primitive
     * @param "Mode" (optional.String) -  Possible values enable/disable/auto

@return Upnp
*/

type CustomerApiCustomerPrototypePutUpnpOpts struct { 
	Enabled optional.String
	Mode optional.String
}

func (a *CustomerApiService) CustomerPrototypePutUpnp(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePutUpnpOpts) (Upnp, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Upnp
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkConfiguration/upnp"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarFormParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Mode.IsSet() {
		localVarFormParams.Add("mode", parameterToString(localVarOptionals.Mode.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Upnp
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a WiFi Password
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, all passwords returned&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Customer id, location id, or WifiNetwork does not exist&lt;/div&gt; &lt;div&gt;&lt;strong&gt;405&lt;/strong&gt;: Cannot disable a read-only key&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Password validation failed&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param accessZone home | guests | internetAccessOnly
 * @param keyId Unique password id: 0-9
 * @param encryptionKey
 * @param enable devices can connect using this encryptionKey
 * @param format encryptionKey | phoneNumber
 * @param optional nil or *CustomerApiCustomerPrototypePutWifiKeyOpts - Optional Parameters:
     * @param "ExpiresAt" (optional.Time) -  UTC in ISO 8601 String format
     * @param "Content" (optional.String) -  Valid values: &#39;adultAndSensitive&#39;

@return []WifiNetworkKey
*/

type CustomerApiCustomerPrototypePutWifiKeyOpts struct { 
	ExpiresAt optional.Time
	Content optional.String
}

func (a *CustomerApiService) CustomerPrototypePutWifiKey(ctx context.Context, id string, locationId string, accessZone string, keyId float64, encryptionKey string, enable bool, format string, localVarOptionals *CustomerApiCustomerPrototypePutWifiKeyOpts) ([]WifiNetworkKey, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []WifiNetworkKey
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork/accessZones/{accessZone}/keys/{keyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accessZone"+"}", fmt.Sprintf("%v", accessZone), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keyId"+"}", fmt.Sprintf("%v", keyId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("encryptionKey", parameterToString(encryptionKey, ""))
	localVarFormParams.Add("enable", parameterToString(enable, ""))
	localVarFormParams.Add("format", parameterToString(format, ""))
	if localVarOptionals != nil && localVarOptionals.ExpiresAt.IsSet() {
		localVarFormParams.Add("expiresAt", parameterToString(localVarOptionals.ExpiresAt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Content.IsSet() {
		localVarFormParams.Add("content", parameterToString(localVarOptionals.Content.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []WifiNetworkKey
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a WiFi SSID and/or PSK for a Location ID.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, your new info looks good.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id, or wifi network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: encryptionKey or ssid must be defined.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypePutWifiNetworkOpts - Optional Parameters:
     * @param "EncryptionKey" (optional.String) - 
     * @param "Ssid" (optional.String) - 
     * @param "WpaMode" (optional.String) - 

@return InlineResponse2002
*/

type CustomerApiCustomerPrototypePutWifiNetworkOpts struct { 
	EncryptionKey optional.String
	Ssid optional.String
	WpaMode optional.String
}

func (a *CustomerApiService) CustomerPrototypePutWifiNetwork(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypePutWifiNetworkOpts) (InlineResponse2002, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2002
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.EncryptionKey.IsSet() {
		localVarFormParams.Add("encryptionKey", parameterToString(localVarOptionals.EncryptionKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ssid.IsSet() {
		localVarFormParams.Add("ssid", parameterToString(localVarOptionals.Ssid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WpaMode.IsSet() {
		localVarFormParams.Add("wpaMode", parameterToString(localVarOptionals.WpaMode.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2002
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Reboots a particular on-line Node for a Location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, your new info looks good.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Delay, is not between 0 and 100000.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeRebootLocationOpts - Optional Parameters:
     * @param "Delay" (optional.String) - 


*/

type CustomerApiCustomerPrototypeRebootLocationOpts struct { 
	Delay optional.String
}

func (a *CustomerApiService) CustomerPrototypeRebootLocation(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeRebootLocationOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/reboot"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Delay.IsSet() {
		localVarFormParams.Add("delay", parameterToString(localVarOptionals.Delay.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Reboots a single on-line Node for a Location ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or nodeId, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Delay, is not between 0 and 100000.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param nodeId
 * @param optional nil or *CustomerApiCustomerPrototypeRebootNodeOpts - Optional Parameters:
     * @param "Delay" (optional.String) - 


*/

type CustomerApiCustomerPrototypeRebootNodeOpts struct { 
	Delay optional.String
}

func (a *CustomerApiService) CustomerPrototypeRebootNode(ctx context.Context, id string, locationId string, nodeId string, localVarOptionals *CustomerApiCustomerPrototypeRebootNodeOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodes/{nodeId}/reboot"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Delay.IsSet() {
		localVarFormParams.Add("delay", parameterToString(localVarOptionals.Delay.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Reject an approval request for a website whitelist
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, CustomerId or requst id does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param requestId

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeRejectWhitelistRequest(ctx context.Context, id string, locationId string, requestId string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/securityPolicy/websites/whitelist/approvalRequests/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", fmt.Sprintf("%v", requestId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Removes a device for a customer&#39;s location id, wiping config and setting a hidden flag.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, device removed from location. &lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id or  device not found. &lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error &lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac mac of device
 * @param optional nil or *CustomerApiCustomerPrototypeRemoveDeviceByMacOpts - Optional Parameters:
     * @param "DaysOffline" (optional.Float64) -  exclude devices disconnected longer than daysOffline. if not set, it will be 31. for older devices, it will return 404, \&quot;not found\&quot;


*/

type CustomerApiCustomerPrototypeRemoveDeviceByMacOpts struct { 
	DaysOffline optional.Float64
}

func (a *CustomerApiService) CustomerPrototypeRemoveDeviceByMac(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypeRemoveDeviceByMacOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.DaysOffline.IsSet() {
		localVarFormParams.Add("daysOffline", parameterToString(localVarOptionals.DaysOffline.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService DEPRECATED: Update home devices visible to guests.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, devicesVisibleToGuests returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Customer id, location id, or WifiNetwork does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Device mac validation failed.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac mac to be removed

@return []string
*/
func (a *CustomerApiService) CustomerPrototypeRemoveDeviceVisibleToGuests(ctx context.Context, id string, locationId string, mac string) ([]string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wifiNetwork/accessZones/home/devicesVisibleToGuests/{mac}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Rename a particular Node for a Location ID with the option to disable the blinking LED.
Rename a particular Node for a Location ID with the option to disable the blinking LED with the option \&quot;emitMessage\&quot;:\&quot;on\&quot; or \&quot;off\&quot;. &lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, a job well done.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Bad request, nickname is undefined or empty string.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required, customer id not found, &lt;br/&gt; or id not owned by requestor.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location ID or node ID not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param nodeId
 * @param nickname
 * @param optional nil or *CustomerApiCustomerPrototypeRenameNodeOpts - Optional Parameters:
     * @param "EmitMessage" (optional.String) - 

@return Node
*/

type CustomerApiCustomerPrototypeRenameNodeOpts struct { 
	EmitMessage optional.String
}

func (a *CustomerApiService) CustomerPrototypeRenameNode(ctx context.Context, id string, locationId string, nodeId string, nickname string, localVarOptionals *CustomerApiCustomerPrototypeRenameNodeOpts) (Node, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Node
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodes/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("nickname", parameterToString(nickname, ""))
	if localVarOptionals != nil && localVarOptionals.EmitMessage.IsSet() {
		localVarFormParams.Add("emitMessage", parameterToString(localVarOptionals.EmitMessage.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Node
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Resend invite to a manager that has status \&quot;pending\&quot;.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing or field type is incorrect.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location or Manager does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Manager already accepted the invite to manage the location &lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param managerId
 * @param optional nil or *CustomerApiCustomerPrototypeResendManagerInviteOpts - Optional Parameters:
     * @param "NotificationOptions" (optional.String) - 

@return interface{}
*/

type CustomerApiCustomerPrototypeResendManagerInviteOpts struct { 
	NotificationOptions optional.String
}

func (a *CustomerApiService) CustomerPrototypeResendManagerInvite(ctx context.Context, id string, locationId string, managerId string, localVarOptionals *CustomerApiCustomerPrototypeResendManagerInviteOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/managers/{managerId}/resendInvite"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"managerId"+"}", fmt.Sprintf("%v", managerId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.NotificationOptions.IsSet() {
		localVarFormParams.Add("notificationOptions", parameterToString(localVarOptionals.NotificationOptions.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Resets the back-off and thresholds for the given client.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Ok.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: No device found with provided mac address&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Invalid MAC.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypeResetTos(ctx context.Context, id string, locationId string, mac string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/tos/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Force a device to use the 2.4Ghz band with auto expire.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, forced steer enabled.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location ID or Device mac not found or the device has not been online in the last 31 days&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: expiresAt is outside of the expected range 5 to 60 minutes in the future&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: expiresAt is an invalid UTC date&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: expiresAt cannot be in the past&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId locationId
 * @param mac MAC address of the target device. Must have been online in the last 31 days.
 * @param optional nil or *CustomerApiCustomerPrototypeSetForcedSteerOpts - Optional Parameters:
     * @param "ExpiresAt" (optional.String) -  time of expiration in RFC 3339 format (e.g. 2021-11-24T09:13:33+00:00), must be between 5 and 60 minutes in the future.

@return interface{}
*/

type CustomerApiCustomerPrototypeSetForcedSteerOpts struct { 
	ExpiresAt optional.String
}

func (a *CustomerApiService) CustomerPrototypeSetForcedSteer(ctx context.Context, id string, locationId string, mac string, localVarOptionals *CustomerApiCustomerPrototypeSetForcedSteerOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/{mac}/forcedSteer"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ExpiresAt.IsSet() {
		localVarFormParams.Add("expiresAt", parameterToString(localVarOptionals.ExpiresAt.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Set networks at wpa3 transition flow
&lt;div&gt;&lt;strong&gt;202&lt;/strong&gt;: Success, accepted the data&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id does not exist&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Input validation failed.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeSetPrimarySecondaryNetworksOpts - Optional Parameters:
     * @param "Wpa3ssid" (optional.String) - 
     * @param "Wpa3encryptionKey" (optional.String) - 
     * @param "Wpa3enabled" (optional.Bool) - 
     * @param "Wpa2ssid" (optional.String) - 
     * @param "Wpa2enabled" (optional.Bool) - 


*/

type CustomerApiCustomerPrototypeSetPrimarySecondaryNetworksOpts struct { 
	Wpa3ssid optional.String
	Wpa3encryptionKey optional.String
	Wpa3enabled optional.Bool
	Wpa2ssid optional.String
	Wpa2enabled optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeSetPrimarySecondaryNetworks(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeSetPrimarySecondaryNetworksOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/primarySecondaryNetworks"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Wpa3ssid.IsSet() {
		localVarFormParams.Add("wpa3ssid", parameterToString(localVarOptionals.Wpa3ssid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Wpa3encryptionKey.IsSet() {
		localVarFormParams.Add("wpa3encryptionKey", parameterToString(localVarOptionals.Wpa3encryptionKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Wpa3enabled.IsSet() {
		localVarFormParams.Add("wpa3enabled", parameterToString(localVarOptionals.Wpa3enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Wpa2ssid.IsSet() {
		localVarFormParams.Add("wpa2ssid", parameterToString(localVarOptionals.Wpa2ssid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Wpa2enabled.IsSet() {
		localVarFormParams.Add("wpa2enabled", parameterToString(localVarOptionals.Wpa2enabled.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Share access to individual device. 
&lt;p&gt;This endpoint allows for a device in the first network to have access to all of the devices in the other group in the second network and/or to individual devices in the second network. In other words, by sharing access, we&#39;re allowing a single device to communicate with other devices across networks, by specifying other groups and/or individual devices.&lt;/p&gt; &lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Schema validation failed.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Illegal share.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Group does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Unauthorized.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Invalid JSON or missing arguments.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param mac
 * @param groups
 * @param devices

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeShareDevice(ctx context.Context, id string, locationId string, networkId string, mac string, groups string, devices string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkAccess/networks/{networkId}/devices/{mac}/groupShares"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("groups", parameterToString(groups, ""))
	localVarFormParams.Add("devices", parameterToString(devices, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Share access for a group or employee.
&lt;p&gt;This endpoint allows for a device in the first network to have access to all of the devices in the other group in the second network and/or to individual devices in the second network. In other words, by sharing access, we&#39;re allowing a single device to communicate with other devices across networks, by specifying other groups and/or individual devices.&lt;/p&gt; &lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Schema validation failed.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Illegal share.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Group does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Unauthorized.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Invalid JSON or missing arguments.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param groupId
 * @param groups
 * @param devices

@return interface{}
*/
func (a *CustomerApiService) CustomerPrototypeShareDeviceGroup(ctx context.Context, id string, locationId string, networkId string, groupId string, groups string, devices string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkAccess/networks/{networkId}/deviceGroups/{groupId}/groupShares"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", fmt.Sprintf("%v", groupId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("groups", parameterToString(groups, ""))
	localVarFormParams.Add("devices", parameterToString(devices, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Start a WPS session
&lt;div&gt;&lt;strong&gt;201&lt;/strong&gt;: Success, a WPS session was requested.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required &lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id not found or nodeId missing from URL &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param nodeId
 * @param optional nil or *CustomerApiCustomerPrototypeStartWpsOpts - Optional Parameters:
     * @param "KeyId" (optional.String) - 
     * @param "NetworkId" (optional.String) - 

@return XAny
*/

type CustomerApiCustomerPrototypeStartWpsOpts struct { 
	KeyId optional.String
	NetworkId optional.String
}

func (a *CustomerApiService) CustomerPrototypeStartWps(ctx context.Context, id string, locationId string, nodeId string, localVarOptionals *CustomerApiCustomerPrototypeStartWpsOpts) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/startWps"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("nodeId", parameterToString(nodeId, ""))
	if localVarOptionals != nil && localVarOptionals.KeyId.IsSet() {
		localVarFormParams.Add("keyId", parameterToString(localVarOptionals.KeyId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NetworkId.IsSet() {
		localVarFormParams.Add("networkId", parameterToString(localVarOptionals.NetworkId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Delete prioritization of a single device
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Unauthorized.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Missing oldMac or newMac field.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: oldMac or newMac is not valid mac.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: If oldMac and newMac are the same.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param oldMac
 * @param newMac


*/
func (a *CustomerApiService) CustomerPrototypeStitchDevice(ctx context.Context, id string, locationId string, oldMac string, newMac string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/devices/stitch"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("oldMac", parameterToString(oldMac, ""))
	localVarFormParams.Add("newMac", parameterToString(newMac, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Unapprove approved devices in the network
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Network does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Device is not approved.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param networkId
 * @param mac


*/
func (a *CustomerApiService) CustomerPrototypeUnapproveDevice(ctx context.Context, id string, locationId string, networkId string, mac string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkAccess/networks/{networkId}/approved/{mac}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", fmt.Sprintf("%v", networkId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Unblock blocked devices
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location does not exist.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param mac


*/
func (a *CustomerApiService) CustomerPrototypeUnblockDevice(ctx context.Context, id string, locationId string, mac string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/networkAccess/blocked/{mac}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mac"+"}", fmt.Sprintf("%v", mac), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Unclaim all Nodes from a Location ID with the option of preserving the original Package ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, a job well done.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required, customer id not found, &lt;br/&gt; or id not owned by requestor.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id not found in customer service or not found in inventory service.&lt;p/&gt;  &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param optional nil or *CustomerApiCustomerPrototypeUnclaimAllNodesOpts - Optional Parameters:
     * @param "PreservePackId" (optional.Bool) -  packId should remain the same
     * @param "RemoveAccountId" (optional.Bool) -  delete account ids on the inventory nodes


*/

type CustomerApiCustomerPrototypeUnclaimAllNodesOpts struct { 
	PreservePackId optional.Bool
	RemoveAccountId optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeUnclaimAllNodes(ctx context.Context, id string, locationId string, localVarOptionals *CustomerApiCustomerPrototypeUnclaimAllNodesOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodes"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.PreservePackId.IsSet() {
		localVarFormParams.Add("preservePackId", parameterToString(localVarOptionals.PreservePackId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemoveAccountId.IsSet() {
		localVarFormParams.Add("removeAccountId", parameterToString(localVarOptionals.RemoveAccountId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Unclaim a particular Node from a Location ID with the option of preserving the original Package ID.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, a job well done.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Pod already unclaimed.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required, customer id not found, &lt;br/&gt; or id not owned by requestor.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;403&lt;/strong&gt;: the node is online, and can not be unclaimed.&lt;br/&gt;  &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id not found, nodeId missing from URL,&lt;br/&gt; or location has zero owned pods.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param nodeId
 * @param optional nil or *CustomerApiCustomerPrototypeUnclaimNodeOpts - Optional Parameters:
     * @param "PreservePackId" (optional.Bool) -  packId should remain the same
     * @param "RemoveAccountId" (optional.Bool) -  delete account id on the inventory node


*/

type CustomerApiCustomerPrototypeUnclaimNodeOpts struct { 
	PreservePackId optional.Bool
	RemoveAccountId optional.Bool
}

func (a *CustomerApiService) CustomerPrototypeUnclaimNode(ctx context.Context, id string, locationId string, nodeId string, localVarOptionals *CustomerApiCustomerPrototypeUnclaimNodeOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/nodes/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.PreservePackId.IsSet() {
		localVarFormParams.Add("preservePackId", parameterToString(localVarOptionals.PreservePackId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemoveAccountId.IsSet() {
		localVarFormParams.Add("removeAccountId", parameterToString(localVarOptionals.RemoveAccountId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Update the location name.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id, does not exist.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId
 * @param name

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypeUpdateLocationName(ctx context.Context, id string, locationId string, name string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update _migration of this model.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param optional nil or *CustomerApiCustomerPrototypeUpdateMigrationOpts - Optional Parameters:
     * @param "Data" (optional.Interface of Migration) - 

@return Migration
*/

type CustomerApiCustomerPrototypeUpdateMigrationOpts struct { 
	Data optional.Interface
}

func (a *CustomerApiService) CustomerPrototypeUpdateMigration(ctx context.Context, id string, localVarOptionals *CustomerApiCustomerPrototypeUpdateMigrationOpts) (Migration, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Migration
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/_migration"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Data.IsSet() {
		
		localVarOptionalData, localVarOptionalDataok := localVarOptionals.Data.Value().(Migration)
		if !localVarOptionalDataok {
				return localVarReturnValue, nil, reportError("data should be Migration")
		}
		localVarPostBody = &localVarOptionalData
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Migration
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Update a terms and privacy acceptance for customer.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, terms and privacy updated.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Input validation failed.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param optional nil or *CustomerApiCustomerPrototypeUpdateTermsAndPrivacyOpts - Optional Parameters:
     * @param "TermsDocumentId" (optional.Float64) - 
     * @param "PrivacyDocumentId" (optional.Float64) - 
     * @param "TermsAcceptedAt" (optional.Time) - 
     * @param "PrivacyAcceptedAt" (optional.Time) - 

@return TermsAndPrivacy
*/

type CustomerApiCustomerPrototypeUpdateTermsAndPrivacyOpts struct { 
	TermsDocumentId optional.Float64
	PrivacyDocumentId optional.Float64
	TermsAcceptedAt optional.Time
	PrivacyAcceptedAt optional.Time
}

func (a *CustomerApiService) CustomerPrototypeUpdateTermsAndPrivacy(ctx context.Context, id string, localVarOptionals *CustomerApiCustomerPrototypeUpdateTermsAndPrivacyOpts) (TermsAndPrivacy, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue TermsAndPrivacy
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/termsAndPrivacyAccepted"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.TermsDocumentId.IsSet() {
		localVarFormParams.Add("termsDocumentId", parameterToString(localVarOptionals.TermsDocumentId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PrivacyDocumentId.IsSet() {
		localVarFormParams.Add("privacyDocumentId", parameterToString(localVarOptionals.PrivacyDocumentId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TermsAcceptedAt.IsSet() {
		localVarFormParams.Add("termsAcceptedAt", parameterToString(localVarOptionals.TermsAcceptedAt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PrivacyAcceptedAt.IsSet() {
		localVarFormParams.Add("privacyAcceptedAt", parameterToString(localVarOptionals.PrivacyAcceptedAt.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v TermsAndPrivacy
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get customer details with userInfo access token.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, customer details returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization Required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id

@return Customer
*/
func (a *CustomerApiService) CustomerPrototypeUserInfo(ctx context.Context, id string) (Customer, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Customer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/userInfo"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Customer
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Verifies the email token and activates tokens related to it. Returns verified text with redirect to \&quot;signup complete deep link\&quot;
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Success, return new appToken and send out the email with emailToken.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: nodeId must be defined.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id


*/
func (a *CustomerApiService) CustomerPrototypeVerifyEmailPasswordlessToken(ctx context.Context, id string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/passwordLessToken"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Returns vlanServices from Customer location state
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Location id or WifiNetwork does not exist and is not known to Plume&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypeVlanServices(ctx context.Context, id string, locationId string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/vlanServices"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Get WPS state
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, a job well done.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required &lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: location id not found or nodeId missing from URL &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Customer id
 * @param locationId

@return XAny
*/
func (a *CustomerApiService) CustomerPrototypeWpsState(ctx context.Context, id string, locationId string) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/{id}/locations/{locationId}/wpsState"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", fmt.Sprintf("%v", locationId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Refresh access and refresh tokens
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, access and refresh tokens created and returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization Required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CustomerApiCustomerRefreshOauthAccessTokenOpts - Optional Parameters:
     * @param "RefreshToken" (optional.String) - 
     * @param "ClientId" (optional.String) - 

@return interface{}
*/

type CustomerApiCustomerRefreshOauthAccessTokenOpts struct { 
	RefreshToken optional.String
	ClientId optional.String
}

func (a *CustomerApiService) CustomerRefreshOauthAccessToken(ctx context.Context, localVarOptionals *CustomerApiCustomerRefreshOauthAccessTokenOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/refreshOauthAccessToken"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.RefreshToken.IsSet() {
		localVarFormParams.Add("refreshToken", parameterToString(localVarOptionals.RefreshToken.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClientId.IsSet() {
		localVarFormParams.Add("clientId", parameterToString(localVarOptionals.ClientId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Register/create an anonymous account with an accountId instead of with email/password.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, customer and location IDs returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields are missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Input validation failed.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Only integration role can set profile to property.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountId must be unique, a UUID is recommended, min length is 6 characters.
 * @param optional nil or *CustomerApiCustomerRegisterOpts - Optional Parameters:
     * @param "Name" (optional.String) -  Full name of customer, defaults to value of accountId
     * @param "PartnerId" (optional.String) -  PartnerId of customer for accountId
     * @param "Email" (optional.String) - 
     * @param "AcceptLanguage" (optional.String) -  acceptable language
     * @param "Profile" (optional.String) -  location profile
     * @param "OnboardingCheckpoint" (optional.String) -  is the last passed onboarding step by the customer: &#39;PodsAdded&#39; or &#39;OnboardingComplete&#39;;

@return RegisterResponse
*/

type CustomerApiCustomerRegisterOpts struct { 
	Name optional.String
	PartnerId optional.String
	Email optional.String
	AcceptLanguage optional.String
	Profile optional.String
	OnboardingCheckpoint optional.String
}

func (a *CustomerApiService) CustomerRegister(ctx context.Context, accountId string, localVarOptionals *CustomerApiCustomerRegisterOpts) (RegisterResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RegisterResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/register"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("accountId", parameterToString(accountId, ""))
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PartnerId.IsSet() {
		localVarFormParams.Add("partnerId", parameterToString(localVarOptionals.PartnerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Email.IsSet() {
		localVarFormParams.Add("email", parameterToString(localVarOptionals.Email.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AcceptLanguage.IsSet() {
		localVarFormParams.Add("acceptLanguage", parameterToString(localVarOptionals.AcceptLanguage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Profile.IsSet() {
		localVarFormParams.Add("profile", parameterToString(localVarOptionals.Profile.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnboardingCheckpoint.IsSet() {
		localVarFormParams.Add("onboardingCheckpoint", parameterToString(localVarOptionals.OnboardingCheckpoint.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v RegisterResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Register/create an account with an accountId plus email/password/groups.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, customer and location IDs returned.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Required fields are missing.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: Input validation failed.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param email
 * @param accountId must be unique, a UUID is recommended, min length is 6 characters.
 * @param name Full name of customer, defaults to value of accountId
 * @param optional nil or *CustomerApiCustomerRegisterWithGroupsOpts - Optional Parameters:
     * @param "Password" (optional.String) - 
     * @param "GroupIds" (optional.String) -  at least one groupId
     * @param "PartnerId" (optional.String) -  PartnerId of customer for accountId
     * @param "AcceptLanguage" (optional.String) -  acceptable language
     * @param "Profile" (optional.String) -  location profile

@return RegisterResponse
*/

type CustomerApiCustomerRegisterWithGroupsOpts struct { 
	Password optional.String
	GroupIds optional.String
	PartnerId optional.String
	AcceptLanguage optional.String
	Profile optional.String
}

func (a *CustomerApiService) CustomerRegisterWithGroups(ctx context.Context, email string, accountId string, name string, localVarOptionals *CustomerApiCustomerRegisterWithGroupsOpts) (RegisterResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RegisterResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/registerWithGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("email", parameterToString(email, ""))
	if localVarOptionals != nil && localVarOptionals.Password.IsSet() {
		localVarFormParams.Add("password", parameterToString(localVarOptionals.Password.Value(), ""))
	}
	localVarFormParams.Add("accountId", parameterToString(accountId, ""))
	localVarFormParams.Add("name", parameterToString(name, ""))
	if localVarOptionals != nil && localVarOptionals.GroupIds.IsSet() {
		localVarFormParams.Add("groupIds", parameterToString(localVarOptionals.GroupIds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PartnerId.IsSet() {
		localVarFormParams.Add("partnerId", parameterToString(localVarOptionals.PartnerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AcceptLanguage.IsSet() {
		localVarFormParams.Add("acceptLanguage", parameterToString(localVarOptionals.AcceptLanguage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Profile.IsSet() {
		localVarFormParams.Add("profile", parameterToString(localVarOptionals.Profile.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v RegisterResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CustomerApiService Resend the verification email.
&lt;div&gt;&lt;strong&gt;204&lt;/strong&gt;: Successfully sent email verification.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;400&lt;/strong&gt;: Customer email is required (for this request).&lt;/div&gt; &lt;div&gt;&lt;strong&gt;404&lt;/strong&gt;: Unable to find Customer by email address.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;409&lt;/strong&gt;: Customer email already verified.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: Internal server error.&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CustomerApiCustomerResendEmailVerificationOpts - Optional Parameters:
     * @param "Email" (optional.String) -  Email address that verification email will be sent to.
     * @param "NotificationOptions" (optional.String) - 


*/

type CustomerApiCustomerResendEmailVerificationOpts struct { 
	Email optional.String
	NotificationOptions optional.String
}

func (a *CustomerApiService) CustomerResendEmailVerification(ctx context.Context, localVarOptionals *CustomerApiCustomerResendEmailVerificationOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/resendEmailVerification"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Email.IsSet() {
		localVarFormParams.Add("email", parameterToString(localVarOptionals.Email.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NotificationOptions.IsSet() {
		localVarFormParams.Add("notificationOptions", parameterToString(localVarOptionals.NotificationOptions.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Reset password for a user with email.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param options


*/
func (a *CustomerApiService) CustomerResetPassword(ctx context.Context, options interface{}) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/reset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &options
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CustomerApiService Search the keyword on a particular field such as \&quot;accountId\&quot;, \&quot;name\&quot;, \&quot;email\&quot;.
&lt;div&gt;&lt;strong&gt;200&lt;/strong&gt;: Success, return the search result.&lt;/div&gt; &lt;div&gt;&lt;strong&gt;401&lt;/strong&gt;: Authorization required or customer id not found&lt;/div&gt; &lt;div&gt;&lt;strong&gt;422&lt;/strong&gt;: \&quot;illegal field\&quot;&lt;/div&gt; &lt;div&gt;&lt;strong&gt;500&lt;/strong&gt;: internal server error&lt;/div&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param keyword
 * @param field
 * @param optional nil or *CustomerApiCustomerSearchFieldsOpts - Optional Parameters:
     * @param "ExactMatch" (optional.Bool) - 
     * @param "StartsWith" (optional.Bool) - 

@return XAny
*/

type CustomerApiCustomerSearchFieldsOpts struct { 
	ExactMatch optional.Bool
	StartsWith optional.Bool
}

func (a *CustomerApiService) CustomerSearchFields(ctx context.Context, keyword string, field string, localVarOptionals *CustomerApiCustomerSearchFieldsOpts) (XAny, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue XAny
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Customers/search/{keyword}"
	localVarPath = strings.Replace(localVarPath, "{"+"keyword"+"}", fmt.Sprintf("%v", keyword), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("field", parameterToString(field, ""))
	if localVarOptionals != nil && localVarOptionals.ExactMatch.IsSet() {
		localVarQueryParams.Add("exactMatch", parameterToString(localVarOptionals.ExactMatch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartsWith.IsSet() {
		localVarQueryParams.Add("startsWith", parameterToString(localVarOptionals.StartsWith.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "application/xml", "text/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml", "text/xml", "application/javascript", "text/javascript"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v XAny
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

